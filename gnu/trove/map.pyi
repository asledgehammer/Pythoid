from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from gnu.trove import TIntCollection, TLongCollection, TShortCollection
from gnu.trove.function import TIntFunction, TLongFunction, TObjectFunction, TShortFunction
from gnu.trove.iterator import TIntIntIterator, TIntLongIterator, TIntObjectIterator, TLongObjectIterator, TObjectIntIterator, TShortObjectIterator, TShortShortIterator
from gnu.trove.procedure import TIntIntProcedure, TIntProcedure, TIntLongProcedure, TLongProcedure, TIntObjectProcedure, TObjectProcedure, TLongObjectProcedure, TObjectObjectProcedure, TObjectIntProcedure, TShortObjectProcedure, TShortProcedure, TShortShortProcedure
from gnu.trove.set import TIntSet, TLongSet, TShortSet
from java.util import Map, Collection, Set
from java.util.function import BiFunction, Function, BiConsumer

V = TypeVar('V', default=Any)
K = TypeVar('K', default=Any)

class TIntIntMap:

  def adjustOrPutValue(self, arg0: int, arg1: int, arg2: int) -> int: ...

  def adjustValue(self, arg0: int, arg1: int) -> bool: ...

  def clear(self) -> None: ...

  def containsKey(self, arg0: int) -> bool: ...

  def containsValue(self, arg0: int) -> bool: ...

  def forEachEntry(self, arg0: TIntIntProcedure) -> bool: ...

  def forEachKey(self, arg0: TIntProcedure) -> bool: ...

  def forEachValue(self, arg0: TIntProcedure) -> bool: ...

  def get(self, arg0: int) -> int: ...

  def getNoEntryKey(self) -> int: ...

  def getNoEntryValue(self) -> int: ...

  def increment(self, arg0: int) -> bool: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> TIntIntIterator: ...

  def keySet(self) -> TIntSet: ...

  @overload
  def keys(self) -> list[int]: ...

  @overload
  def keys(self, arg0: list[int]) -> list[int]: ...

  def put(self, arg0: int, arg1: int) -> int: ...

  @overload
  def putAll(self, arg0: TIntIntMap) -> None: ...

  @overload
  def putAll(self, arg0: Map[Integer, Integer]) -> None: ...

  def putIfAbsent(self, arg0: int, arg1: int) -> int: ...

  def remove(self, arg0: int) -> int: ...

  def retainEntries(self, arg0: TIntIntProcedure) -> bool: ...

  def size(self) -> int: ...

  def transformValues(self, arg0: TIntFunction) -> None: ...

  def valueCollection(self) -> TIntCollection: ...

  @overload
  def values(self) -> list[int]: ...

  @overload
  def values(self, arg0: list[int]) -> list[int]: ...


class TIntLongMap:

  def adjustOrPutValue(self, arg0: int, arg1: int, arg2: int) -> int: ...

  def adjustValue(self, arg0: int, arg1: int) -> bool: ...

  def clear(self) -> None: ...

  def containsKey(self, arg0: int) -> bool: ...

  def containsValue(self, arg0: int) -> bool: ...

  def forEachEntry(self, arg0: TIntLongProcedure) -> bool: ...

  def forEachKey(self, arg0: TIntProcedure) -> bool: ...

  def forEachValue(self, arg0: TLongProcedure) -> bool: ...

  def get(self, arg0: int) -> int: ...

  def getNoEntryKey(self) -> int: ...

  def getNoEntryValue(self) -> int: ...

  def increment(self, arg0: int) -> bool: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> TIntLongIterator: ...

  def keySet(self) -> TIntSet: ...

  @overload
  def keys(self) -> list[int]: ...

  @overload
  def keys(self, arg0: list[int]) -> list[int]: ...

  def put(self, arg0: int, arg1: int) -> int: ...

  @overload
  def putAll(self, arg0: TIntLongMap) -> None: ...

  @overload
  def putAll(self, arg0: Map[Integer, Long]) -> None: ...

  def putIfAbsent(self, arg0: int, arg1: int) -> int: ...

  def remove(self, arg0: int) -> int: ...

  def retainEntries(self, arg0: TIntLongProcedure) -> bool: ...

  def size(self) -> int: ...

  def transformValues(self, arg0: TLongFunction) -> None: ...

  def valueCollection(self) -> TLongCollection: ...

  @overload
  def values(self) -> list[int]: ...

  @overload
  def values(self, arg0: list[int]) -> list[int]: ...


class TIntObjectMap[V]:

  def clear(self) -> None: ...

  def containsKey(self, arg0: int) -> bool: ...

  def containsValue(self, arg0: object) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def forEachEntry(self, arg0: TIntObjectProcedure[V]) -> bool: ...

  def forEachKey(self, arg0: TIntProcedure) -> bool: ...

  def forEachValue(self, arg0: TObjectProcedure[V]) -> bool: ...

  def get(self, arg0: int) -> object: ...

  def getNoEntryKey(self) -> int: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> TIntObjectIterator[V]: ...

  def keySet(self) -> TIntSet: ...

  @overload
  def keys(self) -> list[int]: ...

  @overload
  def keys(self, arg0: list[int]) -> list[int]: ...

  def put(self, arg0: int, arg1: object) -> object: ...

  @overload
  def putAll(self, arg0: TIntObjectMap[V]) -> None: ...

  @overload
  def putAll(self, arg0: Map[Integer, V]) -> None: ...

  def putIfAbsent(self, arg0: int, arg1: object) -> object: ...

  def remove(self, arg0: int) -> object: ...

  def retainEntries(self, arg0: TIntObjectProcedure[V]) -> bool: ...

  def size(self) -> int: ...

  def transformValues(self, arg0: TObjectFunction[V, V]) -> None: ...

  def valueCollection(self) -> Collection[V]: ...

  @overload
  def values(self) -> list[object]: ...

  @overload
  def values(self, arg0: list[object]) -> list[object]: ...


class TLongObjectMap[V]:

  def clear(self) -> None: ...

  def containsKey(self, arg0: int) -> bool: ...

  def containsValue(self, arg0: object) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def forEachEntry(self, arg0: TLongObjectProcedure[V]) -> bool: ...

  def forEachKey(self, arg0: TLongProcedure) -> bool: ...

  def forEachValue(self, arg0: TObjectProcedure[V]) -> bool: ...

  def get(self, arg0: int) -> object: ...

  def getNoEntryKey(self) -> int: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> TLongObjectIterator[V]: ...

  def keySet(self) -> TLongSet: ...

  @overload
  def keys(self) -> list[int]: ...

  @overload
  def keys(self, arg0: list[int]) -> list[int]: ...

  def put(self, arg0: int, arg1: object) -> object: ...

  @overload
  def putAll(self, arg0: TLongObjectMap[V]) -> None: ...

  @overload
  def putAll(self, arg0: Map[Long, V]) -> None: ...

  def putIfAbsent(self, arg0: int, arg1: object) -> object: ...

  def remove(self, arg0: int) -> object: ...

  def retainEntries(self, arg0: TLongObjectProcedure[V]) -> bool: ...

  def size(self) -> int: ...

  def transformValues(self, arg0: TObjectFunction[V, V]) -> None: ...

  def valueCollection(self) -> Collection[V]: ...

  @overload
  def values(self) -> list[object]: ...

  @overload
  def values(self, arg0: list[object]) -> list[object]: ...


class TMap[K, V]:

  def clear(self) -> None: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def containsKey(self, arg0: object) -> bool: ...

  def containsValue(self, arg0: object) -> bool: ...

  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  def equals(self, arg0: object) -> bool: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  def forEachEntry(self, arg0: TObjectObjectProcedure[K, V]) -> bool: ...

  def forEachKey(self, arg0: TObjectProcedure[K]) -> bool: ...

  def forEachValue(self, arg0: TObjectProcedure[V]) -> bool: ...

  def get(self, arg0: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  def keySet(self) -> Set[K]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, arg0: Map[K, V]) -> None: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  def retainEntries(self, arg0: TObjectObjectProcedure[K, V]) -> bool: ...

  def size(self) -> int: ...

  def transformValues(self, arg0: TObjectFunction[V, V]) -> None: ...

  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...


class TObjectIntMap[K]:

  def adjustOrPutValue(self, arg0: object, arg1: int, arg2: int) -> int: ...

  def adjustValue(self, arg0: object, arg1: int) -> bool: ...

  def clear(self) -> None: ...

  def containsKey(self, arg0: object) -> bool: ...

  def containsValue(self, arg0: int) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def forEachEntry(self, arg0: TObjectIntProcedure[K]) -> bool: ...

  def forEachKey(self, arg0: TObjectProcedure[K]) -> bool: ...

  def forEachValue(self, arg0: TIntProcedure) -> bool: ...

  def get(self, arg0: object) -> int: ...

  def getNoEntryValue(self) -> int: ...

  def hashCode(self) -> int: ...

  def increment(self, arg0: object) -> bool: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> TObjectIntIterator[K]: ...

  def keySet(self) -> Set[K]: ...

  @overload
  def keys(self) -> list[object]: ...

  @overload
  def keys(self, arg0: list[object]) -> list[object]: ...

  def put(self, arg0: object, arg1: int) -> int: ...

  @overload
  def putAll(self, arg0: TObjectIntMap[K]) -> None: ...

  @overload
  def putAll(self, arg0: Map[K, Integer]) -> None: ...

  def putIfAbsent(self, arg0: object, arg1: int) -> int: ...

  def remove(self, arg0: object) -> int: ...

  def retainEntries(self, arg0: TObjectIntProcedure[K]) -> bool: ...

  def size(self) -> int: ...

  def transformValues(self, arg0: TIntFunction) -> None: ...

  def valueCollection(self) -> TIntCollection: ...

  @overload
  def values(self) -> list[int]: ...

  @overload
  def values(self, arg0: list[int]) -> list[int]: ...


class TShortObjectMap[V]:

  def clear(self) -> None: ...

  def containsKey(self, arg0: int) -> bool: ...

  def containsValue(self, arg0: object) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def forEachEntry(self, arg0: TShortObjectProcedure[V]) -> bool: ...

  def forEachKey(self, arg0: TShortProcedure) -> bool: ...

  def forEachValue(self, arg0: TObjectProcedure[V]) -> bool: ...

  def get(self, arg0: int) -> object: ...

  def getNoEntryKey(self) -> int: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> TShortObjectIterator[V]: ...

  def keySet(self) -> TShortSet: ...

  @overload
  def keys(self) -> list[int]: ...

  @overload
  def keys(self, arg0: list[int]) -> list[int]: ...

  def put(self, arg0: int, arg1: object) -> object: ...

  @overload
  def putAll(self, arg0: TShortObjectMap[V]) -> None: ...

  @overload
  def putAll(self, arg0: Map[Short, V]) -> None: ...

  def putIfAbsent(self, arg0: int, arg1: object) -> object: ...

  def remove(self, arg0: int) -> object: ...

  def retainEntries(self, arg0: TShortObjectProcedure[V]) -> bool: ...

  def size(self) -> int: ...

  def transformValues(self, arg0: TObjectFunction[V, V]) -> None: ...

  def valueCollection(self) -> Collection[V]: ...

  @overload
  def values(self) -> list[object]: ...

  @overload
  def values(self, arg0: list[object]) -> list[object]: ...


class TShortShortMap:

  def adjustOrPutValue(self, arg0: int, arg1: int, arg2: int) -> int: ...

  def adjustValue(self, arg0: int, arg1: int) -> bool: ...

  def clear(self) -> None: ...

  def containsKey(self, arg0: int) -> bool: ...

  def containsValue(self, arg0: int) -> bool: ...

  def forEachEntry(self, arg0: TShortShortProcedure) -> bool: ...

  def forEachKey(self, arg0: TShortProcedure) -> bool: ...

  def forEachValue(self, arg0: TShortProcedure) -> bool: ...

  def get(self, arg0: int) -> int: ...

  def getNoEntryKey(self) -> int: ...

  def getNoEntryValue(self) -> int: ...

  def increment(self, arg0: int) -> bool: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> TShortShortIterator: ...

  def keySet(self) -> TShortSet: ...

  @overload
  def keys(self) -> list[int]: ...

  @overload
  def keys(self, arg0: list[int]) -> list[int]: ...

  def put(self, arg0: int, arg1: int) -> int: ...

  @overload
  def putAll(self, arg0: TShortShortMap) -> None: ...

  @overload
  def putAll(self, arg0: Map[Short, Short]) -> None: ...

  def putIfAbsent(self, arg0: int, arg1: int) -> int: ...

  def remove(self, arg0: int) -> int: ...

  def retainEntries(self, arg0: TShortShortProcedure) -> bool: ...

  def size(self) -> int: ...

  def transformValues(self, arg0: TShortFunction) -> None: ...

  def valueCollection(self) -> TShortCollection: ...

  @overload
  def values(self) -> list[int]: ...

  @overload
  def values(self, arg0: list[int]) -> list[int]: ...

