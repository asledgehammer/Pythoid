from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.io import OptionalDataException
from java.lang import Class, Enum, ClassLoader, IllegalAccessException, Module
from java.lang.invoke import MethodHandle
from java.lang.reflect import Field, Member, Method, Constructor, Executable
from java.util import Set

T = TypeVar('T', default=Any)

class CallerSensitive:

  def annotationType(self) -> Class[Annotation]: ...

  def equals(self, arg0: object) -> bool: ...

  def hashCode(self) -> int: ...

  def toString(self) -> str: ...


class ConstantPool:

  def getClassAt(self, arg0: int) -> Class[Any]: ...

  def getClassAtIfLoaded(self, arg0: int) -> Class[Any]: ...

  def getClassRefIndexAt(self, arg0: int) -> int: ...

  def getDoubleAt(self, arg0: int) -> float: ...

  def getFieldAt(self, arg0: int) -> Field: ...

  def getFieldAtIfLoaded(self, arg0: int) -> Field: ...

  def getFloatAt(self, arg0: int) -> float: ...

  def getIntAt(self, arg0: int) -> int: ...

  def getLongAt(self, arg0: int) -> int: ...

  def getMemberRefInfoAt(self, arg0: int) -> list[str]: ...

  def getMethodAt(self, arg0: int) -> Member: ...

  def getMethodAtIfLoaded(self, arg0: int) -> Member: ...

  def getNameAndTypeRefIndexAt(self, arg0: int) -> int: ...

  def getNameAndTypeRefInfoAt(self, arg0: int) -> list[str]: ...

  def getSize(self) -> int: ...

  def getStringAt(self, arg0: int) -> str: ...

  def getTagAt(self, arg0: int) -> ConstantPool.Tag: ...

  def getUTF8At(self, arg0: int) -> str: ...

  def __init__(self): ...

  class Tag(Enum):

    DOUBLE: ConstantPool.Tag

    FIELDREF: ConstantPool.Tag

    FLOAT: ConstantPool.Tag

    INTEGER: ConstantPool.Tag

    INTERFACEMETHODREF: ConstantPool.Tag

    INVALID: ConstantPool.Tag

    INVOKEDYNAMIC: ConstantPool.Tag

    LONG: ConstantPool.Tag

    METHODHANDLE: ConstantPool.Tag

    METHODREF: ConstantPool.Tag

    METHODTYPE: ConstantPool.Tag

    NAMEANDTYPE: ConstantPool.Tag

    STRING: ConstantPool.Tag

    UTF8: ConstantPool.Tag

    @staticmethod
    def valueOf(arg0: str) -> ConstantPool.Tag: ...

    @staticmethod
    def values() -> list[ConstantPool.Tag]: ...


class ConstructorAccessor:

  def newInstance(self, arg0: list[object]) -> object: ...


class ConstructorAccessorImpl(MagicAccessorImpl):

  @overload
  def newInstance(self, arg0: list[object]) -> object: ...

  @overload
  def newInstance(self, arg0: list[object]) -> object: ...


class DelegatingClassLoader(ClassLoader): ...


class DelegatingConstructorAccessorImpl(ConstructorAccessorImpl):

  def newInstance(self, arg0: list[object]) -> object: ...


class DirectConstructorHandleAccessor(ConstructorAccessorImpl):

  def newInstance(self, arg0: list[object]) -> object: ...

  class NativeAccessor(ConstructorAccessorImpl):

    def newInstance(self, arg0: list[object]) -> object: ...


class DirectMethodHandleAccessor(MethodAccessorImpl):

  @overload
  def invoke(self, arg0: object, arg1: list[object]) -> object: ...

  @overload
  def invoke(self, arg0: object, arg1: list[object], arg2: Class[Any]) -> object: ...

  class NativeAccessor(MethodAccessorImpl):

    @overload
    def invoke(self, arg0: object, arg1: list[object]) -> object: ...

    @overload
    def invoke(self, arg0: object, arg1: list[object], arg2: Class[Any]) -> object: ...

    def invokeViaReflectiveInvoker(self, arg0: object, arg1: list[object]) -> object: ...

    class ReflectiveInvoker: ...


class FieldAccessor:

  def get(self, arg0: object) -> object: ...

  def getBoolean(self, arg0: object) -> bool: ...

  def getByte(self, arg0: object) -> int: ...

  def getChar(self, arg0: object) -> str: ...

  def getDouble(self, arg0: object) -> float: ...

  def getFloat(self, arg0: object) -> float: ...

  def getInt(self, arg0: object) -> int: ...

  def getLong(self, arg0: object) -> int: ...

  def getShort(self, arg0: object) -> int: ...

  def set(self, arg0: object, arg1: object) -> None: ...

  def setBoolean(self, arg0: object, arg1: bool) -> None: ...

  def setByte(self, arg0: object, arg1: int) -> None: ...

  def setChar(self, arg0: object, arg1: str) -> None: ...

  def setDouble(self, arg0: object, arg1: float) -> None: ...

  def setFloat(self, arg0: object, arg1: float) -> None: ...

  def setInt(self, arg0: object, arg1: int) -> None: ...

  def setLong(self, arg0: object, arg1: int) -> None: ...

  def setShort(self, arg0: object, arg1: int) -> None: ...


class FieldAccessorImpl(MagicAccessorImpl):

  @overload
  def get(self, arg0: object) -> object: ...

  @overload
  def get(self, arg0: object) -> object: ...

  @overload
  def getBoolean(self, arg0: object) -> bool: ...

  @overload
  def getBoolean(self, arg0: object) -> bool: ...

  @overload
  def getByte(self, arg0: object) -> int: ...

  @overload
  def getByte(self, arg0: object) -> int: ...

  @overload
  def getChar(self, arg0: object) -> str: ...

  @overload
  def getChar(self, arg0: object) -> str: ...

  @overload
  def getDouble(self, arg0: object) -> float: ...

  @overload
  def getDouble(self, arg0: object) -> float: ...

  @overload
  def getFloat(self, arg0: object) -> float: ...

  @overload
  def getFloat(self, arg0: object) -> float: ...

  @overload
  def getInt(self, arg0: object) -> int: ...

  @overload
  def getInt(self, arg0: object) -> int: ...

  @overload
  def getLong(self, arg0: object) -> int: ...

  @overload
  def getLong(self, arg0: object) -> int: ...

  @overload
  def getShort(self, arg0: object) -> int: ...

  @overload
  def getShort(self, arg0: object) -> int: ...

  @overload
  def set(self, arg0: object, arg1: object) -> None: ...

  @overload
  def set(self, arg0: object, arg1: object) -> None: ...

  @overload
  def setBoolean(self, arg0: object, arg1: bool) -> None: ...

  @overload
  def setBoolean(self, arg0: object, arg1: bool) -> None: ...

  @overload
  def setByte(self, arg0: object, arg1: int) -> None: ...

  @overload
  def setByte(self, arg0: object, arg1: int) -> None: ...

  @overload
  def setChar(self, arg0: object, arg1: str) -> None: ...

  @overload
  def setChar(self, arg0: object, arg1: str) -> None: ...

  @overload
  def setDouble(self, arg0: object, arg1: float) -> None: ...

  @overload
  def setDouble(self, arg0: object, arg1: float) -> None: ...

  @overload
  def setFloat(self, arg0: object, arg1: float) -> None: ...

  @overload
  def setFloat(self, arg0: object, arg1: float) -> None: ...

  @overload
  def setInt(self, arg0: object, arg1: int) -> None: ...

  @overload
  def setInt(self, arg0: object, arg1: int) -> None: ...

  @overload
  def setLong(self, arg0: object, arg1: int) -> None: ...

  @overload
  def setLong(self, arg0: object, arg1: int) -> None: ...

  @overload
  def setShort(self, arg0: object, arg1: int) -> None: ...

  @overload
  def setShort(self, arg0: object, arg1: int) -> None: ...


class MagicAccessorImpl: ...


class MethodAccessor:

  @overload
  def invoke(self, arg0: object, arg1: list[object]) -> object: ...

  @overload
  def invoke(self, arg0: object, arg1: list[object], arg2: Class[Any]) -> object: ...


class MethodAccessorImpl(MagicAccessorImpl):

  @overload
  def invoke(self, arg0: object, arg1: list[object]) -> object: ...

  @overload
  def invoke(self, arg0: object, arg1: list[object]) -> object: ...

  @overload
  def invoke(self, arg0: object, arg1: list[object], arg2: Class[Any]) -> object: ...

  @overload
  def invoke(self, arg0: object, arg1: list[object], arg2: Class[Any]) -> object: ...


class MethodHandleAccessorFactory:

  class LazyStaticHolder: ...


class NativeConstructorAccessorImpl(ConstructorAccessorImpl):

  def newInstance(self, arg0: list[object]) -> object: ...


class Reflection:

  @staticmethod
  def areNestMates(arg0: Class[Any], arg1: Class[Any]) -> bool: ...

  @staticmethod
  def ensureMemberAccess(arg0: Class[Any], arg1: Class[Any], arg2: Class[Any], arg3: int) -> None: ...

  @staticmethod
  def ensureNativeAccess(arg0: Class[Any]) -> None: ...

  @staticmethod
  def filterFields(arg0: Class[Any], arg1: list[Field]) -> list[Field]: ...

  @staticmethod
  def filterMethods(arg0: Class[Any], arg1: list[Method]) -> list[Method]: ...

  @staticmethod
  def getCallerClass() -> Class[Any]: ...

  @staticmethod
  def getClassAccessFlags(arg0: Class[Any]) -> int: ...

  @staticmethod
  def isCallerSensitive(arg0: Method) -> bool: ...

  @staticmethod
  def isTrustedFinalField(arg0: Field) -> bool: ...

  @staticmethod
  def newIllegalAccessException(arg0: Class[Any], arg1: Class[Any], arg2: Class[Any], arg3: int) -> IllegalAccessException: ...

  @staticmethod
  def registerFieldsToFilter(arg0: Class[Any], arg1: Set[str]) -> None: ...

  @staticmethod
  def registerMethodsToFilter(arg0: Class[Any], arg1: Set[str]) -> None: ...

  @staticmethod
  def verifyMemberAccess(arg0: Class[Any], arg1: Class[Any], arg2: Class[Any], arg3: int) -> bool: ...

  @staticmethod
  def verifyModuleAccess(arg0: Module, arg1: Class[Any]) -> bool: ...

  @staticmethod
  def verifyPublicMemberAccess(arg0: Class[Any], arg1: int) -> bool: ...

  def __init__(self): ...


class ReflectionFactory:

  def copyConstructor(self, arg0: Constructor[T]) -> Constructor[T]: ...

  def copyField(self, arg0: Field) -> Field: ...

  def copyMethod(self, arg0: Method) -> Method: ...

  def getConstructorAccessor(self, arg0: Constructor[Any]) -> ConstructorAccessor: ...

  def getExecutableSharedParameterTypes(self, arg0: Executable) -> list[Class]: ...

  def getExecutableTypeAnnotationBytes(self, arg0: Executable) -> list[int]: ...

  def hasStaticInitializerForSerialization(self, arg0: Class[Any]) -> bool: ...

  def leafCopyMethod(self, arg0: Method) -> Method: ...

  def newConstructor(self, arg0: Class[Any], arg1: list[Class], arg2: list[Class], arg3: int, arg4: int, arg5: str, arg6: list[int], arg7: list[int]) -> Constructor[Any]: ...

  def newConstructorAccessor(self, arg0: Constructor[Any]) -> ConstructorAccessor: ...

  def newConstructorForExternalization(self, arg0: Class[Any]) -> Constructor[Any]: ...

  @overload
  def newConstructorForSerialization(self, arg0: Class[Any]) -> Constructor[Any]: ...

  @overload
  def newConstructorForSerialization(self, arg0: Class[Any], arg1: Constructor[Any]) -> Constructor[Any]: ...

  def newFieldAccessor(self, arg0: Field, arg1: bool) -> FieldAccessor: ...

  def newInstance(self, arg0: Constructor[T], arg1: list[object], arg2: Class[Any]) -> object: ...

  def newMethodAccessor(self, arg0: Method, arg1: bool) -> MethodAccessor: ...

  def newOptionalDataExceptionForSerialization(self) -> Constructor[OptionalDataException]: ...

  def readObjectForSerialization(self, arg0: Class[Any]) -> MethodHandle: ...

  def readObjectNoDataForSerialization(self, arg0: Class[Any]) -> MethodHandle: ...

  def readResolveForSerialization(self, arg0: Class[Any]) -> MethodHandle: ...

  def setConstructorAccessor(self, arg0: Constructor[Any], arg1: ConstructorAccessor) -> None: ...

  def writeObjectForSerialization(self, arg0: Class[Any]) -> MethodHandle: ...

  def writeReplaceForSerialization(self, arg0: Class[Any]) -> MethodHandle: ...

  @staticmethod
  def getReflectionFactory() -> ReflectionFactory: ...

  class GetReflectionFactoryAction:

    @overload
    def run(self) -> ReflectionFactory: ...

    @overload
    def run(self) -> object: ...

    @overload
    def run(self) -> object: ...

    def __init__(self): ...


class UnsafeFieldAccessorImpl(FieldAccessorImpl): ...


class UnsafeStaticFieldAccessorImpl(UnsafeFieldAccessorImpl): ...

