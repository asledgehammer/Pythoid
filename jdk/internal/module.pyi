from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.io import InputStream, PrintStream
from java.lang import ModuleLayer, ClassLoader, Module, Class
from java.lang.module import ModuleDescriptor, ModuleFinder, ModuleReference, ModuleReader, Configuration
from java.net import URI
from java.nio import ByteBuffer
from java.nio.file import Path
from java.util import Set, List, Optional, Map, Collection, Comparator, Spliterator
from java.util.function import Function, Supplier, Consumer
from java.util.stream import Stream
from jdk.internal.loader import Resource

V = TypeVar('V', default=Any)
T = TypeVar('T', default=Any)

class ArchivedBootLayer: ...


class ArchivedModuleGraph: ...


class Builder:

  def build(self, arg0: int) -> ModuleDescriptor: ...

  def exports(self, arg0: list[ModuleDescriptor.Exports]) -> Builder: ...

  def mainClass(self, arg0: str) -> Builder: ...

  def opens(self, arg0: list[ModuleDescriptor.Opens]) -> Builder: ...

  def packages(self, arg0: Set[str]) -> Builder: ...

  def provides(self, arg0: list[ModuleDescriptor.Provides]) -> Builder: ...

  def requires(self, arg0: list[ModuleDescriptor.Requires]) -> Builder: ...

  def uses(self, arg0: Set[str]) -> Builder: ...

  def version(self, arg0: str) -> Builder: ...

  @staticmethod
  @overload
  def newExports(arg0: Set[ModuleDescriptor.Exports.Modifier], arg1: str) -> ModuleDescriptor.Exports: ...

  @staticmethod
  @overload
  def newExports(arg0: Set[ModuleDescriptor.Exports.Modifier], arg1: str, arg2: Set[str]) -> ModuleDescriptor.Exports: ...

  @staticmethod
  @overload
  def newOpens(arg0: Set[ModuleDescriptor.Opens.Modifier], arg1: str) -> ModuleDescriptor.Opens: ...

  @staticmethod
  @overload
  def newOpens(arg0: Set[ModuleDescriptor.Opens.Modifier], arg1: str, arg2: Set[str]) -> ModuleDescriptor.Opens: ...

  @staticmethod
  def newProvides(arg0: str, arg1: List[str]) -> ModuleDescriptor.Provides: ...

  @staticmethod
  @overload
  def newRequires(arg0: Set[ModuleDescriptor.Requires.Modifier], arg1: str) -> ModuleDescriptor.Requires: ...

  @staticmethod
  @overload
  def newRequires(arg0: Set[ModuleDescriptor.Requires.Modifier], arg1: str, arg2: str) -> ModuleDescriptor.Requires: ...


class Checks:

  @staticmethod
  def isClassName(arg0: str) -> bool: ...

  @staticmethod
  def isJavaIdentifier(arg0: str) -> bool: ...

  @staticmethod
  def isPackageName(arg0: str) -> bool: ...

  @staticmethod
  def requireModuleName(arg0: str) -> str: ...

  @staticmethod
  def requirePackageName(arg0: str) -> str: ...

  @staticmethod
  def requireQualifiedClassName(arg0: str, arg1: str) -> str: ...

  @staticmethod
  def requireServiceProviderName(arg0: str) -> str: ...

  @staticmethod
  def requireServiceTypeName(arg0: str) -> str: ...


class DefaultRoots:

  @staticmethod
  def compute(arg0: ModuleFinder) -> Set[str]: ...


class ModuleBootstrap:

  @staticmethod
  def boot() -> ModuleLayer: ...

  @staticmethod
  def limitedFinder() -> ModuleFinder: ...

  @staticmethod
  def patcher() -> ModulePatcher: ...

  @staticmethod
  def unlimitedFinder() -> ModuleFinder: ...

  class Counters: ...

  class SafeModuleFinder:

    @overload
    def find(self, arg0: str) -> Optional[ModuleReference]: ...

    @overload
    def find(self, arg0: str) -> Optional[ModuleReference]: ...

    @overload
    def findAll(self) -> Set[ModuleReference]: ...

    @overload
    def findAll(self) -> Set[ModuleReference]: ...

    @staticmethod
    def compose(arg0: list[ModuleFinder]) -> ModuleFinder: ...

    @staticmethod
    def of(arg0: list[Path]) -> ModuleFinder: ...

    @staticmethod
    def ofSystem() -> ModuleFinder: ...


class ModuleHashes:

  def algorithm(self) -> str: ...

  def equals(self, arg0: object) -> bool: ...

  def hashCode(self) -> int: ...

  def hashFor(self, arg0: str) -> list[int]: ...

  def hashes(self) -> Map[str, byte]: ...

  def names(self) -> Set[str]: ...

  def toString(self) -> str: ...

  class Builder:

    def build(self) -> ModuleHashes: ...

    def hashForModule(self, arg0: str, arg1: list[int]) -> ModuleHashes.Builder: ...

  class HashSupplier:

    def generate(self, arg0: str) -> list[int]: ...


class ModuleLoaderMap:

  @staticmethod
  def bootModules() -> Set[str]: ...

  @staticmethod
  def isBuiltinMapper(arg0: Function[str, ClassLoader]) -> bool: ...

  @staticmethod
  def platformModules() -> Set[str]: ...

  def __init__(self): ...

  class Modules: ...

  class Mapper:

    def andThen(self, arg0: Function[R, V]) -> Function[T, V]: ...

    @overload
    def apply(self, arg0: object) -> object: ...

    @overload
    def apply(self, arg0: object) -> object: ...

    @overload
    def apply(self, arg0: str) -> ClassLoader: ...

    def compose(self, arg0: Function[V, T]) -> Function[V, R]: ...

    @staticmethod
    def identity() -> Function[T, T]: ...


class ModulePatcher:

  def hasPatches(self) -> bool: ...

  def patchIfNeeded(self, arg0: ModuleReference) -> ModuleReference: ...

  def __init__(self, arg0: Map[str, List[str]]): ...

  class PatchedModuleReader:

    @overload
    def close(self) -> None: ...

    @overload
    def close(self) -> None: ...

    @overload
    def find(self, arg0: str) -> Optional[URI]: ...

    @overload
    def find(self, arg0: str) -> Optional[URI]: ...

    def findResource(self, arg0: str) -> Resource: ...

    @overload
    def list(self) -> Stream[str]: ...

    @overload
    def list(self) -> Stream[str]: ...

    @overload
    def open(self, arg0: str) -> Optional[InputStream]: ...

    @overload
    def open(self, arg0: str) -> Optional[InputStream]: ...

    @overload
    def read(self, arg0: str) -> Optional[ByteBuffer]: ...

    @overload
    def read(self, arg0: str) -> Optional[ByteBuffer]: ...

    @overload
    def release(self, arg0: ByteBuffer) -> None: ...

    @overload
    def release(self, arg0: ByteBuffer) -> None: ...

  class ExplodedResourceFinder:

    def close(self) -> None: ...

    @overload
    def find(self, arg0: str) -> Resource: ...

    @overload
    def find(self, arg0: str) -> Resource: ...

    @overload
    def list(self) -> Stream[str]: ...

    @overload
    def list(self) -> Stream[str]: ...

  class JarResourceFinder:

    def close(self) -> None: ...

    @overload
    def find(self, arg0: str) -> Resource: ...

    @overload
    def find(self, arg0: str) -> Resource: ...

    @overload
    def list(self) -> Stream[str]: ...

    @overload
    def list(self) -> Stream[str]: ...

  class ResourceFinder:

    def close(self) -> None: ...

    def find(self, arg0: str) -> Resource: ...

    def list(self) -> Stream[str]: ...


class ModuleReferenceImpl(ModuleReference):

  def computeHash(self, arg0: str) -> list[int]: ...

  def equals(self, arg0: object) -> bool: ...

  def hashCode(self) -> int: ...

  def isPatched(self) -> bool: ...

  def moduleResolution(self) -> ModuleResolution: ...

  def moduleTarget(self) -> ModuleTarget: ...

  def open(self) -> ModuleReader: ...

  def recordedHashes(self) -> ModuleHashes: ...

  def toString(self) -> str: ...

  def __init__(self, arg0: ModuleDescriptor, arg1: URI, arg2: Supplier[ModuleReader], arg3: ModulePatcher, arg4: ModuleTarget, arg5: ModuleHashes, arg6: ModuleHashes.HashSupplier, arg7: ModuleResolution): ...


class ModuleResolution:

  def doNotResolveByDefault(self) -> bool: ...

  def hasDeprecatedForRemovalWarning(self) -> bool: ...

  def hasDeprecatedWarning(self) -> bool: ...

  def hasIncubatingWarning(self) -> bool: ...

  def toString(self) -> str: ...

  def value(self) -> int: ...

  def withDeprecated(self) -> ModuleResolution: ...

  def withDeprecatedForRemoval(self) -> ModuleResolution: ...

  def withDoNotResolveByDefault(self) -> ModuleResolution: ...

  def withIncubating(self) -> ModuleResolution: ...

  @staticmethod
  def empty() -> ModuleResolution: ...


class ModuleTarget:

  def targetPlatform(self) -> str: ...

  def __init__(self, arg0: str): ...


class Modules:

  @staticmethod
  @overload
  def addExports(arg0: Module, arg1: str) -> None: ...

  @staticmethod
  @overload
  def addExports(arg0: Module, arg1: str, arg2: Module) -> None: ...

  @staticmethod
  def addExportsToAllUnnamed(arg0: Module, arg1: str) -> None: ...

  @staticmethod
  def addOpens(arg0: Module, arg1: str, arg2: Module) -> None: ...

  @staticmethod
  def addOpensToAllUnnamed(arg0: Module, arg1: str) -> None: ...

  @staticmethod
  def addProvides(arg0: Module, arg1: Class[Any], arg2: Class[Any]) -> None: ...

  @staticmethod
  def addReads(arg0: Module, arg1: Module) -> None: ...

  @staticmethod
  def addReadsAllUnnamed(arg0: Module) -> None: ...

  @staticmethod
  def addUses(arg0: Module, arg1: Class[Any]) -> None: ...

  @staticmethod
  def defineModule(arg0: ClassLoader, arg1: ModuleDescriptor, arg2: URI) -> Module: ...

  @staticmethod
  def findLoadedModule(arg0: str) -> Optional[Module]: ...

  @staticmethod
  def loadModule(arg0: str) -> Module: ...

  @staticmethod
  def newBootLayerConfiguration(arg0: ModuleFinder, arg1: Collection[str], arg2: PrintStream) -> Configuration: ...

  @staticmethod
  def transformedByAgent(arg0: Module) -> None: ...


class ServicesCatalog:

  def addProvider(self, arg0: Module, arg1: Class[Any], arg2: Class[Any]) -> None: ...

  def findServices(self, arg0: str) -> List[ServicesCatalog.ServiceProvider]: ...

  def register(self, arg0: Module) -> None: ...

  @staticmethod
  def create() -> ServicesCatalog: ...

  @staticmethod
  def getServicesCatalog(arg0: ClassLoader) -> ServicesCatalog: ...

  @staticmethod
  def getServicesCatalogOrNull(arg0: ClassLoader) -> ServicesCatalog: ...

  @staticmethod
  def putServicesCatalog(arg0: ClassLoader, arg1: ServicesCatalog) -> None: ...

  class ServiceProvider:

    def equals(self, arg0: object) -> bool: ...

    def hashCode(self) -> int: ...

    def module(self) -> Module: ...

    def providerName(self) -> str: ...

    def __init__(self, arg0: Module, arg1: str): ...


class SystemModuleFinders:

  @staticmethod
  def ofSystem() -> ModuleFinder: ...

  class SystemModuleFinder:

    @overload
    def find(self, arg0: str) -> Optional[ModuleReference]: ...

    @overload
    def find(self, arg0: str) -> Optional[ModuleReference]: ...

    @overload
    def findAll(self) -> Set[ModuleReference]: ...

    @overload
    def findAll(self) -> Set[ModuleReference]: ...

    @staticmethod
    def compose(arg0: list[ModuleFinder]) -> ModuleFinder: ...

    @staticmethod
    def of(arg0: list[Path]) -> ModuleFinder: ...

    @staticmethod
    def ofSystem() -> ModuleFinder: ...

  class SystemImage: ...

  class ModuleContentSpliterator:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[str]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator[str]: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class SystemModuleReader:

    @overload
    def close(self) -> None: ...

    @overload
    def close(self) -> None: ...

    @overload
    def find(self, arg0: str) -> Optional[URI]: ...

    @overload
    def find(self, arg0: str) -> Optional[URI]: ...

    @overload
    def list(self) -> Stream[str]: ...

    @overload
    def list(self) -> Stream[str]: ...

    @overload
    def open(self, arg0: str) -> Optional[InputStream]: ...

    @overload
    def open(self, arg0: str) -> Optional[InputStream]: ...

    @overload
    def read(self, arg0: str) -> Optional[ByteBuffer]: ...

    @overload
    def read(self, arg0: str) -> Optional[ByteBuffer]: ...

    @overload
    def release(self, arg0: ByteBuffer) -> None: ...

    @overload
    def release(self, arg0: ByteBuffer) -> None: ...


class SystemModules:

  def hasIncubatorModules(self) -> bool: ...

  def hasSplitPackages(self) -> bool: ...

  def moduleDescriptors(self) -> list[ModuleDescriptor]: ...

  def moduleHashes(self) -> list[ModuleHashes]: ...

  def moduleReads(self) -> Map[str, Set[str]]: ...

  def moduleResolutions(self) -> list[ModuleResolution]: ...

  def moduleTargets(self) -> list[ModuleTarget]: ...


class all:

  @overload
  def hasIncubatorModules(self) -> bool: ...

  @overload
  def hasIncubatorModules(self) -> bool: ...

  @overload
  def hasSplitPackages(self) -> bool: ...

  @overload
  def hasSplitPackages(self) -> bool: ...

  @overload
  def moduleDescriptors(self) -> list[ModuleDescriptor]: ...

  @overload
  def moduleDescriptors(self) -> list[ModuleDescriptor]: ...

  @overload
  def moduleHashes(self) -> list[ModuleHashes]: ...

  @overload
  def moduleHashes(self) -> list[ModuleHashes]: ...

  @overload
  def moduleReads(self) -> Map: ...

  @overload
  def moduleReads(self) -> Map[str, Set[str]]: ...

  @overload
  def moduleResolutions(self) -> list[ModuleResolution]: ...

  @overload
  def moduleResolutions(self) -> list[ModuleResolution]: ...

  @overload
  def moduleTargets(self) -> list[ModuleTarget]: ...

  @overload
  def moduleTargets(self) -> list[ModuleTarget]: ...

  def __init__(self): ...


class SystemModulesMap: ...

