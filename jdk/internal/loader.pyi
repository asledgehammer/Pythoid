from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.io import InputStream, File, IOException
from java.lang import ClassLoader, IllegalStateException, Class, Package, Module, ModuleLayer, Exception
from java.lang.module import ModuleReference, Configuration, ResolvedModule
from java.net import URL, URI, URLStreamHandlerFactory
from java.nio import ByteBuffer
from java.security import SecureClassLoader, CodeSigner, AccessControlContext
from java.security.cert import Certificate
from java.util import Enumeration, Optional, List, Collection
from java.util.concurrent import ConcurrentHashMap
from java.util.concurrent.locks import ReentrantLock
from java.util.function import BiFunction
from java.util.jar import Manifest
from java.util.stream import Stream
from jdk.internal.module import ServicesCatalog

CLV = TypeVar('CLV', default=Any)
V = TypeVar('V', default=Any)
K = TypeVar('K', default=Any)
Memoizer_CLV = TypeVar('Memoizer_CLV', default=Any)
Memoizer_V = TypeVar('Memoizer_V', default=Any)

class AbstractClassLoaderValue[CLV, V]:

  def computeIfAbsent(self, arg0: ClassLoader, arg1: BiFunction[ClassLoader, CLV, V]) -> object: ...

  def get(self, arg0: ClassLoader) -> object: ...

  def isEqualOrDescendantOf(self, arg0: AbstractClassLoaderValue[Any, V]) -> bool: ...

  def key(self) -> object: ...

  def putIfAbsent(self, arg0: ClassLoader, arg1: object) -> object: ...

  def remove(self, arg0: ClassLoader, arg1: object) -> bool: ...

  def removeAll(self, arg0: ClassLoader) -> None: ...

  def sub(self, arg0: object) -> AbstractClassLoaderValue.Sub: ...

  class Sub[K](AbstractClassLoaderValue):

    def equals(self, arg0: object) -> bool: ...

    def hashCode(self) -> int: ...

    def isEqualOrDescendantOf(self, arg0: AbstractClassLoaderValue[Any, V]) -> bool: ...

    def key(self) -> object: ...

    def parent(self) -> AbstractClassLoaderValue[CLV, V]: ...

  class Memoizer[Memoizer_CLV, Memoizer_V]:

    @overload
    def get(self) -> object: ...

    @overload
    def get(self) -> object: ...

    class RecursiveInvocationException(IllegalStateException): ...


class ArchivedClassLoaders: ...


class BootLoader:

  @staticmethod
  def definePackage(arg0: Class[Any]) -> Package: ...

  @staticmethod
  @overload
  def findResource(arg0: str) -> URL: ...

  @staticmethod
  @overload
  def findResource(arg0: str, arg1: str) -> URL: ...

  @staticmethod
  def findResourceAsStream(arg0: str, arg1: str) -> InputStream: ...

  @staticmethod
  def findResources(arg0: str) -> Enumeration[URL]: ...

  @staticmethod
  def getClassLoaderValueMap() -> ConcurrentHashMap[Any, Any]: ...

  @staticmethod
  def getDefinedPackage(arg0: str) -> Package: ...

  @staticmethod
  def getNativeLibraries() -> NativeLibraries: ...

  @staticmethod
  def getServicesCatalog() -> ServicesCatalog: ...

  @staticmethod
  def getUnnamedModule() -> Module: ...

  @staticmethod
  def hasClassPath() -> bool: ...

  @staticmethod
  def loadClass(arg0: Module, arg1: str) -> Class[Any]: ...

  @staticmethod
  def loadClassOrNull(arg0: str) -> Class[Any]: ...

  @staticmethod
  def loadLibrary(arg0: str) -> None: ...

  @staticmethod
  def loadModule(arg0: ModuleReference) -> None: ...

  @staticmethod
  def packages() -> Stream[Package]: ...

  class PackageHelper: ...


class BuiltinClassLoader(SecureClassLoader):

  @overload
  def findResource(self, arg0: str) -> URL: ...

  @overload
  def findResource(self, arg0: str, arg1: str) -> URL: ...

  def findResourceAsStream(self, arg0: str, arg1: str) -> InputStream: ...

  def findResources(self, arg0: str) -> Enumeration[URL]: ...

  def loadModule(self, arg0: ModuleReference) -> None: ...

  class LoadedModule: ...

  class NullModuleReader:

    @overload
    def close(self) -> None: ...

    @overload
    def close(self) -> None: ...

    @overload
    def find(self, arg0: str) -> Optional[URI]: ...

    @overload
    def find(self, arg0: str) -> Optional[URI]: ...

    @overload
    def list(self) -> Stream[str]: ...

    @overload
    def list(self) -> Stream[str]: ...

    def open(self, arg0: str) -> Optional[InputStream]: ...

    def read(self, arg0: str) -> Optional[ByteBuffer]: ...

    def release(self, arg0: ByteBuffer) -> None: ...


class ClassLoaderHelper: ...


class ClassLoaderValue[V](AbstractClassLoaderValue):

  def isEqualOrDescendantOf(self, arg0: AbstractClassLoaderValue[Any, V]) -> bool: ...

  @overload
  def key(self) -> object: ...

  @overload
  def key(self) -> ClassLoaderValue[V]: ...

  def __init__(self): ...


class ClassLoaders:

  @staticmethod
  def appClassLoader() -> ClassLoader: ...

  @staticmethod
  def platformClassLoader() -> ClassLoader: ...

  class BootClassLoader(BuiltinClassLoader): ...

  class PlatformClassLoader(BuiltinClassLoader): ...

  class AppClassLoader(BuiltinClassLoader): ...


class FileURLMapper:

  def exists(self) -> bool: ...

  def getPath(self) -> str: ...

  def __init__(self, arg0: URL): ...


class Loader(SecureClassLoader):

  def findResource(self, arg0: str) -> URL: ...

  def findResources(self, arg0: str) -> Enumeration[URL]: ...

  def getResource(self, arg0: str) -> URL: ...

  def getResources(self, arg0: str) -> Enumeration[URL]: ...

  def initRemotePackageMap(self, arg0: Configuration, arg1: List[ModuleLayer]) -> Loader: ...

  def pool(self) -> LoaderPool: ...

  @overload
  def __init__(self, arg0: Collection[ResolvedModule], arg1: ClassLoader): ...
  @overload
  def __init__(self, arg0: ResolvedModule, arg1: LoaderPool, arg2: ClassLoader): ...

  class LoadedModule: ...

  class NullModuleReader:

    @overload
    def close(self) -> None: ...

    @overload
    def close(self) -> None: ...

    @overload
    def find(self, arg0: str) -> Optional[URI]: ...

    @overload
    def find(self, arg0: str) -> Optional[URI]: ...

    @overload
    def list(self) -> Stream[str]: ...

    @overload
    def list(self) -> Stream[str]: ...

    def open(self, arg0: str) -> Optional[InputStream]: ...

    def read(self, arg0: str) -> Optional[ByteBuffer]: ...

    def release(self, arg0: ByteBuffer) -> None: ...


class LoaderPool:

  def loaderFor(self, arg0: str) -> Loader: ...

  def loaders(self) -> Stream[Loader]: ...

  def __init__(self, arg0: Configuration, arg1: List[ModuleLayer], arg2: ClassLoader): ...


class NativeLibraries:

  def find(self, arg0: str) -> int: ...

  @overload
  def loadLibrary(self, arg0: str) -> NativeLibrary: ...

  @overload
  def loadLibrary(self, arg0: Class[Any], arg1: File) -> NativeLibrary: ...

  @overload
  def loadLibrary(self, arg0: Class[Any], arg1: str) -> NativeLibrary: ...

  def unload(self, arg0: NativeLibrary) -> None: ...

  @staticmethod
  def jniNativeLibraries(arg0: ClassLoader) -> NativeLibraries: ...

  @staticmethod
  def rawNativeLibraries(arg0: Class[Any], arg1: bool) -> NativeLibraries: ...

  class NativeLibraryContext: ...

  class NativeLibraryImpl:

    @overload
    def find(self, arg0: str) -> int: ...

    @overload
    def find(self, arg0: str) -> int: ...

    def lookup(self, arg0: str) -> int: ...

    @overload
    def name(self) -> str: ...

    @overload
    def name(self) -> str: ...

  class LibraryPaths: ...

  class CountedLock(ReentrantLock):

    def decrement(self) -> None: ...

    def getCounter(self) -> int: ...

    def increment(self) -> None: ...

  class Unloader:

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...


class NativeLibrary:

  def find(self, arg0: str) -> int: ...

  def lookup(self, arg0: str) -> int: ...

  def name(self) -> str: ...


class Resource:

  def getByteBuffer(self) -> ByteBuffer: ...

  def getBytes(self) -> list[int]: ...

  def getCertificates(self) -> list[Certificate]: ...

  def getCodeSigners(self) -> list[CodeSigner]: ...

  def getCodeSourceURL(self) -> URL: ...

  def getContentLength(self) -> int: ...

  def getDataError(self) -> Exception: ...

  def getInputStream(self) -> InputStream: ...

  def getManifest(self) -> Manifest: ...

  def getName(self) -> str: ...

  def getURL(self) -> URL: ...

  def __init__(self): ...


class URLClassPath:

  def addFile(self, arg0: str) -> None: ...

  def addURL(self, arg0: URL) -> None: ...

  def closeLoaders(self) -> List[IOException]: ...

  def findResource(self, arg0: str, arg1: bool) -> URL: ...

  def findResources(self, arg0: str, arg1: bool) -> Enumeration[URL]: ...

  @overload
  def getResource(self, arg0: str) -> Resource: ...

  @overload
  def getResource(self, arg0: str, arg1: bool) -> Resource: ...

  @overload
  def getResources(self, arg0: str) -> Enumeration[Resource]: ...

  @overload
  def getResources(self, arg0: str, arg1: bool) -> Enumeration[Resource]: ...

  def getURLs(self) -> list[URL]: ...

  @staticmethod
  def check(arg0: URL) -> None: ...

  @staticmethod
  def checkURL(arg0: URL) -> URL: ...

  @overload
  def __init__(self, arg0: list[URL], arg1: AccessControlContext): ...
  @overload
  def __init__(self, arg0: list[URL], arg1: URLStreamHandlerFactory, arg2: AccessControlContext): ...

  class Loader:

    @overload
    def close(self) -> None: ...

    @overload
    def close(self) -> None: ...

  class FileLoader(URLClassPath.Loader): ...

  class JarLoader(URLClassPath.Loader):

    def close(self) -> None: ...

