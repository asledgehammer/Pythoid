from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.lang import Long, Integer
from java.util import Comparator, Map, AbstractMap, Enumeration, Set, Collection, Iterator, AbstractSet, Dictionary, AbstractCollection, Spliterator
from java.util.function import BiFunction, Function, BiConsumer, Consumer

TypeK = TypeVar('TypeK', default=Any)
TypeV = TypeVar('TypeV', default=Any)
K = TypeVar('K', default=Any)
V = TypeVar('V', default=Any)
CHM_TypeK = TypeVar('CHM_TypeK', default=Any)
CHM_TypeV = TypeVar('CHM_TypeV', default=Any)
E = TypeVar('E', default=Any)
SimpleImmutableEntry_K = TypeVar('SimpleImmutableEntry_K', default=Any)
SimpleImmutableEntry_V = TypeVar('SimpleImmutableEntry_V', default=Any)
SimpleEntry_K = TypeVar('SimpleEntry_K', default=Any)
SimpleEntry_V = TypeVar('SimpleEntry_V', default=Any)
Entry_K = TypeVar('Entry_K', default=Any)
Entry_V = TypeVar('Entry_V', default=Any)
T = TypeVar('T', default=Any)

class AbstractEntry[TypeK, TypeV]:

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def getKey(self) -> object: ...

  @overload
  def getKey(self) -> object: ...

  @overload
  def getValue(self) -> object: ...

  @overload
  def getValue(self) -> object: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  def setValue(self, arg0: object) -> object: ...

  def toString(self) -> str: ...

  @staticmethod
  @overload
  def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

  @staticmethod
  @overload
  def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

  @staticmethod
  @overload
  def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

  @staticmethod
  @overload
  def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

  @staticmethod
  def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  @overload
  def __init__(self, arg0: Map.Entry): ...
  @overload
  def __init__(self, arg0: object, arg1: object): ...


class ConcurrentAutoTable:

  def add(self, x: int) -> None: ...

  def decrement(self) -> None: ...

  def estimate_get(self) -> int: ...

  def get(self) -> int: ...

  def increment(self) -> None: ...

  def intValue(self) -> int: ...

  def internal_size(self) -> int: ...

  def longValue(self) -> int: ...

  def print(self) -> None: ...

  def set(self, x: int) -> None: ...

  def toString(self) -> str: ...

  def __init__(self): ...

  class CAT:

    def add_if_mask(self, arg0: int, arg1: int, arg2: int, arg3: ConcurrentAutoTable) -> int: ...

    def all_and(self, arg0: int) -> None: ...

    def all_or(self, arg0: int) -> None: ...

    def all_set(self, arg0: int) -> None: ...

    def estimate_sum(self, arg0: int) -> int: ...

    def print(self) -> None: ...

    def sum(self, arg0: int) -> int: ...


class Counter(ConcurrentAutoTable):

  def __init__(self): ...


class IntIterator:

  def hasNext(self) -> bool: ...

  def next(self) -> int: ...


class NonBlockingHashMap[TypeK, TypeV](AbstractMap):

  def clear(self) -> None: ...

  def clone(self) -> object: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def contains(self, val: object) -> bool: ...

  def containsKey(self, key: object) -> bool: ...

  def containsValue(self, val: object) -> bool: ...

  def elements(self) -> Enumeration[TypeV]: ...

  def entrySet(self) -> Set[Map.Entry[TypeK, TypeV]]: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  def get(self, key: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def isEmpty(self) -> bool: ...

  def keySet(self) -> Set[TypeK]: ...

  def keys(self) -> Enumeration[TypeK]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  def print(self) -> None: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, m: Map[TypeK, TypeV]) -> None: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, key: object) -> object: ...

  @overload
  def remove(self, key: object, val: object) -> bool: ...

  @overload
  def remove(self, key: object, val: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  def reprobes(self) -> int: ...

  def size(self) -> int: ...

  def toString(self) -> str: ...

  def values(self) -> Collection[TypeV]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, initial_sz: int): ...

  class CHM[CHM_TypeK, CHM_TypeV]:

    def size(self) -> int: ...

    def slots(self) -> int: ...

  class Prime: ...

  class SnapshotV:

    def asIterator(self) -> Iterator[E]: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingHashMap): ...

  class SnapshotK:

    def asIterator(self) -> Iterator[E]: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingHashMap): ...

  class SnapshotE:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingHashMap): ...

  class NBHMEntry(AbstractEntry):

    def setValue(self, arg0: object) -> object: ...


class NonBlockingHashMapLong[TypeV](AbstractMap):

  def clear(self) -> None: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def contains(self, val: object) -> bool: ...

  @overload
  def containsKey(self, key: object) -> bool: ...

  @overload
  def containsKey(self, key: int) -> bool: ...

  def containsValue(self, val: object) -> bool: ...

  def elements(self) -> Enumeration[TypeV]: ...

  def entrySet(self) -> Set[Map.Entry[Long, TypeV]]: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def get(self, key: object) -> object: ...

  @overload
  def get(self, key: int) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def keySet(self) -> Set[Long]: ...

  def keys(self) -> Enumeration[Long]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  def print(self) -> None: ...

  @overload
  def put(self, arg0: Long, arg1: object) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def put(self, arg0: int, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: Long, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: int, arg1: object) -> object: ...

  @overload
  def remove(self, key: object) -> object: ...

  @overload
  def remove(self, key: int) -> object: ...

  @overload
  def remove(self, key: object, Val: object) -> bool: ...

  @overload
  def remove(self, key: object, Val: object) -> bool: ...

  @overload
  def remove(self, key: int, val: object) -> bool: ...

  @overload
  def replace(self, arg0: Long, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: int, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: Long, arg1: object, arg2: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replace(self, arg0: int, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  def reprobes(self) -> int: ...

  def size(self) -> int: ...

  def values(self) -> Collection[TypeV]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, opt_for_space: bool): ...
  @overload
  def __init__(self, initial_sz: int): ...
  @overload
  def __init__(self, initial_sz: int, opt_for_space: bool): ...

  class CHM[CHM_TypeV]:

    def size(self) -> int: ...

    def slots(self) -> int: ...

  class Prime: ...

  class SnapshotV:

    def asIterator(self) -> Iterator[E]: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingHashMapLong): ...

  class IteratorLong:

    def asIterator(self) -> Iterator[E]: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> Long: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> Long: ...

    @overload
    def nextElement(self) -> object: ...

    def nextLong(self) -> int: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingHashMapLong): ...

  class SnapshotE:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingHashMapLong): ...

  class NBHMLEntry(AbstractEntry):

    def setValue(self, arg0: object) -> object: ...


class NonBlockingHashSet[E](AbstractSet):

  def add(self, arg0: object) -> bool: ...

  def clear(self) -> None: ...

  def contains(self, o: object) -> bool: ...

  def iterator(self) -> Iterator[E]: ...

  def readOnly(self) -> None: ...

  def remove(self, o: object) -> bool: ...

  def size(self) -> int: ...

  def __init__(self): ...


class NonBlockingHashtable[TypeK, TypeV](Dictionary):

  def clear(self) -> None: ...

  def clone(self) -> object: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def contains(self, val: object) -> bool: ...

  def containsKey(self, key: object) -> bool: ...

  def containsValue(self, val: object) -> bool: ...

  def elements(self) -> Enumeration[TypeV]: ...

  def entrySet(self) -> Set[Map.Entry[TypeK, TypeV]]: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  def get(self, key: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def isEmpty(self) -> bool: ...

  def keySet(self) -> Set[TypeK]: ...

  def keys(self) -> Enumeration[TypeK]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  def print(self) -> None: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, m: Map[TypeK, TypeV]) -> None: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, key: object) -> object: ...

  @overload
  def remove(self, key: object, val: object) -> bool: ...

  @overload
  def remove(self, key: object, val: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  def reprobes(self) -> int: ...

  def size(self) -> int: ...

  def toString(self) -> str: ...

  def values(self) -> Collection[TypeV]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, initial_sz: int): ...

  class CHM[CHM_TypeK, CHM_TypeV]:

    def size(self) -> int: ...

    def slots(self) -> int: ...

  class Prime: ...

  class SnapshotV:

    def asIterator(self) -> Iterator[E]: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingHashtable): ...

  class SnapshotK:

    def asIterator(self) -> Iterator[E]: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingHashtable): ...

  class SnapshotE:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingHashtable): ...

  class NBHMEntry(AbstractEntry):

    def setValue(self, arg0: object) -> object: ...


class NonBlockingIdentityHashMap[TypeK, TypeV](AbstractMap):

  def clear(self) -> None: ...

  def clone(self) -> object: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def contains(self, val: object) -> bool: ...

  def containsKey(self, key: object) -> bool: ...

  def containsValue(self, val: object) -> bool: ...

  def elements(self) -> Enumeration[TypeV]: ...

  def entrySet(self) -> Set[Map.Entry[TypeK, TypeV]]: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  def get(self, key: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def isEmpty(self) -> bool: ...

  def keySet(self) -> Set[TypeK]: ...

  def keys(self) -> Enumeration[TypeK]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  def print(self) -> None: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, m: Map[TypeK, TypeV]) -> None: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, key: object) -> object: ...

  @overload
  def remove(self, key: object, val: object) -> bool: ...

  @overload
  def remove(self, key: object, val: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  def reprobes(self) -> int: ...

  def size(self) -> int: ...

  def toString(self) -> str: ...

  def values(self) -> Collection[TypeV]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, initial_sz: int): ...

  class CHM[CHM_TypeK, CHM_TypeV]:

    def size(self) -> int: ...

    def slots(self) -> int: ...

  class Prime: ...

  class SnapshotV:

    def asIterator(self) -> Iterator[E]: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingIdentityHashMap): ...

  class SnapshotK:

    def asIterator(self) -> Iterator[E]: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingIdentityHashMap): ...

  class SnapshotE:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    def __init__(self, arg0: NonBlockingIdentityHashMap): ...

  class NBHMEntry(AbstractEntry):

    def setValue(self, arg0: object) -> object: ...


class NonBlockingSetInt(AbstractSet):

  @overload
  def add(self, i: int) -> bool: ...

  @overload
  def add(self, i: Integer) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  def clear(self) -> None: ...

  @overload
  def contains(self, i: int) -> bool: ...

  @overload
  def contains(self, o: object) -> bool: ...

  def intIterator(self) -> IntIterator: ...

  def intersect(self, op: NonBlockingSetInt) -> NonBlockingSetInt: ...

  def iterator(self) -> Iterator[Integer]: ...

  def print(self) -> None: ...

  @overload
  def remove(self, i: int) -> bool: ...

  @overload
  def remove(self, o: object) -> bool: ...

  def size(self) -> int: ...

  def sizeInBytes(self) -> int: ...

  def union(self, op: NonBlockingSetInt) -> NonBlockingSetInt: ...

  def __init__(self): ...

  class NBSI:

    def add(self, arg0: int) -> bool: ...

    def contains(self, arg0: int) -> bool: ...

    def intersect(self, arg0: NonBlockingSetInt.NBSI, arg1: NonBlockingSetInt.NBSI, arg2: NonBlockingSetInt.NBSI) -> bool: ...

    def remove(self, arg0: int) -> bool: ...

    def size(self) -> int: ...

    def sizeInBytes(self) -> int: ...

    def union(self, arg0: NonBlockingSetInt.NBSI, arg1: NonBlockingSetInt.NBSI, arg2: NonBlockingSetInt.NBSI) -> bool: ...

  class iter:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> Integer: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

  class NBSIIntIterator:

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> int: ...

    @overload
    def next(self) -> int: ...

    def remove(self) -> None: ...


class ZomboidAbstractMap[K, V]:

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def containsKey(self, key: object) -> bool: ...

  @overload
  def containsKey(self, key: object) -> bool: ...

  @overload
  def containsValue(self, value: object) -> bool: ...

  @overload
  def containsValue(self, value: object) -> bool: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def equals(self, o: object) -> bool: ...

  @overload
  def equals(self, o: object) -> bool: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def get(self, key: object) -> object: ...

  @overload
  def get(self, key: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def keySet(self) -> Set[K]: ...

  @overload
  def keySet(self) -> Set[K]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putAll(self, m: Map[K, V]) -> None: ...

  @overload
  def putAll(self, m: Map[K, V]) -> None: ...

  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, key: object) -> object: ...

  @overload
  def remove(self, key: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  def toString(self) -> str: ...

  @overload
  def values(self) -> Collection[V]: ...

  @overload
  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

  class SimpleImmutableEntry[SimpleImmutableEntry_K, SimpleImmutableEntry_V]:

    @overload
    def equals(self, o: object) -> bool: ...

    @overload
    def equals(self, o: object) -> bool: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    def toString(self) -> str: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...

    @overload
    def __init__(self, entry: Map.Entry): ...
    @overload
    def __init__(self, arg0: object, arg1: object): ...

  class SimpleEntry[SimpleEntry_K, SimpleEntry_V]:

    @overload
    def equals(self, o: object) -> bool: ...

    @overload
    def equals(self, o: object) -> bool: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    def toString(self) -> str: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...

    @overload
    def __init__(self, entry: Map.Entry): ...
    @overload
    def __init__(self, arg0: object, arg1: object): ...


class ZomboidHashMap[K, V](ZomboidAbstractMap):

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def clone(self) -> object: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def containsKey(self, key: object) -> bool: ...

  @overload
  def containsKey(self, key: object) -> bool: ...

  @overload
  def containsValue(self, value: object) -> bool: ...

  @overload
  def containsValue(self, value: object) -> bool: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  def equals(self, arg0: object) -> bool: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def get(self, key: object) -> object: ...

  @overload
  def get(self, key: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def hashCode(self) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def keySet(self) -> Set[K]: ...

  @overload
  def keySet(self) -> Set[K]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putAll(self, m: Map[K, V]) -> None: ...

  @overload
  def putAll(self, m: Map[K, V]) -> None: ...

  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, key: object) -> object: ...

  @overload
  def remove(self, key: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  @overload
  def values(self) -> Collection[V]: ...

  @overload
  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, initialCapacity: int): ...
  @overload
  def __init__(self, m: Map[K, V]): ...
  @overload
  def __init__(self, initialCapacity: int, loadFactor: float): ...

  class Entry[Entry_K, Entry_V]:

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    def toString(self) -> str: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  class KeyIterator(ZomboidHashMap.HashIterator):

    def next(self) -> object: ...

  class ValueIterator(ZomboidHashMap.HashIterator):

    def next(self) -> object: ...

  class EntryIterator(ZomboidHashMap.HashIterator):

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

  class KeySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[K]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

  class Values(AbstractCollection):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[V]: ...

    def size(self) -> int: ...

  class EntrySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

  class HashIterator[E]:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...


class ZomboidHashSet[E](AbstractSet):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def clone(self) -> object: ...

  @overload
  def contains(self, o: object) -> bool: ...

  @overload
  def contains(self, o: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def hashCode(self) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def remove(self, o: object) -> bool: ...

  @overload
  def remove(self, o: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> Set[E]: ...

  @staticmethod
  @overload
  def of() -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, initialCapacity: int): ...
  @overload
  def __init__(self, c: Collection[E]): ...
  @overload
  def __init__(self, initialCapacity: int, loadFactor: float): ...

