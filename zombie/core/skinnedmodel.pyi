from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.net import URI
from java.nio import FloatBuffer
from java.util import ArrayList, List, Collection, HashMap
from org.lwjgl.util.vector import Matrix4f, Vector4f, Quaternion, Vector3f
from zombie import PredicatedFileWatcher
from zombie.characters import IsoZombie, IsoGameCharacter
from zombie.core import ImmutableColor, Color
from zombie.core.skinnedmodel.animation import AnimationClip, AnimationPlayer, SoftwareSkinnedModelAnim
from zombie.core.skinnedmodel.model import VertexPositionNormalTangentTextureSkin, ModelInstance, AnimationAsset, Model, ModelMesh
from zombie.core.skinnedmodel.visual import HumanVisual, ItemVisuals
from zombie.core.textures import Texture, TextureDraw, ColorInfo, TextureFBO
from zombie.iso import IsoDirections, IsoGridSquare, IsoObject, IsoMovingObject, IsoLightSource
from zombie.iso.objects import IsoDeadBody, IsoMannequin
from zombie.popman import ObjectPool
from zombie.vehicles import BaseVehicle

class CharacterTextures:

  def __init__(self): ...

  class CTAnimSet: ...

  class CTState: ...

  class CTEntry: ...

  class CTEntryList(ArrayList): ...


class DeadBodyAtlas:

  ATLAS_SIZE: int

  instance: DeadBodyAtlas

  def Reset(self) -> None: ...

  @overload
  def checkLights(self, entryTex: Texture, body: IsoZombie) -> None: ...

  @overload
  def checkLights(self, entryTex: Texture, body: IsoDeadBody) -> None: ...

  @overload
  def getBodyTexture(self, body: IsoZombie) -> DeadBodyAtlas.BodyTexture: ...

  @overload
  def getBodyTexture(self, body: DeadBodyAtlas.BodyParams) -> DeadBodyAtlas.BodyTexture: ...

  @overload
  def getBodyTexture(self, body: IsoDeadBody) -> DeadBodyAtlas.BodyTexture: ...

  @overload
  def getBodyTexture(self, body: IsoMannequin) -> DeadBodyAtlas.BodyTexture: ...

  @overload
  def getBodyTexture(self, bFemale: bool, animSet: str, stateName: str, dir: IsoDirections, frame: int, trackTime: float) -> DeadBodyAtlas.BodyTexture: ...

  def lightingUpdate(self, updateCounter: int, lightsChanged: bool) -> None: ...

  def render(self) -> None: ...

  def renderDebug(self) -> None: ...

  def renderUI(self) -> None: ...

  def __init__(self): ...

  class BodyParams: ...

  class Checksummer:

    def checksumToString(self) -> str: ...

    def reset(self) -> None: ...

    @overload
    def update(self, arg0: bool) -> None: ...

    @overload
    def update(self, arg0: int) -> None: ...

    @overload
    def update(self, arg0: int) -> None: ...

    @overload
    def update(self, arg0: str) -> None: ...

    @overload
    def update(self, arg0: ImmutableColor) -> None: ...

    @overload
    def update(self, arg0: IsoGridSquare.ResultLight, arg1: float, arg2: float, arg3: float) -> None: ...

  class DebugDrawInWorld(TextureDraw.GenericDrawer):

    def init(self, arg0: DeadBodyAtlas.RenderJob) -> None: ...

    def postRender(self) -> None: ...

    def render(self) -> None: ...

  class CharacterTextureVisual:

    @overload
    def getHumanVisual(self) -> HumanVisual: ...

    @overload
    def getHumanVisual(self) -> HumanVisual: ...

    @overload
    def getItemVisuals(self, arg0: ItemVisuals) -> None: ...

    @overload
    def getItemVisuals(self, arg0: ItemVisuals) -> None: ...

    @overload
    def isFemale(self) -> bool: ...

    @overload
    def isFemale(self) -> bool: ...

    @overload
    def isSkeleton(self) -> bool: ...

    @overload
    def isSkeleton(self) -> bool: ...

    @overload
    def isZombie(self) -> bool: ...

    @overload
    def isZombie(self) -> bool: ...

  class BodyTexture:

    def render(self, x: float, y: float, r: float, g: float, b: float, a: float) -> None: ...

    def renderObjectPicker(self, sx: float, sy: float, lightInfo: ColorInfo, square: IsoGridSquare, object: IsoObject) -> None: ...

    def __init__(self): ...

  class AtlasEntry:

    def Reset(self) -> None: ...

  class RenderJob(TextureDraw.GenericDrawer):

    def Reset(self) -> None: ...

    def init(self, arg0: DeadBodyAtlas.BodyParams, arg1: DeadBodyAtlas.AtlasEntry) -> DeadBodyAtlas.RenderJob: ...

    def postRender(self) -> None: ...

    def render(self) -> None: ...

    def renderMain(self) -> bool: ...

    @staticmethod
    def getNew() -> DeadBodyAtlas.RenderJob: ...

    class L_getCameraRay: ...

    class L_uiToScene: ...

  class Atlas:

    def Reset(self) -> None: ...

    def addBody(self, arg0: str) -> DeadBodyAtlas.AtlasEntry: ...

    def addEntry(self, arg0: DeadBodyAtlas.AtlasEntry) -> None: ...

    def isFull(self) -> bool: ...

    def __init__(self, arg0: DeadBodyAtlas, arg1: int, arg2: int, arg3: int, arg4: int):
      self.clear: bool
      self.entry_hgt: int
      self.entry_wid: int
      self.entrylist: ArrayList[DeadBodyAtlas.AtlasEntry]
      self.tex: Texture

  class ClearAtlasTexture(TextureDraw.GenericDrawer):

    def render(self) -> None: ...

  class BodyTextureDrawer(TextureDraw.GenericDrawer):

    def postRender(self) -> None: ...

    def render(self) -> None: ...


class HelperFunctions:

  @staticmethod
  def ApplyBlendBone(weight: float, transform: Matrix4f, vertPos: Vector3, vertNorm: Vector3, tmpVect: Vector4f, newPos: Vector3, newNorm: Vector3) -> None: ...

  @staticmethod
  @overload
  def CreateFromQuaternion(q: Quaternion) -> Matrix4f: ...

  @staticmethod
  @overload
  def CreateFromQuaternion(q: Quaternion, result: Matrix4f) -> Matrix4f: ...

  @staticmethod
  @overload
  def CreateFromQuaternionPositionScale(position: Vector3f, rotation: Quaternion, scale: Vector3f, result: Matrix4f) -> Matrix4f: ...

  @staticmethod
  @overload
  def CreateFromQuaternionPositionScale(position: Vector3f, rotation: Quaternion, scale: Vector3f, transformResult: HelperFunctions.TransformResult_QPS) -> None: ...

  @staticmethod
  def ToEulerAngles(rot: Quaternion, out_angles: Vector3f) -> Vector3f: ...

  @staticmethod
  def ToQuaternion(roll: float, pitch: float, yaw: float, out_result: Quaternion) -> Quaternion: ...

  @staticmethod
  def ToRgba(color: Color) -> int: ...

  @staticmethod
  def TransformVertices(vertices: list[VertexPositionNormalTangentTextureSkin], boneTransforms: List[Matrix4f]) -> None: ...

  @staticmethod
  def getIdentityQ() -> Quaternion: ...

  @staticmethod
  @overload
  def getMatrix() -> Matrix4f: ...

  @staticmethod
  @overload
  def getMatrix(copyFrom: Matrix4f) -> Matrix4f: ...

  @staticmethod
  def getPosition(matrix: Matrix4f, out_pos: Vector3f) -> Vector3f: ...

  @staticmethod
  def getRotation(matrix: Matrix4f, out_rot: Quaternion) -> Quaternion: ...

  @staticmethod
  def getRotationY(rotation: Quaternion) -> float: ...

  @staticmethod
  def getRotationZ(rotation: Quaternion) -> float: ...

  @staticmethod
  def getVector3f() -> Vector3f: ...

  @staticmethod
  def getZero3() -> Vector3f: ...

  @staticmethod
  def returnMatrix(mat: Matrix4f) -> None: ...

  @staticmethod
  def returnVector3f(v: Vector3f) -> None: ...

  @staticmethod
  def setPosition(matrix: Matrix4f, pos: Vector3f) -> None: ...

  @staticmethod
  def transform(rotation: Quaternion, in_vector: Vector3f, out_result: Vector3f) -> None: ...

  def __init__(self): ...

  class TransformResult_QPS:

    @overload
    def __init__(self):
      self.result: Matrix4f

    @overload
    def __init__(self, result: Matrix4f): ...

  class UnitTests:

    class transformQuaternion:

      @staticmethod
      def run() -> None: ...

      @staticmethod
      def runTest(arg0: float, arg1: float, arg2: float, arg3: Quaternion, arg4: Vector3f, arg5: Vector3f, arg6: Matrix4f, arg7: Vector4f, arg8: Vector4f, arg9: Vector3f, arg10: Vector3f, arg11: Vector3f) -> None: ...

    class getRotationMatrix:

      @staticmethod
      def run() -> None: ...

    class getRotationY:

      @staticmethod
      def run() -> None: ...

    class getRotationZ:

      @staticmethod
      def run() -> None: ...


class IAnimatable:

  def Play(self, animName: str) -> None: ...

  def Update(self, time: float) -> None: ...


class IDrawable:

  def Draw(self) -> None: ...


class Matrix4:

  Identity: Matrix4

  def clear(self) -> Matrix4: ...

  def clearToIdentity(self) -> Matrix4: ...

  def clearToOrtho(self, left: float, right: float, bottom: float, top: float, near: float, far: float) -> Matrix4: ...

  def clearToPerspective(self, fovRad: float, width: float, height: float, near: float, far: float) -> Matrix4: ...

  def get(self, index: int) -> float: ...

  def getBuffer(self) -> FloatBuffer: ...

  @overload
  def mult(self, m: list[float]) -> Matrix4: ...

  @overload
  def mult(self, m: Matrix4) -> Matrix4: ...

  @overload
  def put(self, m: list[float]) -> Matrix4: ...

  @overload
  def put(self, m: Matrix4) -> Matrix4: ...

  @overload
  def put(self, index: int, f: float) -> Matrix4: ...

  @overload
  def put(self, index: int, v: Vector3, w: float) -> Matrix4: ...

  @overload
  def rotate(self, angle: float, vec: Vector3) -> Matrix4: ...

  @overload
  def rotate(self, angle: float, x: float, y: float, z: float) -> Matrix4: ...

  @overload
  def scale(self, vec: Vector3) -> Matrix4: ...

  @overload
  def scale(self, x: float, y: float, z: float) -> Matrix4: ...

  @overload
  def translate(self, vec: Vector3) -> Matrix4: ...

  @overload
  def translate(self, x: float, y: float, z: float) -> Matrix4: ...

  def transpose(self) -> Matrix4: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, m: list[float]): ...
  @overload
  def __init__(self, m: Matrix4): ...


class ModelCamera:

  instance: ModelCamera

  def Begin(self) -> None: ...

  def End(self) -> None: ...

  def __init__(self):
    self.bdepthmask: bool
    self.m_binvehicle: bool
    self.m_buseworldiso: bool
    self.m_useangle: float
    self.m_x: float
    self.m_y: float
    self.m_z: float


class ModelCameraRenderData(TextureDraw.GenericDrawer):

  s_pool: ObjectPool[ModelCameraRenderData]

  @overload
  def init(self, camera: ModelCamera, modelSlot: ModelManager.ModelSlot) -> ModelCameraRenderData: ...

  @overload
  def init(self, camera: ModelCamera, useangle: float, useWorldIso: bool, tx: float, ty: float, tz: float, bInVehicle: bool) -> ModelCameraRenderData: ...

  def postRender(self) -> None: ...

  def render(self) -> None: ...

  def __init__(self): ...


class ModelManager:

  instance: ModelManager

  NoOpenGL: bool

  def Add(self, chr: IsoGameCharacter) -> None: ...

  def ContainsChar(self, chr: IsoGameCharacter) -> bool: ...

  @overload
  def Remove(self, chr: IsoGameCharacter) -> None: ...

  @overload
  def Remove(self, vehicle: BaseVehicle) -> None: ...

  def RenderParticles(self, texd: TextureDraw, userId: int, va11: int) -> None: ...

  def RenderPuddles(self, shaderID: int, userId: int, z: int) -> None: ...

  def RenderSkyBox(self, texd: TextureDraw, shaderID: int, userId: int, apiId: int, bufferId: int) -> None: ...

  def RenderWater(self, texd: TextureDraw, shaderID: int, userId: int, bShore: bool) -> None: ...

  @overload
  def Reset(self) -> None: ...

  @overload
  def Reset(self, chr: IsoGameCharacter) -> None: ...

  def ResetCharacterEquippedHands(self, chr: IsoGameCharacter) -> None: ...

  def ResetEquippedNextFrame(self, isoGameCharacter: IsoGameCharacter) -> None: ...

  def ResetNextFrame(self, isoGameCharacter: IsoGameCharacter) -> None: ...

  def addAnimationClip(self, name: str, clip: AnimationClip) -> None: ...

  @overload
  def addStatic(self, parentInst: ModelInstance, modelName: str, attachNameSelf: str, attachNameParent: str) -> ModelInstance: ...

  @overload
  def addStatic(self, slot: ModelManager.ModelSlot, meshName: str, texName: str, boneName: str, shaderName: str) -> ModelInstance: ...

  def addStaticForcedTex(self, parentInst: ModelInstance, modelName: str, attachNameSelf: str, attachNameParent: str, forcedTex: str) -> ModelInstance: ...

  def addVehicle(self, vehicle: BaseVehicle) -> None: ...

  def animationAssetLoaded(self, animationAsset: AnimationAsset) -> None: ...

  def create(self) -> None: ...

  def derefModelInstance(self, modelInstance: ModelInstance) -> None: ...

  def derefModelInstances(self, modelInstances: ArrayList[ModelInstance]) -> None: ...

  def dressInRandomOutfit(self, chr: IsoGameCharacter) -> None: ...

  def getAllAnimationClips(self) -> Collection[AnimationClip]: ...

  def getAnimationClip(self, name: str) -> AnimationClip: ...

  def getBodyModel(self, chr: IsoGameCharacter) -> Model: ...

  def getClosestThreeLights(self, chr: IsoMovingObject, ret: list[IsoLightSource]) -> None: ...

  @overload
  def getLoadedModel(self, meshName: str) -> Model: ...

  @overload
  def getLoadedModel(self, meshName: str, tex: str, isStatic: bool, shaderName: str) -> Model: ...

  def getSlot(self, chr: IsoGameCharacter) -> ModelManager.ModelSlot: ...

  def getTextureFlags(self) -> int: ...

  def initAnimationMeshes(self, bReloading: bool) -> None: ...

  def isCreated(self) -> bool: ...

  def isLoadingAnimations(self) -> bool: ...

  def loadAdditionalModel(self, meshName: str, tex: str, bStatic: bool, shaderName: str) -> None: ...

  def loadModAnimations(self) -> None: ...

  def loadStaticModel(self, meshName: str, tex: str, shaderName: str) -> Model: ...

  def newAdditionalModelInstance(self, meshName: str, tex: str, chr: IsoGameCharacter, animPlayer: AnimationPlayer, shaderName: str) -> ModelInstance: ...

  def newInstance(self, model: Model, chr: IsoGameCharacter, player: AnimationPlayer) -> ModelInstance: ...

  def newStaticInstance(self, slot: ModelManager.ModelSlot, meshName: str, texName: str, boneName: str, shaderName: str) -> ModelInstance: ...

  def putLoadedModel(self, name: str, tex: str, isStatic: bool, shaderName: str, model: Model) -> None: ...

  def reloadAllOutfits(self) -> None: ...

  def reloadModelsMatching(self, meshName: str) -> None: ...

  def resetModelInstance(self, modelInstance: ModelInstance, expectedOwner: object) -> None: ...

  def resetModelInstanceRecurse(self, modelInstance: ModelInstance, expectedOwner: object) -> None: ...

  def resetModelInstancesRecurse(self, modelInstances: ArrayList[ModelInstance], expectedOwner: object) -> None: ...

  @overload
  def setModelMetaData(self, meshName: str, texName: str, shaderName: str, bStatic: bool) -> None: ...

  @overload
  def setModelMetaData(self, modelId: str, meshName: str, texName: str, shaderName: str, bStatic: bool) -> None: ...

  def tryGetLoadedModel(self, meshName: str, tex: str, isStatic: bool, shaderName: str, logError: bool) -> Model: ...

  def update(self) -> None: ...

  def __init__(self):
    self.bcreatesoftwaremeshes: bool
    self.bdebugenablemodels: bool
    self.bitmap: TextureFBO
    self.m_femalemodel: Model
    self.m_malemodel: Model
    self.m_skeletonfemalemodel: Model
    self.m_skeletonmalemodel: Model
    self.softwaremeshanims: HashMap[str, SoftwareSkinnedModelAnim]

  class ModAnimations:

    def isActive(self) -> bool: ...

    def setPriority(self, priority: int) -> None: ...

    def __init__(self, modID: str):
      self.m_animationassetlist: ArrayList[AnimationAsset]
      self.m_animationassetmap: HashMap[str, AnimationAsset]
      self.m_modid: str
      self.m_priority: int

  class AnimDirReloader:

    def GetFileWatcher(self) -> PredicatedFileWatcher: ...

    @overload
    def call(self, arg0: str) -> None: ...

    @overload
    def call(self, arg0: str) -> None: ...

    def __init__(self, arg0: ModelManager, arg1: URI, arg2: URI, arg3: str, arg4: ModelMesh, arg5: ModelManager.ModAnimations): ...

  class ModelSlot:

    def Update(self) -> None: ...

    def isRendering(self) -> bool: ...

    def reset(self) -> None: ...

    def __init__(self, ID: int, model: ModelInstance, character: IsoGameCharacter):
      self.active: bool
      self.bremove: bool
      self.character: IsoGameCharacter
      self.framessincestart: int
      self.id: int
      self.model: ModelInstance
      self.renderrefcount: int
      self.sub: ArrayList[ModelInstance]

  class ModelMetaData: ...


class Vector3:

  @overload
  def add(self, vec: Vector3) -> Vector3: ...

  @overload
  def add(self, x: float, y: float, z: float) -> Vector3: ...

  def cross(self, vec: Vector3) -> Vector3: ...

  def dot(self, vec: Vector3) -> float: ...

  def length(self) -> float: ...

  @overload
  def mul(self, f: float) -> Vector3: ...

  @overload
  def mul(self, vec: Vector3) -> Vector3: ...

  @overload
  def mul(self, x: float, y: float, z: float) -> Vector3: ...

  def normalize(self) -> Vector3: ...

  def reset(self) -> Vector3: ...

  @overload
  def set(self, vec: Vector3) -> Vector3: ...

  @overload
  def set(self, x: float, y: float, z: float) -> Vector3: ...

  @overload
  def sub(self, vec: Vector3) -> Vector3: ...

  @overload
  def sub(self, x: float, y: float, z: float) -> Vector3: ...

  @overload
  def x(self) -> float: ...

  @overload
  def x(self, x: float) -> Vector3: ...

  @overload
  def y(self) -> float: ...

  @overload
  def y(self, y: float) -> Vector3: ...

  @overload
  def z(self) -> float: ...

  @overload
  def z(self, z: float) -> Vector3: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, vec: Vector3): ...
  @overload
  def __init__(self, x: float, y: float, z: float): ...


class Vector4:

  @overload
  def set(self, vec: Vector4) -> Vector4: ...

  @overload
  def set(self, x: float, y: float, z: float, w: float) -> Vector4: ...

  @overload
  def __init__(self):
    self.w: float

    self.x: float

    self.y: float

    self.z: float

  @overload
  def __init__(self, vec: Vector4): ...
  @overload
  def __init__(self, x: float, y: float, z: float, w: float): ...

