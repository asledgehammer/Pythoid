from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.lang import Class, Iterable, Float
from java.util import AbstractList, Collection, Iterator, ListIterator, Comparator, Spliterator, List, ArrayList, HashMap, Stack
from java.util.function import UnaryOperator, Function, Supplier, Predicate, Consumer
from zombie.util import AbstractIntCollection, IntCollection, IntIterator, ICloner

E = TypeVar('E', default=Any)
T = TypeVar('T', default=Any)
L = TypeVar('L', default=Any)
S = TypeVar('S', default=Any)
K = TypeVar('K', default=Any)
V = TypeVar('V', default=Any)
T1 = TypeVar('T1', default=Any)
R = TypeVar('R', default=Any)

class AbstractIntList(AbstractIntCollection):

  @overload
  def add(self, v: int) -> bool: ...

  @overload
  def add(self, index: int, v: int) -> None: ...

  @overload
  def add(self, index: int, v: int) -> None: ...

  @overload
  def addAll(self, index: int, c: IntCollection) -> bool: ...

  @overload
  def addAll(self, index: int, c: IntCollection) -> bool: ...

  def equals(self, obj: object) -> bool: ...

  def get(self, arg0: int) -> int: ...

  def hashCode(self) -> int: ...

  @overload
  def indexOf(self, c: int) -> int: ...

  @overload
  def indexOf(self, c: int) -> int: ...

  @overload
  def indexOf(self, index: int, c: int) -> int: ...

  @overload
  def indexOf(self, index: int, c: int) -> int: ...

  def iterator(self) -> IntIterator: ...

  @overload
  def lastIndexOf(self, c: int) -> int: ...

  @overload
  def lastIndexOf(self, c: int) -> int: ...

  @overload
  def lastIndexOf(self, index: int, c: int) -> int: ...

  @overload
  def lastIndexOf(self, index: int, c: int) -> int: ...

  @overload
  def listIterator(self) -> IntListIterator: ...

  @overload
  def listIterator(self) -> IntListIterator: ...

  @overload
  def listIterator(self, index: int) -> IntListIterator: ...

  @overload
  def listIterator(self, index: int) -> IntListIterator: ...

  @overload
  def removeElementAt(self, index: int) -> int: ...

  @overload
  def removeElementAt(self, index: int) -> int: ...

  def set(self, arg0: int, arg1: int) -> int: ...


class FloatConsumer:

  def accept(self, t: float) -> None: ...

  def andThen(self, after: FloatConsumer) -> FloatConsumer: ...


class IntArrayList(AbstractIntList):

  DEFAULT_CAPACITY: int

  DEFAULT_GROWTH_CHUNK: int

  DEFAULT_GROWTH_FACTOR: float

  def add(self, index: int, v: int) -> None: ...

  def capacity(self) -> int: ...

  def clear(self) -> None: ...

  def clone(self) -> object: ...

  def contains(self, v: int) -> bool: ...

  def ensureCapacity(self, capacity: int) -> int: ...

  def equals(self, obj: object) -> bool: ...

  def get(self, index: int) -> int: ...

  def hashCode(self) -> int: ...

  @overload
  def indexOf(self, c: int) -> int: ...

  @overload
  def indexOf(self, index: int, c: int) -> int: ...

  def isEmpty(self) -> bool: ...

  def lastIndexOf(self, c: int) -> int: ...

  def remove(self, v: int) -> bool: ...

  def removeElementAt(self, index: int) -> int: ...

  def set(self, index: int, v: int) -> int: ...

  def size(self) -> int: ...

  @overload
  def toArray(self) -> list[int]: ...

  @overload
  def toArray(self, a: list[int]) -> list[int]: ...

  def trimToSize(self) -> None: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, a: list[int]): ...
  @overload
  def __init__(self, capacity: int): ...
  @overload
  def __init__(self, c: IntCollection): ...
  @overload
  def __init__(self, capacity: int, growthFactor: float): ...
  @overload
  def __init__(self, capacity: int, growthChunk: int): ...


class IntList:

  @overload
  def add(self, arg0: int) -> bool: ...

  @overload
  def add(self, index: int, v: int) -> None: ...

  @overload
  def addAll(self, arg0: IntCollection) -> bool: ...

  @overload
  def addAll(self, index: int, c: IntCollection) -> bool: ...

  def clear(self) -> None: ...

  def contains(self, arg0: int) -> bool: ...

  def containsAll(self, arg0: IntCollection) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def get(self, index: int) -> int: ...

  def hashCode(self) -> int: ...

  @overload
  def indexOf(self, c: int) -> int: ...

  @overload
  def indexOf(self, index: int, c: int) -> int: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> IntIterator: ...

  @overload
  def lastIndexOf(self, c: int) -> int: ...

  @overload
  def lastIndexOf(self, index: int, c: int) -> int: ...

  @overload
  def listIterator(self) -> IntListIterator: ...

  @overload
  def listIterator(self, index: int) -> IntListIterator: ...

  def remove(self, arg0: int) -> bool: ...

  def removeAll(self, arg0: IntCollection) -> bool: ...

  def removeElementAt(self, index: int) -> int: ...

  def retainAll(self, arg0: IntCollection) -> bool: ...

  def set(self, index: int, v: int) -> int: ...

  def size(self) -> int: ...

  @overload
  def toArray(self) -> list[int]: ...

  @overload
  def toArray(self, arg0: list[int]) -> list[int]: ...

  def trimToSize(self) -> None: ...


class IntListIterator:

  def add(self, v: int) -> None: ...

  def hasNext(self) -> bool: ...

  def hasPrevious(self) -> bool: ...

  def next(self) -> int: ...

  def nextIndex(self) -> int: ...

  def previous(self) -> int: ...

  def previousIndex(self) -> int: ...

  def remove(self) -> None: ...

  def set(self, v: int) -> None: ...


class PZArrayList[E](AbstractList):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def contains(self, o: object) -> bool: ...

  @overload
  def contains(self, o: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  @overload
  def get(self, index: int) -> object: ...

  @overload
  def get(self, index: int) -> object: ...

  def getElements(self) -> list[object]: ...

  def hashCode(self) -> int: ...

  @overload
  def indexOf(self, o: object) -> int: ...

  @overload
  def indexOf(self, o: object) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self, index: int) -> ListIterator[E]: ...

  @overload
  def listIterator(self, index: int) -> ListIterator[E]: ...

  @overload
  def remove(self, index: int) -> object: ...

  @overload
  def remove(self, index: int) -> object: ...

  @overload
  def remove(self, o: object) -> bool: ...

  @overload
  def remove(self, o: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  def sort(self, arg0: Comparator[E]) -> None: ...

  def spliterator(self) -> Spliterator[E]: ...

  def subList(self, arg0: int, arg1: int) -> List[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  def toString(self) -> str: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> List[E]: ...

  @staticmethod
  def emptyList() -> AbstractList[E]: ...

  @staticmethod
  @overload
  def of() -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...

  def __init__(self, elementType: Class[E], initialCapacity: int): ...


class PZArrayUtil:

  emptyFloatArray: list[float]

  emptyIntArray: list[int]

  @staticmethod
  @overload
  def add(array: list[float], val: float) -> list[float]: ...

  @staticmethod
  @overload
  def add(arg0: list[object], arg1: object) -> list[object]: ...

  @staticmethod
  def arrayAdd(in_out_a: list[int], b: list[int]) -> list[int]: ...

  @staticmethod
  def arrayConvert(arg0: L, arg1: List[S], arg2: Function[S, E]) -> L: ...

  @staticmethod
  @overload
  def arrayCopy(arg0: list[object], arg1: list[object]) -> list[object]: ...

  @staticmethod
  @overload
  def arrayCopy(arg0: list[object], arg1: List[E]) -> list[object]: ...

  @staticmethod
  @overload
  def arrayCopy(arg0: L, arg1: List[E]) -> L: ...

  @staticmethod
  @overload
  def arrayCopy(to: list[float], arg1: list[float], startIdx: int, endIdx: int) -> list[float]: ...

  @staticmethod
  @overload
  def arrayCopy(to: list[int], arg1: list[int], startIdx: int, endIdx: int) -> list[int]: ...

  @staticmethod
  @overload
  def arrayCopy(arg0: list[object], arg1: list[object], arg2: int, arg3: int) -> list[object]: ...

  @staticmethod
  def arrayPopulate(arg0: list[object], arg1: Supplier[E]) -> list[object]: ...

  @staticmethod
  @overload
  def arraySet(arr: list[float], val: float) -> list[float]: ...

  @staticmethod
  @overload
  def arraySet(arr: list[int], val: int) -> list[int]: ...

  @staticmethod
  @overload
  def arraySet(arg0: list[object], arg1: object) -> list[object]: ...

  @staticmethod
  @overload
  def arrayToString(list: list[float]) -> str: ...

  @staticmethod
  @overload
  def arrayToString(arg0: list[object]) -> str: ...

  @staticmethod
  @overload
  def arrayToString(list: Iterable[E]) -> str: ...

  @staticmethod
  @overload
  def arrayToString(list: Iterable[E], __toString__: Function[E, str]) -> str: ...

  @staticmethod
  @overload
  def arrayToString(list: list[float], prefix: str, suffix: str, delimiter: str) -> str: ...

  @staticmethod
  @overload
  def arrayToString(arg0: list[object], arg1: str, arg2: str, arg3: str) -> str: ...

  @staticmethod
  @overload
  def arrayToString(list: Iterable[E], prefix: str, suffix: str, delimiter: str) -> str: ...

  @staticmethod
  @overload
  def arrayToString(list: Iterable[E], __toString__: Function[E, str], prefix: str, suffix: str, delimiter: str) -> str: ...

  @staticmethod
  @overload
  def clone(src: list[float]) -> list[float]: ...

  @staticmethod
  @overload
  def clone(arg0: list[object]) -> list[object]: ...

  @staticmethod
  def concat(arg0: list[object], arg1: list[object]) -> list[object]: ...

  @staticmethod
  @overload
  def contains(arg0: list[object], arg1: Predicate[E]) -> bool: ...

  @staticmethod
  @overload
  def contains(it: Iterable[E], comparer: Predicate[E]) -> bool: ...

  @staticmethod
  @overload
  def contains(it: Collection[E], comparer: Predicate[E]) -> bool: ...

  @staticmethod
  @overload
  def contains(collection: List[E], comparer: Predicate[E]) -> bool: ...

  @staticmethod
  @overload
  def contains(arr: list[float], count: int, val: float) -> bool: ...

  @staticmethod
  @overload
  def contains(arr: list[int], count: int, val: int) -> bool: ...

  @staticmethod
  @overload
  def copy(target: ArrayList[E], source: ArrayList[E]) -> None: ...

  @staticmethod
  @overload
  def copy(target: ArrayList[E], source: ArrayList[E], elementCloner: ICloner[E]) -> None: ...

  @staticmethod
  @overload
  def find(collection: Iterable[E], comparer: Predicate[E]) -> object: ...

  @staticmethod
  @overload
  def find(collection: List[E], comparer: Predicate[E]) -> object: ...

  @staticmethod
  @overload
  def forEach(arg0: list[object], arg1: Consumer[E]) -> None: ...

  @staticmethod
  @overload
  def forEach(it: Iterable[E], consumer: Consumer[E]) -> None: ...

  @staticmethod
  @overload
  def forEach(list: List[E], consumer: Consumer[E]) -> None: ...

  @staticmethod
  def getElementAt(collection: Iterable[E], index: int) -> object: ...

  @staticmethod
  def getOrCreate(arg0: HashMap[K, V], arg1: object, arg2: Supplier[V]) -> object: ...

  @staticmethod
  @overload
  def getOrDefault(list: List[E], i: int) -> object: ...

  @staticmethod
  @overload
  def getOrDefault(list: list[float], i: int, defaultVal: float) -> float: ...

  @staticmethod
  @overload
  def getOrDefault(arg0: list[object], arg1: int, arg2: object) -> object: ...

  @staticmethod
  @overload
  def getOrDefault(arg0: List[E], arg1: int, arg2: object) -> object: ...

  @staticmethod
  def getSize(collection: Iterable[E]) -> int: ...

  @staticmethod
  @overload
  def indexOf(arg0: list[object], arg1: Predicate[E]) -> int: ...

  @staticmethod
  @overload
  def indexOf(collection: List[E], comparer: Predicate[E]) -> int: ...

  @staticmethod
  @overload
  def indexOf(arr: list[float], count: int, val: float) -> int: ...

  @staticmethod
  @overload
  def indexOf(arr: list[int], count: int, val: int) -> int: ...

  @staticmethod
  @overload
  def indexOf(arg0: list[object], arg1: int, arg2: object) -> int: ...

  @staticmethod
  @overload
  def insertAt(arr: list[float], insertAt: int, val: float) -> None: ...

  @staticmethod
  @overload
  def insertAt(arr: list[int], insertAt: int, val: int) -> None: ...

  @staticmethod
  @overload
  def isNullOrEmpty(array: list[float]) -> bool: ...

  @staticmethod
  @overload
  def isNullOrEmpty(array: list[int]) -> bool: ...

  @staticmethod
  @overload
  def isNullOrEmpty(arg0: list[object]) -> bool: ...

  @staticmethod
  @overload
  def isNullOrEmpty(it: Iterable[E]) -> bool: ...

  @staticmethod
  @overload
  def isNullOrEmpty(list: List[E]) -> bool: ...

  @staticmethod
  def itConvert(source: Iterable[S], converter: Function[S, E]) -> Iterable[E]: ...

  @staticmethod
  @overload
  def listConvert(source: List[S], converter: Function[S, E]) -> List[E]: ...

  @staticmethod
  @overload
  def listConvert(source: List[S], dest: List[E], converter: Function[S, E]) -> List[E]: ...

  @staticmethod
  @overload
  def listConvert(arg0: List[S], arg1: List[E], arg2: object, arg3: PZArrayUtil.IListConverter1Param) -> List[E]: ...

  @staticmethod
  @overload
  def newInstance(componentType: Class[Any], length: int) -> list[object]: ...

  @staticmethod
  @overload
  def newInstance(arg0: Class[Any], arg1: list[object], arg2: int) -> list[object]: ...

  @staticmethod
  @overload
  def newInstance(componentType: Class[Any], length: int, allocator: Supplier[E]) -> list[object]: ...

  @staticmethod
  @overload
  def newInstance(arg0: Class[Any], arg1: list[object], arg2: int, arg3: bool) -> list[object]: ...

  @staticmethod
  @overload
  def newInstance(arg0: Class[Any], arg1: list[object], arg2: int, arg3: Supplier[E]) -> list[object]: ...

  @staticmethod
  @overload
  def newInstance(arg0: Class[Any], arg1: list[object], arg2: int, arg3: bool, arg4: Supplier[E]) -> list[object]: ...

  @staticmethod
  @overload
  def pickRandom(arg0: list[object]) -> object: ...

  @staticmethod
  @overload
  def pickRandom(collection: Iterable[E]) -> object: ...

  @staticmethod
  @overload
  def pickRandom(collection: Collection[E]) -> object: ...

  @staticmethod
  @overload
  def pickRandom(collection: List[E]) -> object: ...

  @staticmethod
  @overload
  def sequenceEqual(arg0: list[object], arg1: List[E]) -> bool: ...

  @staticmethod
  @overload
  def sequenceEqual(a: List[E], b: List[E]) -> bool: ...

  @staticmethod
  @overload
  def sequenceEqual(arg0: list[object], arg1: List[E], arg2: Comparator[E]) -> bool: ...

  @staticmethod
  @overload
  def sequenceEqual(a: List[E], b: List[E], comparator: Comparator[E]) -> bool: ...

  @staticmethod
  def sort(stack: Stack[E], comparator: Comparator[E]) -> None: ...

  @staticmethod
  def toArray(list: List[E]) -> list[object]: ...

  def __init__(self): ...

  class IListConverter1Param[S, E, T1]:

    def convert(self, arg0: object, arg1: object) -> object: ...

  class Comparators:

    @staticmethod
    def equalsIgnoreCase(a: str, b: str) -> int: ...

    @staticmethod
    def objectsEqual(arg0: object, arg1: object) -> int: ...

    @staticmethod
    def referencesEqual(arg0: object, arg1: object) -> int: ...

    def __init__(self): ...


class PZConvertArray[S, T](AbstractList):

  def contains(self, o: object) -> bool: ...

  def forEach(self, action: Consumer[T]) -> None: ...

  def get(self, index: int) -> object: ...

  def indexOf(self, val: object) -> int: ...

  def isReadonly(self) -> bool: ...

  def replaceAll(self, operator: UnaryOperator[T]) -> None: ...

  def set(self, arg0: int, arg1: object) -> object: ...

  def setS(self, arg0: int, arg1: object) -> object: ...

  def size(self) -> int: ...

  def sort(self, c: Comparator[T]) -> None: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def __init__(self, arg0: list[object], arg1: Function[S, T]): ...
  @overload
  def __init__(self, arg0: list[object], arg1: Function[S, T], arg2: Function[T, S]): ...


class PZConvertIterable[T, S]:

  def forEach(self, arg0: Consumer[T]) -> None: ...

  @overload
  def iterator(self) -> Iterator[T]: ...

  @overload
  def iterator(self) -> Iterator[T]: ...

  def spliterator(self) -> Spliterator[T]: ...

  def __init__(self, srcIterable: Iterable[S], converter: Function[S, T]): ...


class PZConvertList[S, T](AbstractList):

  def contains(self, o: object) -> bool: ...

  def forEach(self, action: Consumer[T]) -> None: ...

  def get(self, index: int) -> object: ...

  def indexOf(self, val: object) -> int: ...

  def isReadonly(self) -> bool: ...

  def replaceAll(self, operator: UnaryOperator[T]) -> None: ...

  def set(self, arg0: int, arg1: object) -> object: ...

  def setS(self, arg0: int, arg1: object) -> object: ...

  def size(self) -> int: ...

  def sort(self, c: Comparator[T]) -> None: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def __init__(self, list: List[S], converterST: Function[S, T]): ...
  @overload
  def __init__(self, list: List[S], converterST: Function[S, T], converterTS: Function[T, S]): ...


class PZEmptyIterable[T]:

  def forEach(self, arg0: Consumer[T]) -> None: ...

  @overload
  def iterator(self) -> Iterator[T]: ...

  @overload
  def iterator(self) -> Iterator[T]: ...

  def spliterator(self) -> Spliterator[T]: ...

  @staticmethod
  def getInstance() -> PZEmptyIterable[E]: ...


class PZPrimitiveArrayIterable:

  @staticmethod
  def fromArray(list: list[float]) -> Iterable[Float]: ...

  def __init__(self): ...


class PrimitiveFloatList(AbstractList):

  @overload
  def contains(self, val: float) -> bool: ...

  @overload
  def contains(self, o: object) -> bool: ...

  @overload
  def forEach(self, action: Consumer[Float]) -> None: ...

  @overload
  def forEach(self, action: FloatConsumer) -> None: ...

  @overload
  def get(self, index: int) -> object: ...

  @overload
  def get(self, index: int) -> Float: ...

  @overload
  def indexOf(self, val: float) -> int: ...

  @overload
  def indexOf(self, o: object) -> int: ...

  def replaceAll(self, operator: UnaryOperator[Float]) -> None: ...

  @overload
  def set(self, index: int, element: float) -> float: ...

  @overload
  def set(self, index: int, element: Float) -> Float: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  def size(self) -> int: ...

  @overload
  def sort(self) -> None: ...

  @overload
  def sort(self, unused: Comparator[Float]) -> None: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  def __init__(self, array: list[float]): ...

