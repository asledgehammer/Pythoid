from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from gnu.trove.map.hash import THashMap
from java.lang import Enum
from java.nio import ByteBuffer
from java.util import ArrayList, HashMap, LinkedHashMap, Comparator, List
from java.util.function import Predicate, Function, ToDoubleFunction, ToIntFunction, ToLongFunction
from se.krka.kahlua.vm import KahluaTable, LuaClosure
from zombie.audio import BaseSoundEmitter
from zombie.characterTextures import BloodBodyPartType, BloodClothingType
from zombie.characters import IsoGameCharacter, SurvivorDesc, IsoPlayer
from zombie.core import Color
from zombie.core.raknet import UdpConnection
from zombie.core.skinnedmodel.model import WorldItemAtlas
from zombie.core.skinnedmodel.population import ClothingItem
from zombie.core.skinnedmodel.visual import ItemVisual
from zombie.core.textures import ColorInfo, Texture
from zombie.inventory.types import Food, InventoryContainer
from zombie.iso import IsoDirections, IsoObject, IsoGridSquare
from zombie.iso.objects import IsoWorldInventoryObject
from zombie.popman import ObjectPool
from zombie.radio.media import MediaData
from zombie.scripting.objects import Fixing, ItemReplacement, Item, Recipe, EvolvedRecipe
from zombie.ui import ObjectTooltip
from zombie.vehicles import VehiclePart

T = TypeVar('T', default=Any)
U = TypeVar('U', default=Any)

class ClothingItemsDotTxt:

  instance: ClothingItemsDotTxt

  def LoadFile(self) -> None: ...

  def __init__(self): ...

  class Block:

    @overload
    def asBlock(self) -> ClothingItemsDotTxt.Block: ...

    @overload
    def asBlock(self) -> ClothingItemsDotTxt.Block: ...

    @overload
    def asValue(self) -> ClothingItemsDotTxt.Value: ...

    @overload
    def asValue(self) -> ClothingItemsDotTxt.Value: ...

    def toString(self) -> str: ...

    @overload
    def toXML(self) -> str: ...

    @overload
    def toXML(self) -> str: ...

  class Value:

    @overload
    def asBlock(self) -> ClothingItemsDotTxt.Block: ...

    @overload
    def asBlock(self) -> ClothingItemsDotTxt.Block: ...

    @overload
    def asValue(self) -> ClothingItemsDotTxt.Value: ...

    @overload
    def asValue(self) -> ClothingItemsDotTxt.Value: ...

    def toString(self) -> str: ...

    @overload
    def toXML(self) -> str: ...

    @overload
    def toXML(self) -> str: ...

  class BlockElement:

    def asBlock(self) -> ClothingItemsDotTxt.Block: ...

    def asValue(self) -> ClothingItemsDotTxt.Value: ...

    def toXML(self) -> str: ...


class CompressIdenticalItems:

  @staticmethod
  def load(input: ByteBuffer, WorldVersion: int, Items: ArrayList[InventoryItem], IncludingObsoleteItems: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @staticmethod
  @overload
  def save(output: ByteBuffer, item: InventoryItem) -> None: ...

  @staticmethod
  @overload
  def save(output: ByteBuffer, items: ArrayList[InventoryItem], noCompress: IsoGameCharacter) -> ArrayList[InventoryItem]: ...

  def __init__(self): ...

  class PerThreadData: ...

  class PerCallData: ...


class FixingManager:

  @staticmethod
  def fixItem(brokenItem: InventoryItem, chr: IsoGameCharacter, fixing: Fixing, fixer: Fixing.Fixer) -> InventoryItem: ...

  @staticmethod
  def getChanceOfFail(brokenItem: InventoryItem, chr: IsoGameCharacter, fixing: Fixing, fixer: Fixing.Fixer) -> float: ...

  @staticmethod
  def getCondRepaired(brokenItem: InventoryItem, chr: IsoGameCharacter, fixing: Fixing, fixer: Fixing.Fixer) -> float: ...

  @staticmethod
  def getFixes(item: InventoryItem) -> ArrayList[Fixing]: ...

  @staticmethod
  def useFixer(chr: IsoGameCharacter, fixer: Fixing.Fixer, brokenItem: InventoryItem) -> None: ...

  def __init__(self): ...


class InventoryItem:

  def CanStack(self, item: InventoryItem) -> bool: ...

  def CopyModData(self, DefaultModData: KahluaTable) -> None: ...

  @overload
  def DoTooltip(self, tooltipUI: ObjectTooltip) -> None: ...

  @overload
  def DoTooltip(self, tooltipUI: ObjectTooltip, layout: ObjectTooltip.Layout) -> None: ...

  def HowRotten(self) -> float: ...

  def IsClothing(self) -> bool: ...

  def IsDrainable(self) -> bool: ...

  def IsFood(self) -> bool: ...

  def IsInventoryContainer(self) -> bool: ...

  def IsLiterature(self) -> bool: ...

  def IsMap(self) -> bool: ...

  def IsRotten(self) -> bool: ...

  def IsWeapon(self) -> bool: ...

  def ModDataMatches(self, item: InventoryItem) -> bool: ...

  def SetContainerPosition(self, x: int, y: int) -> None: ...

  @overload
  def Use(self) -> None: ...

  @overload
  def Use(self, bCrafting: bool) -> None: ...

  @overload
  def Use(self, bCrafting: bool, bInContainer: bool) -> None: ...

  def UseItem(self) -> None: ...

  def addExtraItem(self, type: str) -> None: ...

  def allowRandomTint(self) -> bool: ...

  def canBeActivated(self) -> bool: ...

  def canBeRemote(self) -> bool: ...

  def canEmitLight(self) -> bool: ...

  def canStoreWater(self) -> bool: ...

  def copyConditionModData(self, other: InventoryItem) -> None: ...

  def copyModData(self, modData: KahluaTable) -> None: ...

  def doBuildingStash(self) -> None: ...

  def finishupdate(self) -> bool: ...

  def getA(self) -> float: ...

  def getActualWeight(self) -> float: ...

  def getAge(self) -> float: ...

  def getAlcoholPower(self) -> float: ...

  def getAlternateModelName(self) -> str: ...

  def getAmmoType(self) -> str: ...

  def getAttachedSlot(self) -> int: ...

  def getAttachedSlotType(self) -> str: ...

  def getAttachedToModel(self) -> str: ...

  def getAttachmentReplacement(self) -> str: ...

  def getAttachmentType(self) -> str: ...

  def getAttachmentsProvided(self) -> ArrayList[str]: ...

  def getB(self) -> float: ...

  def getBandagePower(self) -> float: ...

  def getBlood(self, bodyPartType: BloodBodyPartType) -> float: ...

  def getBloodClothingType(self) -> ArrayList[BloodClothingType]: ...

  def getBodyLocation(self) -> str: ...

  def getBoredomChange(self) -> float: ...

  def getBrakeForce(self) -> float: ...

  def getBreakSound(self) -> str: ...

  def getBringToBearSound(self) -> str: ...

  def getBurntString(self) -> str: ...

  def getByteData(self) -> ByteBuffer: ...

  def getCat(self) -> ItemType: ...

  def getCategory(self) -> str: ...

  def getChanceToSpawnDamaged(self) -> int: ...

  def getCleanString(self, weight: float) -> str: ...

  def getClothingItem(self) -> ClothingItem: ...

  def getClothingItemExtra(self) -> ArrayList[str]: ...

  def getClothingItemExtraOption(self) -> ArrayList[str]: ...

  def getClothingItemName(self) -> str: ...

  def getColor(self) -> Color: ...

  def getColorBlue(self) -> float: ...

  def getColorGreen(self) -> float: ...

  def getColorInfo(self) -> ColorInfo: ...

  def getColorRed(self) -> float: ...

  def getCondition(self) -> int: ...

  def getConditionLowerNormal(self) -> float: ...

  def getConditionLowerOffroad(self) -> float: ...

  def getConditionMax(self) -> int: ...

  def getConsolidateOption(self) -> str: ...

  def getContainer(self) -> ItemContainer: ...

  def getContainerX(self) -> int: ...

  def getContainerY(self) -> int: ...

  def getContentsWeight(self) -> float: ...

  def getCookedString(self) -> str: ...

  def getCookingTime(self) -> float: ...

  def getCount(self) -> int: ...

  def getCountDownSound(self) -> str: ...

  def getCurrentAmmoCount(self) -> int: ...

  def getCurrentCondition(self) -> float: ...

  def getCurrentUses(self) -> int: ...

  def getCustomMenuOption(self) -> str: ...

  def getDescription(self) -> str: ...

  def getDirt(self, bodyPartType: BloodBodyPartType) -> float: ...

  def getDisplayCategory(self) -> str: ...

  def getDisplayName(self) -> str: ...

  def getEatType(self) -> str: ...

  def getEngineLoudness(self) -> float: ...

  def getEquipParent(self) -> IsoGameCharacter: ...

  def getEquipSound(self) -> str: ...

  def getEquippedWeight(self) -> float: ...

  def getEvolvedRecipeName(self) -> str: ...

  def getExplosionSound(self) -> str: ...

  def getExtraItems(self) -> ArrayList[str]: ...

  def getExtraItemsWeight(self) -> float: ...

  def getFabricType(self) -> str: ...

  def getFatigueChange(self) -> float: ...

  def getFillFromDispenserSound(self) -> str: ...

  def getFillFromTapSound(self) -> str: ...

  def getFullType(self) -> str: ...

  def getG(self) -> float: ...

  def getGunType(self) -> str: ...

  def getHaveBeenRepaired(self) -> int: ...

  def getHotbarEquippedWeight(self) -> float: ...

  def getID(self) -> int: ...

  def getIconsForTexture(self) -> ArrayList[str]: ...

  def getInvHeat(self) -> float: ...

  def getItemCapacity(self) -> float: ...

  def getItemHeat(self) -> float: ...

  def getItemReplacementPrimaryHand(self) -> ItemReplacement: ...

  def getItemReplacementSecondHand(self) -> ItemReplacement: ...

  def getItemWhenDry(self) -> str: ...

  def getJobDelta(self) -> float: ...

  def getJobType(self) -> str: ...

  def getKeyId(self) -> int: ...

  def getLastAged(self) -> float: ...

  def getLightDistance(self) -> int: ...

  def getLightStrength(self) -> float: ...

  def getLuaCreate(self) -> str: ...

  def getMakeUpType(self) -> str: ...

  def getMaxAmmo(self) -> int: ...

  def getMaxCapacity(self) -> int: ...

  def getMechanicType(self) -> int: ...

  def getMediaData(self) -> MediaData: ...

  def getMediaType(self) -> int: ...

  def getMeltingTime(self) -> float: ...

  def getMetalValue(self) -> float: ...

  def getMinutesToBurn(self) -> float: ...

  def getMinutesToCook(self) -> float: ...

  def getModData(self) -> KahluaTable: ...

  def getModID(self) -> str: ...

  def getModName(self) -> str: ...

  def getModule(self) -> str: ...

  def getName(self) -> str: ...

  def getNewPlaceDir(self) -> IsoDirections: ...

  def getOffAge(self) -> int: ...

  def getOffAgeMax(self) -> int: ...

  def getOffString(self) -> str: ...

  def getOutermostContainer(self) -> ItemContainer: ...

  def getPlaceDir(self) -> IsoDirections: ...

  def getPlaceMultipleSound(self) -> str: ...

  def getPlaceOneSound(self) -> str: ...

  def getPreviousOwner(self) -> IsoGameCharacter: ...

  def getR(self) -> float: ...

  def getRecordedMediaIndex(self) -> int: ...

  def getReduceInfectionPower(self) -> float: ...

  def getRegistry_id(self) -> int: ...

  def getRemoteControlID(self) -> int: ...

  def getRemoteRange(self) -> int: ...

  def getReplaceOnUse(self) -> str: ...

  def getReplaceOnUseFullType(self) -> str: ...

  def getReplaceOnUseOn(self) -> str: ...

  def getReplaceOnUseOnString(self) -> str: ...

  def getReplaceType(self, key: str) -> str: ...

  def getReplaceTypes(self) -> str: ...

  def getReplaceTypesMap(self) -> HashMap[str, str]: ...

  def getRequireInHandOrInventory(self) -> ArrayList[str]: ...

  def getRightClickContainer(self) -> ItemContainer: ...

  def getSaveType(self) -> int: ...

  def getScore(self, desc: SurvivorDesc) -> float: ...

  def getScriptItem(self) -> Item: ...

  def getSoundByID(self, ID: str) -> str: ...

  def getSoundParameter(self, parameterName: str) -> str: ...

  def getStashChance(self) -> int: ...

  def getStaticModel(self) -> str: ...

  def getStressChange(self) -> float: ...

  def getStringItemType(self) -> str: ...

  def getSuspensionCompression(self) -> float: ...

  def getSuspensionDamping(self) -> float: ...

  def getSwingAnim(self) -> str: ...

  def getTags(self) -> ArrayList[str]: ...

  def getTaken(self) -> ArrayList[IsoObject]: ...

  def getTex(self) -> Texture: ...

  def getTexture(self) -> Texture: ...

  def getTextureBurnt(self) -> Texture: ...

  def getTextureCooked(self) -> Texture: ...

  def getTexturerotten(self) -> Texture: ...

  def getTooltip(self) -> str: ...

  def getTorchDot(self) -> float: ...

  def getType(self) -> str: ...

  def getUnCookedString(self) -> str: ...

  def getUnequipSound(self) -> str: ...

  def getUnequippedWeight(self) -> float: ...

  def getUnhappyChange(self) -> float: ...

  def getUses(self) -> int: ...

  def getVisual(self) -> ItemVisual: ...

  def getWeight(self) -> float: ...

  def getWetCooldown(self) -> float: ...

  def getWheelFriction(self) -> float: ...

  def getWorker(self) -> str: ...

  def getWorldItem(self) -> IsoWorldInventoryObject: ...

  def getWorldStaticItem(self) -> str: ...

  def getWorldTexture(self) -> str: ...

  def hasBlood(self) -> bool: ...

  def hasDirt(self) -> bool: ...

  def hasModData(self) -> bool: ...

  def hasReplaceType(self, key: str) -> bool: ...

  def hasTag(self, tag: str) -> bool: ...

  def haveExtraItems(self) -> bool: ...

  def initialiseItem(self) -> None: ...

  def isActivated(self) -> bool: ...

  def isAlcoholic(self) -> bool: ...

  def isAlwaysWelcomeGift(self) -> bool: ...

  def isBeingFilled(self) -> bool: ...

  def isBroken(self) -> bool: ...

  def isBurnt(self) -> bool: ...

  def isCanBandage(self) -> bool: ...

  def isConditionAffectsCapacity(self) -> bool: ...

  def isCookable(self) -> bool: ...

  def isCooked(self) -> bool: ...

  def isCustomColor(self) -> bool: ...

  def isCustomName(self) -> bool: ...

  def isCustomWeight(self) -> bool: ...

  def isDisappearOnUse(self) -> bool: ...

  def isEmittingLight(self) -> bool: ...

  def isEquipped(self) -> bool: ...

  def isEquippedNoSprint(self) -> bool: ...

  def isFavorite(self) -> bool: ...

  def isFishingLure(self) -> bool: ...

  def isHairDye(self) -> bool: ...

  def isHidden(self) -> bool: ...

  def isInLocalPlayerInventory(self) -> bool: ...

  def isInPlayerInventory(self) -> bool: ...

  def isInfected(self) -> bool: ...

  def isInitialised(self) -> bool: ...

  def isIsCookable(self) -> bool: ...

  def isProtectFromRainWhileEquipped(self) -> bool: ...

  def isRecordedMedia(self) -> bool: ...

  def isRemoteController(self) -> bool: ...

  def isRequiresEquippedBothHands(self) -> bool: ...

  def isTaintedWater(self) -> bool: ...

  def isTorchCone(self) -> bool: ...

  def isTrap(self) -> bool: ...

  def isTwoHandWeapon(self) -> bool: ...

  def isUseWorldItem(self) -> bool: ...

  def isVanilla(self) -> bool: ...

  def isWaterSource(self) -> bool: ...

  def isWet(self) -> bool: ...

  def load(self, input: ByteBuffer, WorldVersion: int) -> None: ...

  def save(self, output: ByteBuffer, net: bool) -> None: ...

  def saveWithSize(self, output: ByteBuffer, net: bool) -> None: ...

  def setActivated(self, activated: bool) -> None: ...

  def setActivatedRemote(self, activated: bool) -> None: ...

  def setActualWeight(self, ActualWeight: float) -> None: ...

  def setAge(self, Age: float) -> None: ...

  def setAlcoholPower(self, alcoholPower: float) -> None: ...

  def setAlcoholic(self, alcoholic: bool) -> None: ...

  def setAmmoType(self, ammoType: str) -> None: ...

  def setAttachedSlot(self, attachedSlot: int) -> None: ...

  def setAttachedSlotType(self, attachedSlotType: str) -> None: ...

  def setAttachedToModel(self, attachedToModel: str) -> None: ...

  def setAttachmentReplacement(self, attachementReplacement: str) -> None: ...

  def setAttachmentType(self, attachmentType: str) -> None: ...

  def setAttachmentsProvided(self, attachmentsProvided: ArrayList[str]) -> None: ...

  def setAutoAge(self) -> None: ...

  def setBandagePower(self, bandagePower: float) -> None: ...

  def setBeingFilled(self, v: bool) -> None: ...

  def setBlood(self, bodyPartType: BloodBodyPartType, amount: float) -> None: ...

  def setBloodClothingType(self, bloodClothingType: ArrayList[BloodClothingType]) -> None: ...

  def setBoredomChange(self, boredomChange: float) -> None: ...

  def setBrakeForce(self, brakeForce: float) -> None: ...

  def setBreakSound(self, breakSound: str) -> None: ...

  def setBroken(self, broken: bool) -> None: ...

  def setBurnt(self, Burnt: bool) -> None: ...

  def setBurntString(self, BurntString: str) -> None: ...

  def setCanBeActivated(self, activatedItem: bool) -> None: ...

  def setCanBeRemote(self, canBeRemote: bool) -> None: ...

  def setCat(self, cat: ItemType) -> None: ...

  def setChanceToSpawnDamaged(self, chanceToSpawnDamaged: int) -> None: ...

  def setColor(self, color: Color) -> None: ...

  def setColorBlue(self, colorBlue: float) -> None: ...

  def setColorGreen(self, colorGreen: float) -> None: ...

  def setColorRed(self, colorRed: float) -> None: ...

  @overload
  def setCondition(self, Condition: int) -> None: ...

  @overload
  def setCondition(self, Condition: int, doSound: bool) -> None: ...

  def setConditionFromModData(self, other: InventoryItem) -> None: ...

  def setConditionLowerNormal(self, conditionLowerNormal: float) -> None: ...

  def setConditionLowerOffroad(self, conditionLowerOffroad: float) -> None: ...

  def setConditionMax(self, ConditionMax: int) -> None: ...

  def setContainer(self, container: ItemContainer) -> None: ...

  def setContainerX(self, containerX: int) -> None: ...

  def setContainerY(self, containerY: int) -> None: ...

  def setCooked(self, Cooked: bool) -> None: ...

  def setCookedString(self, CookedString: str) -> None: ...

  def setCookingTime(self, CookingTime: float) -> None: ...

  def setCount(self, count: int) -> None: ...

  def setCountDownSound(self, sound: str) -> None: ...

  def setCurrentAmmoCount(self, ammo: int) -> None: ...

  def setCustomColor(self, customColor: bool) -> None: ...

  def setCustomMenuOption(self, customMenuOption: str) -> None: ...

  def setCustomName(self, customName: bool) -> None: ...

  def setCustomWeight(self, custom: bool) -> None: ...

  def setDescription(self, Description: str) -> None: ...

  def setDirt(self, bodyPartType: BloodBodyPartType, amount: float) -> None: ...

  def setDisplayCategory(self, displayCategory: str) -> None: ...

  def setEngineLoudness(self, engineLoudness: float) -> None: ...

  def setEquipParent(self, parent: IsoGameCharacter) -> None: ...

  def setEvolvedRecipeName(self, evolvedRecipeName: str) -> None: ...

  def setExplosionSound(self, explosionSound: str) -> None: ...

  def setFatigueChange(self, fatigueChange: float) -> None: ...

  def setFavorite(self, favorite: bool) -> None: ...

  def setGunType(self, gunType: str) -> None: ...

  def setHaveBeenRepaired(self, haveBeenRepaired: int) -> None: ...

  def setID(self, itemId: int) -> None: ...

  def setIconsForTexture(self, iconsForTexture: ArrayList[str]) -> None: ...

  def setInfected(self, infected: bool) -> None: ...

  def setInitialised(self, initialised: bool) -> None: ...

  def setIsCookable(self, IsCookable: bool) -> None: ...

  def setIsWaterSource(self, IsWaterSource: bool) -> None: ...

  def setItemCapacity(self, capacity: float) -> None: ...

  def setItemHeat(self, itemHeat: float) -> None: ...

  def setItemWhenDry(self, itemWhenDry: str) -> None: ...

  def setJobDelta(self, delta: float) -> None: ...

  def setJobType(self, type: str) -> None: ...

  def setKeyId(self, keyId: int) -> None: ...

  def setLastAged(self, time: float) -> None: ...

  def setLightDistance(self, lightDistance: int) -> None: ...

  def setLightStrength(self, lightStrength: float) -> None: ...

  def setMaxAmmo(self, maxAmmoCount: int) -> None: ...

  def setMaxCapacity(self, maxCapacity: int) -> None: ...

  def setMediaType(self, b: int) -> None: ...

  def setMeltingTime(self, meltingTime: float) -> None: ...

  def setMetalValue(self, metalValue: float) -> None: ...

  def setMinutesToBurn(self, MinutesToBurn: float) -> None: ...

  def setMinutesToCook(self, MinutesToCook: float) -> None: ...

  def setModule(self, module: str) -> None: ...

  def setName(self, name: str) -> None: ...

  def setNewPlaceDir(self, newPlaceDir: IsoDirections) -> None: ...

  def setOffAge(self, OffAge: int) -> None: ...

  def setOffAgeMax(self, OffAgeMax: int) -> None: ...

  def setOffString(self, OffString: str) -> None: ...

  def setPlaceDir(self, placeDir: IsoDirections) -> None: ...

  def setPreviousOwner(self, previousOwner: IsoGameCharacter) -> None: ...

  def setRecordedMediaData(self, data: MediaData) -> None: ...

  def setRecordedMediaIndex(self, id: int) -> None: ...

  def setRecordedMediaIndexInteger(self, id: int) -> None: ...

  def setReduceInfectionPower(self, reduceInfectionPower: float) -> None: ...

  def setRegistry_id(self, itemscript: Item) -> None: ...

  def setRemoteControlID(self, remoteControlID: int) -> None: ...

  def setRemoteController(self, remoteController: bool) -> None: ...

  def setRemoteRange(self, remoteRange: int) -> None: ...

  def setReplaceOnUse(self, replaceOnUse: str) -> None: ...

  def setReplaceOnUseOn(self, ReplaceOnUseOn: str) -> None: ...

  def setRequireInHandOrInventory(self, requireInHandOrInventory: ArrayList[str]) -> None: ...

  def setRightClickContainer(self, rightClickContainer: ItemContainer) -> None: ...

  def setScriptItem(self, ScriptItem: Item) -> None: ...

  def setStashChance(self, stashChance: int) -> None: ...

  def setStashMap(self, stashMap: str) -> None: ...

  def setStressChange(self, stressChange: float) -> None: ...

  def setSuspensionCompression(self, suspensionCompression: float) -> None: ...

  def setSuspensionDamping(self, suspensionDamping: float) -> None: ...

  def setTaintedWater(self, taintedWater: bool) -> None: ...

  def setTaken(self, Taken: ArrayList[IsoObject]) -> None: ...

  def setTexture(self, texture: Texture) -> None: ...

  def setTextureBurnt(self, textureBurnt: Texture) -> None: ...

  def setTextureCooked(self, textureCooked: Texture) -> None: ...

  def setTexturerotten(self, texturerotten: Texture) -> None: ...

  def setTooltip(self, tooltip: str) -> None: ...

  def setTorchCone(self, isTorchCone: bool) -> None: ...

  def setType(self, type: str) -> None: ...

  def setUnCookedString(self, UnCookedString: str) -> None: ...

  def setUnhappyChange(self, unhappyChange: float) -> None: ...

  def setUses(self, uses: int) -> None: ...

  def setWeight(self, Weight: float) -> None: ...

  def setWet(self, isWet: bool) -> None: ...

  def setWetCooldown(self, wetCooldown: float) -> None: ...

  def setWheelFriction(self, wheelFriction: float) -> None: ...

  def setWorker(self, worker: str) -> None: ...

  def setWorldItem(self, w: IsoWorldInventoryObject) -> None: ...

  def setWorldScale(self, scale: float) -> None: ...

  def setWorldTexture(self, WorldTexture: str) -> None: ...

  def setWorldZRotation(self, rot: int) -> None: ...

  def shouldUpdateInWorld(self) -> bool: ...

  def storeInByteData(self, o: IsoObject) -> None: ...

  def synchWithVisual(self) -> None: ...

  def update(self) -> None: ...

  def updateAge(self) -> None: ...

  def updateSound(self, emitter: BaseSoundEmitter) -> None: ...

  @staticmethod
  @overload
  def loadItem(input: ByteBuffer, WorldVersion: int) -> InventoryItem: ...

  @staticmethod
  @overload
  def loadItem(input: ByteBuffer, WorldVersion: int, doSaveTypeCheck: bool) -> InventoryItem: ...

  @overload
  def __init__(self, module: str, name: str, type: str, tex: str):
    self.atlastexture: WorldItemAtlas.ItemTexture

    self.bytedata: ByteBuffer

    self.canstack: bool

    self.canstorewater: bool

    self.closekillmove: str

    self.col: Color

    self.cooked: bool

    self.extraitems: ArrayList[str]

    self.fatiguechange: float

    self.id: int

    self.iswatersource: bool

    self.jobdelta: float

    self.jobtype: str

    self.keepondeplete: bool

    self.maincategory: str

    self.replaceonuseon: str

    self.requiresequippedbothhands: bool

    self.worlditem: IsoWorldInventoryObject

    self.worldscale: float

    self.worldzrotation: int

  @overload
  def __init__(self, module: str, name: str, type: str, item: Item): ...


class InventoryItemFactory:

  @staticmethod
  @overload
  def CreateItem(itemType: str) -> InventoryItem: ...

  @staticmethod
  @overload
  def CreateItem(registryID: int) -> InventoryItem: ...

  @staticmethod
  @overload
  def CreateItem(itemType: str, useDelta: float) -> InventoryItem: ...

  @staticmethod
  @overload
  def CreateItem(itemType: str, food: Food) -> InventoryItem: ...

  @staticmethod
  @overload
  def CreateItem(itemType: str, useDelta: float, moduleDefaultsToBase: bool) -> InventoryItem: ...

  @staticmethod
  @overload
  def CreateItem(itemType: str, useDelta: float, param: str) -> InventoryItem: ...

  @staticmethod
  @overload
  def CreateItem(module: str, name: str, type: str, tex: str) -> InventoryItem: ...

  def __init__(self): ...


class ItemContainer:

  @overload
  def AddItem(self, type: str) -> InventoryItem: ...

  @overload
  def AddItem(self, item: InventoryItem) -> InventoryItem: ...

  @overload
  def AddItem(self, type: str, useDelta: float) -> bool: ...

  def AddItemBlind(self, item: InventoryItem) -> InventoryItem: ...

  @overload
  def AddItems(self, item: str, use: int) -> ArrayList[InventoryItem]: ...

  @overload
  def AddItems(self, item: InventoryItem, use: int) -> None: ...

  def DoAddItem(self, item: InventoryItem) -> InventoryItem: ...

  def DoAddItemBlind(self, item: InventoryItem) -> InventoryItem: ...

  def DoRemoveItem(self, item: InventoryItem) -> None: ...

  def Find(self, itemType: ItemType) -> InventoryItem: ...

  def FindAll(self, type: str) -> ArrayList[InventoryItem]: ...

  @overload
  def FindAndReturn(self, type: str) -> InventoryItem: ...

  @overload
  def FindAndReturn(self, type: str, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def FindAndReturn(self, type: str, itemToCheck: ArrayList[InventoryItem]) -> InventoryItem: ...

  def FindAndReturnCategory(self, category: str) -> InventoryItem: ...

  @overload
  def FindAndReturnStack(self, type: str) -> InventoryItem: ...

  @overload
  def FindAndReturnStack(self, itemlike: InventoryItem) -> InventoryItem: ...

  def FindAndReturnWaterItem(self, uses: int) -> InventoryItem: ...

  def FindWaterSource(self) -> InventoryItem: ...

  def HasType(self, itemType: ItemType) -> bool: ...

  @overload
  def Remove(self, itemTypes: str) -> None: ...

  @overload
  def Remove(self, item: InventoryItem) -> None: ...

  @overload
  def Remove(self, itemType: ItemType) -> InventoryItem: ...

  def RemoveAll(self, itemType: str) -> None: ...

  @overload
  def RemoveOneOf(self, String: str) -> None: ...

  @overload
  def RemoveOneOf(self, String: str, insideInv: bool) -> bool: ...

  def addItem(self, item: InventoryItem) -> InventoryItem: ...

  def addItemOnServer(self, item: InventoryItem) -> None: ...

  def addItemsToProcessItems(self) -> None: ...

  def clear(self) -> None: ...

  @overload
  def contains(self, type: str) -> bool: ...

  @overload
  def contains(self, item: InventoryItem) -> bool: ...

  @overload
  def contains(self, type: str, doInv: bool) -> bool: ...

  @overload
  def contains(self, itemToFind: InventoryItem, doInv: bool) -> bool: ...

  @overload
  def contains(self, type: str, doInv: bool, ignoreBroken: bool) -> bool: ...

  def containsEval(self, functionObj: LuaClosure) -> bool: ...

  def containsEvalArg(self, functionObj: LuaClosure, arg: object) -> bool: ...

  def containsEvalArgRecurse(self, functionObj: LuaClosure, arg: object) -> bool: ...

  def containsEvalRecurse(self, functionObj: LuaClosure) -> bool: ...

  def containsID(self, id: int) -> bool: ...

  def containsRecursive(self, item: InventoryItem) -> bool: ...

  def containsTag(self, tag: str) -> bool: ...

  def containsTagEval(self, tag: str, functionObj: LuaClosure) -> bool: ...

  def containsTagEvalArgRecurse(self, tag: str, functionObj: LuaClosure, arg: object) -> bool: ...

  def containsTagEvalRecurse(self, tag: str, functionObj: LuaClosure) -> bool: ...

  def containsTagRecurse(self, tag: str) -> bool: ...

  def containsType(self, type: str) -> bool: ...

  def containsTypeEvalArgRecurse(self, type: str, functionObj: LuaClosure, arg: object) -> bool: ...

  def containsTypeEvalRecurse(self, type: str, functionObj: LuaClosure) -> bool: ...

  def containsTypeRecurse(self, type: str) -> bool: ...

  @overload
  def containsWithModule(self, moduleType: str) -> bool: ...

  @overload
  def containsWithModule(self, moduleType: str, withDeltaLeft: bool) -> bool: ...

  def emptyIt(self) -> None: ...

  def getAcceptItemFunction(self) -> str: ...

  def getAgeFactor(self) -> float: ...

  @overload
  def getAll(self, predicate: Predicate[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAll(self, predicate: Predicate[InventoryItem], result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllCategory(self, category: str) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllCategory(self, category: str, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getAllCategoryRecurse(self, category: str, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllEval(self, functionObj: LuaClosure) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllEval(self, functionObj: LuaClosure, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllEvalArg(self, functionObj: LuaClosure, arg: object) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllEvalArg(self, functionObj: LuaClosure, arg: object, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllEvalArgRecurse(self, functionObj: LuaClosure, arg: object) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllEvalArgRecurse(self, functionObj: LuaClosure, arg: object, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllEvalRecurse(self, functionObj: LuaClosure) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllEvalRecurse(self, functionObj: LuaClosure, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getAllItems(self, items: LinkedHashMap[str, InventoryItem], inInv: bool) -> LinkedHashMap[str, InventoryItem]: ...

  def getAllRecurse(self, predicate: Predicate[InventoryItem], result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getAllTag(self, tag: str, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTagEval(self, type: str, functionObj: LuaClosure) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTagEval(self, tag: str, functionObj: LuaClosure, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTagEvalArg(self, type: str, functionObj: LuaClosure, arg: object) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTagEvalArg(self, tag: str, functionObj: LuaClosure, arg: object, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getAllTagEvalArgRecurse(self, tag: str, functionObj: LuaClosure, arg: object, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getAllTagEvalRecurse(self, tag: str, functionObj: LuaClosure, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getAllTagRecurse(self, tag: str, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllType(self, type: str) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllType(self, type: str, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTypeEval(self, type: str, functionObj: LuaClosure) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTypeEval(self, type: str, functionObj: LuaClosure, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTypeEvalArg(self, type: str, functionObj: LuaClosure, arg: object) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTypeEvalArg(self, type: str, functionObj: LuaClosure, arg: object, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTypeEvalArgRecurse(self, type: str, functionObj: LuaClosure, arg: object) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTypeEvalArgRecurse(self, type: str, functionObj: LuaClosure, arg: object, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTypeEvalRecurse(self, type: str, functionObj: LuaClosure) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTypeEvalRecurse(self, type: str, functionObj: LuaClosure, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTypeRecurse(self, type: str) -> ArrayList[InventoryItem]: ...

  @overload
  def getAllTypeRecurse(self, type: str, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getAllWaterFillables(self) -> ArrayList[InventoryItem]: ...

  def getBest(self, predicate: Predicate[InventoryItem], comparator: Comparator[InventoryItem]) -> InventoryItem: ...

  def getBestBandage(self, descriptor: SurvivorDesc) -> InventoryItem: ...

  @overload
  def getBestCondition(self, type: str) -> InventoryItem: ...

  @overload
  def getBestCondition(self, predicate: Predicate[InventoryItem]) -> InventoryItem: ...

  def getBestConditionEval(self, functionObj: LuaClosure) -> InventoryItem: ...

  def getBestConditionEvalArg(self, functionObj: LuaClosure, arg: object) -> InventoryItem: ...

  def getBestConditionEvalArgRecurse(self, functionObj: LuaClosure, arg: object) -> InventoryItem: ...

  def getBestConditionEvalRecurse(self, functionObj: LuaClosure) -> InventoryItem: ...

  @overload
  def getBestConditionRecurse(self, type: str) -> InventoryItem: ...

  @overload
  def getBestConditionRecurse(self, predicate: Predicate[InventoryItem]) -> InventoryItem: ...

  def getBestEval(self, predicateObj: LuaClosure, comparatorObj: LuaClosure) -> InventoryItem: ...

  def getBestEvalArg(self, predicateObj: LuaClosure, comparatorObj: LuaClosure, arg: object) -> InventoryItem: ...

  def getBestEvalArgRecurse(self, predicateObj: LuaClosure, comparatorObj: LuaClosure, arg: object) -> InventoryItem: ...

  def getBestEvalRecurse(self, predicateObj: LuaClosure, comparatorObj: LuaClosure) -> InventoryItem: ...

  def getBestFood(self, descriptor: SurvivorDesc) -> InventoryItem: ...

  def getBestRecurse(self, predicate: Predicate[InventoryItem], comparator: Comparator[InventoryItem]) -> InventoryItem: ...

  def getBestType(self, type: str, comparator: Comparator[InventoryItem]) -> InventoryItem: ...

  def getBestTypeEval(self, type: str, comparatorObj: LuaClosure) -> InventoryItem: ...

  def getBestTypeEvalArg(self, type: str, comparatorObj: LuaClosure, arg: object) -> InventoryItem: ...

  def getBestTypeEvalArgRecurse(self, type: str, comparatorObj: LuaClosure, arg: object) -> InventoryItem: ...

  def getBestTypeEvalRecurse(self, type: str, comparatorObj: LuaClosure) -> InventoryItem: ...

  def getBestTypeRecurse(self, type: str, comparator: Comparator[InventoryItem]) -> InventoryItem: ...

  @overload
  def getBestWeapon(self) -> InventoryItem: ...

  @overload
  def getBestWeapon(self, desc: SurvivorDesc) -> InventoryItem: ...

  def getCapacity(self) -> int: ...

  def getCapacityWeight(self) -> float: ...

  def getCharacter(self) -> IsoGameCharacter: ...

  def getCloseSound(self) -> str: ...

  def getContainerPosition(self) -> str: ...

  def getContainingItem(self) -> InventoryItem: ...

  def getContentsWeight(self) -> float: ...

  def getCookingFactor(self) -> float: ...

  def getCount(self, predicate: Predicate[InventoryItem]) -> int: ...

  def getCountEval(self, functionObj: LuaClosure) -> int: ...

  def getCountEvalArg(self, functionObj: LuaClosure, arg: object) -> int: ...

  def getCountEvalArgRecurse(self, functionObj: LuaClosure, arg: object) -> int: ...

  def getCountEvalRecurse(self, functionObj: LuaClosure) -> int: ...

  def getCountRecurse(self, predicate: Predicate[InventoryItem]) -> int: ...

  def getCountTag(self, tag: str) -> int: ...

  def getCountTagEval(self, tag: str, functionObj: LuaClosure) -> int: ...

  def getCountTagEvalArg(self, tag: str, functionObj: LuaClosure, arg: object) -> int: ...

  def getCountTagEvalArgRecurse(self, tag: str, functionObj: LuaClosure, arg: object) -> int: ...

  def getCountTagEvalRecurse(self, tag: str, functionObj: LuaClosure) -> int: ...

  def getCountTagRecurse(self, tag: str) -> int: ...

  def getCountType(self, type: str) -> int: ...

  def getCountTypeEval(self, type: str, functionObj: LuaClosure) -> int: ...

  def getCountTypeEvalArg(self, type: str, functionObj: LuaClosure, arg: object) -> int: ...

  def getCountTypeEvalArgRecurse(self, type: str, functionObj: LuaClosure, arg: object) -> int: ...

  def getCountTypeEvalRecurse(self, type: str, functionObj: LuaClosure) -> int: ...

  def getCountTypeRecurse(self, type: str) -> int: ...

  def getCustomTemperature(self) -> float: ...

  def getEffectiveCapacity(self, chr: IsoGameCharacter) -> int: ...

  def getFirst(self, predicate: Predicate[InventoryItem]) -> InventoryItem: ...

  def getFirstCategory(self, category: str) -> InventoryItem: ...

  def getFirstCategoryRecurse(self, category: str) -> InventoryItem: ...

  def getFirstEval(self, functionObj: LuaClosure) -> InventoryItem: ...

  def getFirstEvalArg(self, functionObj: LuaClosure, arg: object) -> InventoryItem: ...

  def getFirstEvalArgRecurse(self, functionObj: LuaClosure, arg: object) -> InventoryItem: ...

  def getFirstEvalRecurse(self, functionObj: LuaClosure) -> InventoryItem: ...

  def getFirstRecurse(self, predicate: Predicate[InventoryItem]) -> InventoryItem: ...

  def getFirstTag(self, tag: str) -> InventoryItem: ...

  def getFirstTagEval(self, tag: str, functionObj: LuaClosure) -> InventoryItem: ...

  def getFirstTagEvalArgRecurse(self, tag: str, functionObj: LuaClosure, arg: object) -> InventoryItem: ...

  def getFirstTagEvalRecurse(self, tag: str, functionObj: LuaClosure) -> InventoryItem: ...

  def getFirstTagRecurse(self, tag: str) -> InventoryItem: ...

  def getFirstType(self, type: str) -> InventoryItem: ...

  def getFirstTypeEval(self, type: str, functionObj: LuaClosure) -> InventoryItem: ...

  def getFirstTypeEvalArgRecurse(self, type: str, functionObj: LuaClosure, arg: object) -> InventoryItem: ...

  def getFirstTypeEvalRecurse(self, type: str, functionObj: LuaClosure) -> InventoryItem: ...

  def getFirstTypeRecurse(self, type: str) -> InventoryItem: ...

  def getFreezerPosition(self) -> str: ...

  def getItemById(self, id: int) -> InventoryItem: ...

  @overload
  def getItemCount(self, type: str) -> int: ...

  @overload
  def getItemCount(self, type: str, doBags: bool) -> int: ...

  def getItemCountFromTypeRecurse(self, type: str) -> int: ...

  def getItemCountRecurse(self, type: str) -> int: ...

  @overload
  def getItemFromType(self, type: str) -> InventoryItem: ...

  @overload
  def getItemFromType(self, type: str, ignoreBroken: bool, includeInv: bool) -> InventoryItem: ...

  @overload
  def getItemFromType(self, type: str, chr: IsoGameCharacter, notEquipped: bool, ignoreBroken: bool, includeInv: bool) -> InventoryItem: ...

  def getItemFromTypeRecurse(self, type: str) -> InventoryItem: ...

  def getItemWithID(self, id: int) -> InventoryItem: ...

  def getItemWithIDRecursiv(self, id: int) -> InventoryItem: ...

  def getItems(self) -> ArrayList[InventoryItem]: ...

  def getItems4Admin(self) -> LinkedHashMap[str, InventoryItem]: ...

  def getItemsFromCategory(self, category: str) -> ArrayList[InventoryItem]: ...

  @overload
  def getItemsFromFullType(self, type: str) -> ArrayList[InventoryItem]: ...

  @overload
  def getItemsFromFullType(self, type: str, includeInv: bool) -> ArrayList[InventoryItem]: ...

  @overload
  def getItemsFromType(self, type: str) -> ArrayList[InventoryItem]: ...

  @overload
  def getItemsFromType(self, type: str, includeInv: bool) -> ArrayList[InventoryItem]: ...

  def getMaxWeight(self) -> float: ...

  def getNumItems(self, item: str) -> int: ...

  @overload
  def getNumberOfItem(self, findItem: str) -> int: ...

  @overload
  def getNumberOfItem(self, findItem: str, includeReplaceOnDeplete: bool) -> int: ...

  @overload
  def getNumberOfItem(self, findItem: str, includeReplaceOnDeplete: bool, insideInv: bool) -> int: ...

  @overload
  def getNumberOfItem(self, findItem: str, includeReplaceOnDeplete: bool, containers: ArrayList[ItemContainer]) -> int: ...

  def getOnlyAcceptCategory(self) -> str: ...

  def getOpenSound(self) -> str: ...

  def getParent(self) -> IsoObject: ...

  def getPutSound(self) -> str: ...

  def getSome(self, predicate: Predicate[InventoryItem], count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeCategory(self, category: str, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeCategory(self, category: str, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getSomeCategoryRecurse(self, category: str, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeEval(self, functionObj: LuaClosure, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeEval(self, functionObj: LuaClosure, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeEvalArg(self, functionObj: LuaClosure, arg: object, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeEvalArg(self, functionObj: LuaClosure, arg: object, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeEvalArgRecurse(self, functionObj: LuaClosure, arg: object, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeEvalArgRecurse(self, functionObj: LuaClosure, arg: object, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeEvalRecurse(self, functionObj: LuaClosure, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeEvalRecurse(self, functionObj: LuaClosure, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getSomeRecurse(self, predicate: Predicate[InventoryItem], count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTag(self, tag: str, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTag(self, tag: str, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getSomeTagEval(self, tag: str, functionObj: LuaClosure, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getSomeTagEvalArg(self, tag: str, functionObj: LuaClosure, arg: object, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTagEvalArgRecurse(self, tag: str, functionObj: LuaClosure, arg: object, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTagEvalArgRecurse(self, tag: str, functionObj: LuaClosure, arg: object, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTagEvalRecurse(self, tag: str, functionObj: LuaClosure, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTagEvalRecurse(self, tag: str, functionObj: LuaClosure, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTagRecurse(self, tag: str, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTagRecurse(self, tag: str, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeType(self, type: str, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeType(self, type: str, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTypeEval(self, type: str, functionObj: LuaClosure, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTypeEval(self, type: str, functionObj: LuaClosure, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTypeEvalArg(self, type: str, functionObj: LuaClosure, arg: object, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTypeEvalArg(self, type: str, functionObj: LuaClosure, arg: object, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTypeEvalArgRecurse(self, type: str, functionObj: LuaClosure, arg: object, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTypeEvalArgRecurse(self, type: str, functionObj: LuaClosure, arg: object, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTypeEvalRecurse(self, type: str, functionObj: LuaClosure, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTypeEvalRecurse(self, type: str, functionObj: LuaClosure, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTypeRecurse(self, type: str, count: int) -> ArrayList[InventoryItem]: ...

  @overload
  def getSomeTypeRecurse(self, type: str, count: int, result: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  def getSourceGrid(self) -> IsoGridSquare: ...

  def getTemprature(self) -> float: ...

  def getTotalFoodScore(self, desc: SurvivorDesc) -> float: ...

  def getTotalWeaponScore(self, desc: SurvivorDesc) -> float: ...

  def getType(self) -> str: ...

  def getUsesRecurse(self, predicate: Predicate[InventoryItem]) -> int: ...

  def getUsesType(self, type: str) -> int: ...

  def getUsesTypeRecurse(self, type: str) -> int: ...

  def getVehiclePart(self) -> VehiclePart: ...

  def getWaterContainerCount(self) -> int: ...

  def getWeight(self) -> int: ...

  def getWeightReduction(self) -> int: ...

  @overload
  def hasRoomFor(self, chr: IsoGameCharacter, weightVal: float) -> bool: ...

  @overload
  def hasRoomFor(self, chr: IsoGameCharacter, item: InventoryItem) -> bool: ...

  def haveThisKeyId(self, keyId: int) -> InventoryItem: ...

  def isActive(self) -> bool: ...

  def isDirty(self) -> bool: ...

  def isDrawDirty(self) -> bool: ...

  def isEmpty(self) -> bool: ...

  def isExistYet(self) -> bool: ...

  def isExplored(self) -> bool: ...

  def isHasBeenLooted(self) -> bool: ...

  def isInCharacterInventory(self, chr: IsoGameCharacter) -> bool: ...

  def isInside(self, item: InventoryItem) -> bool: ...

  def isIsDevice(self) -> bool: ...

  def isItemAllowed(self, item: InventoryItem) -> bool: ...

  def isMicrowave(self) -> bool: ...

  def isPowered(self) -> bool: ...

  def isRemoveItemAllowed(self, item: InventoryItem) -> bool: ...

  def isTemperatureChanging(self) -> bool: ...

  def load(self, input: ByteBuffer, WorldVersion: int) -> ArrayList[InventoryItem]: ...

  def removeAllItems(self) -> None: ...

  def removeItemOnServer(self, item: InventoryItem) -> None: ...

  def removeItemWithID(self, id: int) -> bool: ...

  def removeItemWithIDRecurse(self, id: int) -> bool: ...

  def removeItemsFromProcessItems(self) -> None: ...

  def requestServerItemsForContainer(self) -> None: ...

  def requestSync(self) -> None: ...

  @overload
  def save(self, output: ByteBuffer) -> ArrayList[InventoryItem]: ...

  @overload
  def save(self, output: ByteBuffer, noCompress: IsoGameCharacter) -> ArrayList[InventoryItem]: ...

  @overload
  def sendContentsToRemoteContainer(self) -> None: ...

  @overload
  def sendContentsToRemoteContainer(self, connection: UdpConnection) -> None: ...

  def setAcceptItemFunction(self, functionName: str) -> None: ...

  def setActive(self, active: bool) -> None: ...

  def setAgeFactor(self, ageFactor: float) -> None: ...

  def setCapacity(self, arg0: int) -> None: ...

  def setCloseSound(self, closeSound: str) -> None: ...

  def setContainerPosition(self, containerPosition: str) -> None: ...

  def setCookingFactor(self, CookingFactor: float) -> None: ...

  def setCustomTemperature(self, newTemp: float) -> None: ...

  def setDirty(self, dirty: bool) -> None: ...

  def setDrawDirty(self, b: bool) -> None: ...

  def setExplored(self, b: bool) -> None: ...

  def setFreezerPosition(self, freezerPosition: str) -> None: ...

  def setHasBeenLooted(self, hasBeenLooted: bool) -> None: ...

  def setIsDevice(self, IsDevice: bool) -> None: ...

  def setItems(self, Items: ArrayList[InventoryItem]) -> None: ...

  def setOnlyAcceptCategory(self, onlyAcceptCategory: str) -> None: ...

  def setOpenSound(self, openSound: str) -> None: ...

  def setParent(self, parent: IsoObject) -> None: ...

  def setPutSound(self, putSound: str) -> None: ...

  def setSourceGrid(self, SourceGrid: IsoGridSquare) -> None: ...

  def setType(self, type: str) -> None: ...

  def setWeightReduction(self, weightReduction: int) -> None: ...

  @staticmethod
  def floatingPointCorrection(val: float) -> float: ...

  @overload
  def __init__(self):
    self.active: bool

    self.agefactor: float

    self.bexplored: bool

    self.capacity: int

    self.containingitem: InventoryItem

    self.cookingfactor: float

    self.id: int

    self.includingobsoleteitems: ArrayList[InventoryItem]

    self.inventorycontainer: InventoryContainer

    self.isdevice: bool

    self.items: ArrayList[InventoryItem]

    self.parent: IsoObject

    self.sourcegrid: IsoGridSquare

    self.type: str

    self.vehiclepart: VehiclePart

  @overload
  def __init__(self, ID: int): ...
  @overload
  def __init__(self, containerName: str, square: IsoGridSquare, parent: IsoObject): ...
  @overload
  def __init__(self, ID: int, containerName: str, square: IsoGridSquare, parent: IsoObject): ...

  class InventoryItemListPool(ObjectPool):

    @overload
    def release(self, arg0: object) -> None: ...

    @overload
    def release(self, arg0: ItemContainer.InventoryItemList) -> None: ...

    def __init__(self): ...

  class InventoryItemList(ArrayList):

    def equals(self, arg0: object) -> bool: ...

  class Predicates: ...

  class TypePredicate:

    def negate(self) -> Predicate[T]: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: InventoryItem) -> bool: ...

    @staticmethod
    def isEqual(arg0: object) -> Predicate[T]: ...

  class EvalPredicate:

    def negate(self) -> Predicate[T]: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: InventoryItem) -> bool: ...

    @staticmethod
    def isEqual(arg0: object) -> Predicate[T]: ...

  class Comparators: ...

  class EvalComparator:

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: InventoryItem, arg1: InventoryItem) -> int: ...

    def equals(self, arg0: object) -> bool: ...

    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

  class EvalArgPredicate:

    def negate(self) -> Predicate[T]: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: InventoryItem) -> bool: ...

    @staticmethod
    def isEqual(arg0: object) -> Predicate[T]: ...

  class EvalArgComparator:

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: InventoryItem, arg1: InventoryItem) -> int: ...

    def equals(self, arg0: object) -> bool: ...

    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

  class ConditionComparator:

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: InventoryItem, arg1: InventoryItem) -> int: ...

    def equals(self, arg0: object) -> bool: ...

    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

  class TagPredicate:

    def negate(self) -> Predicate[T]: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: InventoryItem) -> bool: ...

    @staticmethod
    def isEqual(arg0: object) -> Predicate[T]: ...

  class TagEvalPredicate:

    def negate(self) -> Predicate[T]: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: InventoryItem) -> bool: ...

    @staticmethod
    def isEqual(arg0: object) -> Predicate[T]: ...

  class TagEvalArgPredicate:

    def negate(self) -> Predicate[T]: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: InventoryItem) -> bool: ...

    @staticmethod
    def isEqual(arg0: object) -> Predicate[T]: ...

  class TypeEvalPredicate:

    def negate(self) -> Predicate[T]: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: InventoryItem) -> bool: ...

    @staticmethod
    def isEqual(arg0: object) -> Predicate[T]: ...

  class TypeEvalArgPredicate:

    def negate(self) -> Predicate[T]: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: InventoryItem) -> bool: ...

    @staticmethod
    def isEqual(arg0: object) -> Predicate[T]: ...

  class CategoryPredicate:

    def negate(self) -> Predicate[T]: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: object) -> bool: ...

    @overload
    def test(self, arg0: InventoryItem) -> bool: ...

    @staticmethod
    def isEqual(arg0: object) -> Predicate[T]: ...


class ItemPickerJava:

  containers: THashMap[str, ItemPickerJava.ItemPickerContainer]

  NoContainerFillRooms: ArrayList[str]

  ProceduralDistributions: THashMap[str, ItemPickerJava.ItemPickerContainer]

  rooms: THashMap[str, ItemPickerJava.ItemPickerRoom]

  VehicleDistributions: THashMap[str, ItemPickerJava.VehicleDistribution]

  WeaponUpgradeMap: HashMap[str, ItemPickerJava.ItemPickerUpgradeWeapons]

  WeaponUpgrades: ArrayList[ItemPickerJava.ItemPickerUpgradeWeapons]

  zombieDensityCap: float

  @staticmethod
  def InitSandboxLootSettings() -> None: ...

  @staticmethod
  def Parse() -> None: ...

  @staticmethod
  def doOverlaySprite(sq: IsoGridSquare) -> None: ...

  @staticmethod
  def doRollItem(containerDist: ItemPickerJava.ItemPickerContainer, container: ItemContainer, zombieDensity: float, character: IsoGameCharacter, doItemContainer: bool, isJunk: bool, roomDist: ItemPickerJava.ItemPickerRoom) -> None: ...

  @staticmethod
  def fillContainer(container: ItemContainer, player: IsoPlayer) -> None: ...

  @staticmethod
  def fillContainerType(roomDist: ItemPickerJava.ItemPickerRoom, container: ItemContainer, roomName: str, character: IsoGameCharacter) -> None: ...

  @staticmethod
  def getItemContainer(room: str, container: str, proceduralName: str, junk: bool) -> ItemPickerJava.ItemPickerContainer: ...

  @staticmethod
  def getLootModifier(itemname: str) -> float: ...

  @staticmethod
  def rollContainerItem(bag: InventoryContainer, character: IsoGameCharacter, containerDist: ItemPickerJava.ItemPickerContainer) -> None: ...

  @staticmethod
  def rollItem(containerDist: ItemPickerJava.ItemPickerContainer, container: ItemContainer, doItemContainer: bool, character: IsoGameCharacter, roomDist: ItemPickerJava.ItemPickerRoom) -> None: ...

  @staticmethod
  def tryAddItemToContainer(container: ItemContainer, itemType: str, containerDist: ItemPickerJava.ItemPickerContainer) -> InventoryItem: ...

  @staticmethod
  def updateOverlaySprite(obj: IsoObject) -> None: ...

  def __init__(self): ...

  class ItemPickerUpgradeWeapons:

    def __init__(self):
      self.name: str
      self.upgrades: ArrayList[str]

  class ItemPickerContainer:

    def __init__(self):
      self.dontspawnammo: bool
      self.fillrand: int
      self.ignorezombiedensity: bool
      self.items: list[ItemPickerJava.ItemPickerItem]
      self.junk: ItemPickerJava.ItemPickerContainer
      self.maxmap: int
      self.noautoage: bool
      self.procedural: bool
      self.proceduralitems: ArrayList[ItemPickerJava.ProceduralItem]
      self.rolls: float
      self.stashchance: int

  class ItemPickerRoom:

    def __init__(self):
      self.containers: THashMap[str, ItemPickerJava.ItemPickerContainer]
      self.fillrand: int
      self.isshop: bool
      self.specificid: str

  class VehicleDistribution:

    def __init__(self):
      self.normal: ItemPickerJava.ItemPickerRoom
      self.specific: ArrayList[ItemPickerJava.ItemPickerRoom]

  class ItemPickerItem:

    def __init__(self):
      self.chance: float
      self.itemname: str

  class ProceduralItem:

    def __init__(self):
      self.forceforitems: List[str]
      self.forceforrooms: List[str]
      self.forcefortiles: List[str]
      self.forceforzones: List[str]
      self.max: int
      self.min: int
      self.name: str
      self.weightchance: int


class ItemSoundManager:

  @staticmethod
  def Reset() -> None: ...

  @staticmethod
  def addItem(item: InventoryItem) -> None: ...

  @staticmethod
  def removeItem(item: InventoryItem) -> None: ...

  @staticmethod
  def removeItems(items: ArrayList[InventoryItem]) -> None: ...

  @staticmethod
  def update() -> None: ...

  def __init__(self): ...


class ItemType(Enum):

  AlarmClock: ItemType

  AlarmClockClothing: ItemType

  Clothing: ItemType

  Drainable: ItemType

  Food: ItemType

  Key: ItemType

  KeyRing: ItemType

  Literature: ItemType

  Moveable: ItemType

  # None: ItemType

  Weapon: ItemType

  def index(self) -> int: ...

  @staticmethod
  def fromIndex(value: int) -> ItemType: ...

  @staticmethod
  def valueOf(arg0: str) -> ItemType: ...

  @staticmethod
  def values() -> list[ItemType]: ...


class ItemUser:

  @staticmethod
  def AddItem(existingItem: InventoryItem, newItem: InventoryItem) -> None: ...

  @staticmethod
  def CreateItem(fullType: str, result: ArrayList[InventoryItem]) -> None: ...

  @staticmethod
  def RemoveItem(item: InventoryItem) -> None: ...

  @staticmethod
  @overload
  def UseItem(item: InventoryItem) -> None: ...

  @staticmethod
  @overload
  def UseItem(item: InventoryItem, bCrafting: bool, bInContainer: bool) -> None: ...

  def __init__(self): ...


class RecipeManager:

  @staticmethod
  def DoesUseItemUp(itemToUse: str, recipe: Recipe) -> bool: ...

  @staticmethod
  def DoesWipeUseDelta(itemToUse: str, itemToMake: str) -> bool: ...

  @staticmethod
  def GetMovableRecipeTool(isPrimary: bool, recipe: Recipe, selectedItem: InventoryItem, chr: IsoGameCharacter, containers: ArrayList[ItemContainer]) -> InventoryItem: ...

  @staticmethod
  def HasAllRequiredItems(recipe: Recipe, chr: IsoGameCharacter, selectedItem: InventoryItem, containers: ArrayList[ItemContainer]) -> bool: ...

  @staticmethod
  def IsItemDestroyed(itemToUse: str, recipe: Recipe) -> bool: ...

  @staticmethod
  def IsRecipeValid(recipe: Recipe, chr: IsoGameCharacter, item: InventoryItem, containers: ArrayList[ItemContainer]) -> bool: ...

  @staticmethod
  def Loaded() -> None: ...

  @staticmethod
  def LoadedAfterLua() -> None: ...

  @staticmethod
  def PerformMakeItem(recipe: Recipe, selectedItem: InventoryItem, chr: IsoGameCharacter, containers: ArrayList[ItemContainer]) -> InventoryItem: ...

  @staticmethod
  def UseAmount(sourceFullType: str, recipe: Recipe, chr: IsoGameCharacter) -> float: ...

  @staticmethod
  def getAllEvolvedRecipes() -> ArrayList[EvolvedRecipe]: ...

  @staticmethod
  def getAvailableItemsAll(recipe: Recipe, chr: IsoGameCharacter, containers: ArrayList[ItemContainer], selectedItem: InventoryItem, ignoreItems: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @staticmethod
  def getAvailableItemsNeeded(recipe: Recipe, chr: IsoGameCharacter, containers: ArrayList[ItemContainer], selectedItem: InventoryItem, ignoreItems: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @staticmethod
  def getDismantleRecipeFor(item: str) -> Recipe: ...

  @staticmethod
  def getEvolvedRecipe(baseItem: InventoryItem, chr: IsoGameCharacter, containers: ArrayList[ItemContainer], need1ingredient: bool) -> ArrayList[EvolvedRecipe]: ...

  @staticmethod
  def getKnownRecipesNumber(chr: IsoGameCharacter) -> int: ...

  @staticmethod
  def getNumberOfTimesRecipeCanBeDone(recipe: Recipe, chr: IsoGameCharacter, containers: ArrayList[ItemContainer], selectedItem: InventoryItem) -> int: ...

  @staticmethod
  def getSourceItemsAll(recipe: Recipe, sourceIndex: int, chr: IsoGameCharacter, containers: ArrayList[ItemContainer], selectedItem: InventoryItem, ignoreItems: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @staticmethod
  def getSourceItemsNeeded(recipe: Recipe, sourceIndex: int, chr: IsoGameCharacter, containers: ArrayList[ItemContainer], selectedItem: InventoryItem, ignoreItems: ArrayList[InventoryItem]) -> ArrayList[InventoryItem]: ...

  @staticmethod
  def getUniqueRecipeItems(item: InventoryItem, chr: IsoGameCharacter, containers: ArrayList[ItemContainer]) -> ArrayList[Recipe]: ...

  @staticmethod
  def hasHeat(recipe: Recipe, item: InventoryItem, containers: ArrayList[ItemContainer], chr: IsoGameCharacter) -> bool: ...

  @staticmethod
  def isAllItemsUsableRotten(arg0: Recipe, arg1: IsoGameCharacter, arg2: InventoryItem, arg3: ArrayList[ItemContainer]) -> bool: ...

  def __init__(self): ...

  class SourceItems:

    def getItems(self) -> ArrayList[InventoryItem]: ...

  class RMRecipe: ...

  class RMRecipeItemList:

    class Type(Enum):

      DESTROY: RecipeManager.RMRecipeItemList.Type

      DRAINABLE: RecipeManager.RMRecipeItemList.Type

      FOOD: RecipeManager.RMRecipeItemList.Type

      NONE: RecipeManager.RMRecipeItemList.Type

      OTHER: RecipeManager.RMRecipeItemList.Type

      WATER: RecipeManager.RMRecipeItemList.Type

      @staticmethod
      def valueOf(arg0: str) -> RecipeManager.RMRecipeItemList.Type: ...

      @staticmethod
      def values() -> list[RecipeManager.RMRecipeItemList.Type]: ...

  class RMRecipeItem: ...

  class RMRecipeSource: ...

