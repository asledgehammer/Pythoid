from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from astar import AStar, ASearchNode, ISearchNode
from gnu.trove.list.array import TFloatArrayList
from java.lang import ThreadLocal, Boolean, Enum, Integer, Thread, Byte
from java.nio import ByteBuffer
from java.util import HashMap, BitSet, ArrayList, List, Comparator
from java.util.function import Function, ToDoubleFunction, ToIntFunction, ToLongFunction
from org.joml import Vector3f, Matrix4f, Quaternionf, Vector2f, Vector4f
from org.junit import Assert
from org.junit.rules import TestRule
from se.krka.kahlua.converter import KahluaConverterManager
from se.krka.kahlua.integration import LuaCaller
from se.krka.kahlua.j2se import J2SEPlatform
from se.krka.kahlua.vm import KahluaTable, KahluaThread
from zombie.ai import State, WalkingOnTheSpot
from zombie.ai.astar import Mover, IPathfinder
from zombie.audio import BaseSoundEmitter, FMODParameterList, GameSoundClip
from zombie.characters import IsoGameCharacter, IsoPlayer, IsoZombie
from zombie.chat import ChatElement
from zombie.core.opengl import Shader
from zombie.core.physics import CarController, Transform
from zombie.core.raknet import UdpConnection
from zombie.core.skinnedmodel import ModelCamera
from zombie.core.skinnedmodel.advancedanimation import AnimEvent
from zombie.core.skinnedmodel.animation import AnimationPlayer, AnimationTrack
from zombie.core.skinnedmodel.model import VehicleSubModelInstance
from zombie.core.textures import Texture, ColorInfo, TextureDraw
from zombie.core.utils import UpdateLimit
from zombie.gameStates import GameState, GameStateMachine
from zombie.inventory import InventoryItem, ItemContainer
from zombie.inventory.types import HandWeapon
from zombie.iso import IsoMovingObject, IsoObject, IsoGridSquare, Vector2, IsoLightSource, IsoCell, IsoChunk, IsoMetaGrid
from zombie.iso.objects import IsoDeadBody
from zombie.iso.objects.interfaces import Thumpable
from zombie.network import PacketTypes
from zombie.popman import ObjectPool, ZombiePopulationRenderer
from zombie.radio.devices import DeviceData
from zombie.scripting.objects import VehicleScript, ModelScript, BaseScriptObject
from zombie.ui import UIElement
from zombie.util import PooledObject

U = TypeVar('U', default=Any)
T = TypeVar('T', default=Any)
T1 = TypeVar('T1', default=Any)
T2 = TypeVar('T2', default=Any)
E = TypeVar('E', default=Any)

class AttackVehicleState(State):

  def animEvent(self, owner: IsoGameCharacter, event: AnimEvent) -> None: ...

  def enter(self, owner: IsoGameCharacter) -> None: ...

  def execute(self, owner: IsoGameCharacter) -> None: ...

  def exit(self, owner: IsoGameCharacter) -> None: ...

  def isAttacking(self, owner: IsoGameCharacter) -> bool: ...

  def isPassengerExposed(self, owner: IsoGameCharacter) -> bool: ...

  @staticmethod
  def instance() -> AttackVehicleState: ...

  def __init__(self): ...


class BaseVehicle(IsoMovingObject):

  CENTER_OF_MASS_MAGIC: float

  FADE_DISTANCE: int

  MASK1_DOOR_LEFT_FRONT: int

  MASK1_DOOR_LEFT_REAR: int

  MASK1_DOOR_RIGHT_FRONT: int

  MASK1_DOOR_RIGHT_REAR: int

  MASK1_FRONT: int

  MASK1_GUARD_LEFT_FRONT: int

  MASK1_GUARD_LEFT_REAR: int

  MASK1_GUARD_RIGHT_FRONT: int

  MASK1_GUARD_RIGHT_REAR: int

  MASK1_REAR: int

  MASK1_WINDOW_FRONT: int

  MASK1_WINDOW_LEFT_FRONT: int

  MASK1_WINDOW_LEFT_REAR: int

  MASK1_WINDOW_REAR: int

  MASK1_WINDOW_RIGHT_FRONT: int

  MASK1_WINDOW_RIGHT_REAR: int

  MASK2_BOOT: int

  MASK2_BRAKE_LEFT: int

  MASK2_BRAKE_RIGHT: int

  MASK2_HOOD: int

  MASK2_LIGHT_LEFT_FRONT: int

  MASK2_LIGHT_LEFT_REAR: int

  MASK2_LIGHT_RIGHT_FRONT: int

  MASK2_LIGHT_RIGHT_REAR: int

  MASK2_LIGHTBAR_LEFT: int

  MASK2_LIGHTBAR_RIGHT: int

  MASK2_ROOF: int

  MAX_WHEELS: int

  noAuthorization: int

  PHYSICS_PARAM_COUNT: int

  PHYSICS_Z_SCALE: float

  PLUS_RADIUS: float

  RADIUS: float

  RANDOMIZE_CONTAINER_CHANCE: int

  RENDER_TO_TEXTURE: bool

  TL_matrix4f_pool: ThreadLocal[BaseVehicle.Matrix4fObjectPool]

  TL_quaternionf_pool: ThreadLocal[BaseVehicle.QuaternionfObjectPool]

  TL_vector2_pool: ThreadLocal[BaseVehicle.Vector2ObjectPool]

  TL_vector2f_pool: ThreadLocal[BaseVehicle.Vector2fObjectPool]

  TL_vector3f_pool: ThreadLocal[BaseVehicle.Vector3fObjectPool]

  vehicleShadow: Texture

  YURI_FORCE_FIELD: bool

  def ApplyImpulse(self, obj: IsoObject, mul: float) -> None: ...

  def ApplyImpulse4Break(self, obj: IsoObject, mul: float) -> None: ...

  def Damage(self, amount: float) -> None: ...

  def HitByVehicle(self, vehicle: BaseVehicle, amount: float) -> None: ...

  def Serialize(self) -> bool: ...

  @overload
  def Thump(self, thumper: IsoMovingObject) -> None: ...

  @overload
  def Thump(self, thumper: IsoMovingObject) -> None: ...

  @overload
  def WeaponHit(self, chr: IsoGameCharacter, weapon: HandWeapon) -> None: ...

  @overload
  def WeaponHit(self, chr: IsoGameCharacter, weapon: HandWeapon) -> None: ...

  def addDamageFrontHitAChr(self, dmg: int) -> None: ...

  def addDamageRearHitAChr(self, dmg: int) -> None: ...

  def addImpulse(self, impulse: Vector3f, rel_pos: Vector3f) -> None: ...

  def addKeyToGloveBox(self) -> None: ...

  def addKeyToSquare(self, sq: IsoGridSquare) -> bool: ...

  def addKeyToWorld(self) -> None: ...

  @overload
  def addPointConstraint(self, player: IsoPlayer, vehicleB: BaseVehicle, attachmentA: str, attachmentB: str) -> None: ...

  @overload
  def addPointConstraint(self, player: IsoPlayer, vehicleB: BaseVehicle, attachmentA: str, attachmentB: str, remote: Boolean) -> None: ...

  def addRandomDamageFromCrash(self, chr: IsoGameCharacter, damage: float) -> None: ...

  def addToWorld(self) -> None: ...

  def areAllDoorsLocked(self) -> bool: ...

  @overload
  def areaPositionWorld(self, area: VehicleScript.Area) -> Vector2: ...

  @overload
  def areaPositionWorld(self, area: VehicleScript.Area, out: Vector2) -> Vector2: ...

  @overload
  def areaPositionWorld4PlayerInteract(self, area: VehicleScript.Area) -> Vector2: ...

  @overload
  def areaPositionWorld4PlayerInteract(self, area: VehicleScript.Area, out: Vector2) -> Vector2: ...

  def attachmentExist(self, attachmentName: str) -> bool: ...

  def authorizationChanged(self, character: IsoGameCharacter) -> None: ...

  def authorizationClientCollide(self, driver: IsoPlayer) -> None: ...

  def authorizationServerCollide(self, PlayerID: int, isCollide: bool) -> None: ...

  def authorizationServerOnSeat(self, player: IsoPlayer, enter: bool) -> None: ...

  def blocked(self, x: int, y: int, z: int) -> bool: ...

  def breakConstraint(self, forgetID: bool, remote: bool) -> None: ...

  def brekingObjects(self) -> None: ...

  def calculateDamageWithCharacter(self, chr: IsoGameCharacter) -> int: ...

  def canAccessContainer(self, partIndex: int, chr: IsoGameCharacter) -> bool: ...

  @overload
  def canAttachTrailer(self, vehicleB: BaseVehicle, attachmentA: str, attachmentB: str) -> bool: ...

  @overload
  def canAttachTrailer(self, vehicleB: BaseVehicle, attachmentA: str, attachmentB: str, reconnect: bool) -> bool: ...

  def canInstallPart(self, chr: IsoGameCharacter, part: VehiclePart) -> bool: ...

  def canLockDoor(self, part: VehiclePart, chr: IsoGameCharacter) -> bool: ...

  def canSwitchSeat(self, seatFrom: int, seatTo: int) -> bool: ...

  def canUninstallPart(self, chr: IsoGameCharacter, part: VehiclePart) -> bool: ...

  def canUnlockDoor(self, part: VehiclePart, chr: IsoGameCharacter) -> bool: ...

  def changeTransmission(self, newTransmission: TransmissionNumber) -> None: ...

  def cheatHotwire(self, hotwired: bool, broken: bool) -> None: ...

  def checkCollision(self, target: IsoGameCharacter) -> BaseVehicle.HitVars: ...

  def checkPhysicsValidWithServer(self) -> None: ...

  def chooseBestAttackPosition(self, target: IsoGameCharacter, attacker: IsoGameCharacter, worldPos: Vector3f) -> Vector3f: ...

  def circleIntersects(self, x: float, y: float, z: float, radius: float) -> bool: ...

  def clearPassenger(self, seat: int) -> bool: ...

  def constraintChanged(self) -> None: ...

  def couldCrawlerAttackPassenger(self, chr: IsoGameCharacter) -> bool: ...

  def crash(self, delta: float, front: bool) -> None: ...

  def createPhysics(self) -> None: ...

  def createVehicleKey(self) -> InventoryItem: ...

  def damageObjects(self, damage: float) -> None: ...

  def damagePlayers(self, damage: float) -> None: ...

  def doBloodOverlay(self) -> None: ...

  def doChrHitImpulse(self, chr: IsoObject) -> None: ...

  def doDamageOverlay(self) -> None: ...

  def drainBatteryUpdateHack(self) -> None: ...

  def drawDirectionLine(self, dir: Vector2, length: float, r: float, g: float, b: float) -> None: ...

  def engineDoIdle(self) -> None: ...

  def engineDoRetryingStarting(self) -> None: ...

  def engineDoRunning(self) -> None: ...

  def engineDoShuttingDown(self) -> None: ...

  def engineDoStalling(self) -> None: ...

  def engineDoStarting(self) -> None: ...

  def engineDoStartingFailed(self) -> None: ...

  def engineDoStartingFailedNoPower(self) -> None: ...

  def engineDoStartingSuccess(self) -> None: ...

  @overload
  def enter(self, seat: int, chr: IsoGameCharacter) -> bool: ...

  @overload
  def enter(self, seat: int, chr: IsoGameCharacter, offset: Vector3f) -> bool: ...

  def enterRSync(self, seat: int, chr: IsoGameCharacter, v: BaseVehicle) -> bool: ...

  def exit(self, chr: IsoGameCharacter) -> bool: ...

  def exitRSync(self, chr: IsoGameCharacter) -> bool: ...

  def fixLightbarModelLighting(self, ls: IsoLightSource, lightPos: Vector3f) -> None: ...

  def flipUpright(self) -> None: ...

  def getAngleX(self) -> float: ...

  def getAngleY(self) -> float: ...

  def getAngleZ(self) -> float: ...

  def getAnimationPlayer(self) -> AnimationPlayer: ...

  @overload
  def getAreaCenter(self, areaId: str) -> Vector2: ...

  @overload
  def getAreaCenter(self, areaId: str, out: Vector2) -> Vector2: ...

  def getAreaDist(self, areaId: str, chr: IsoGameCharacter) -> float: ...

  def getAttachmentLocalPos(self, attachmentName: str, v: Vector3f) -> Vector3f: ...

  def getAttachmentWorldPos(self, attachmentName: str, v: Vector3f) -> Vector3f: ...

  def getAuthorizationDescription(self) -> str: ...

  def getBaseQuality(self) -> float: ...

  def getBattery(self) -> VehiclePart: ...

  def getBatteryCharge(self) -> float: ...

  def getBestSeat(self, chr: IsoGameCharacter) -> int: ...

  def getBloodIntensity(self, id: str) -> float: ...

  def getBrakeSpeedBetweenUpdate(self) -> float: ...

  def getBrakingForce(self) -> float: ...

  def getCharacter(self, seat: int) -> IsoGameCharacter: ...

  def getChoosenParts(self) -> HashMap[str, str]: ...

  def getClientForce(self) -> float: ...

  def getClosestWindow(self, chr: IsoGameCharacter) -> VehiclePart: ...

  def getColorHue(self) -> float: ...

  def getColorSaturation(self) -> float: ...

  def getColorValue(self) -> float: ...

  def getController(self) -> CarController: ...

  def getCurrentKey(self) -> InventoryItem: ...

  def getCurrentSpeedForRegulator(self) -> float: ...

  def getCurrentSpeedKmHour(self) -> float: ...

  def getCurrentSteering(self) -> float: ...

  def getDebugZ(self) -> float: ...

  def getDriver(self) -> IsoGameCharacter: ...

  def getEmitter(self) -> BaseSoundEmitter: ...

  def getEngineLoudness(self) -> int: ...

  def getEnginePower(self) -> int: ...

  def getEngineQuality(self) -> int: ...

  def getEngineSpeed(self) -> float: ...

  @overload
  def getFMODParameters(self) -> FMODParameterList: ...

  @overload
  def getFMODParameters(self) -> FMODParameterList: ...

  def getFacingPosition(self, chr: IsoGameCharacter, out: Vector2) -> None: ...

  def getForce(self) -> float: ...

  def getForwardVector(self, out: Vector3f) -> Vector3f: ...

  def getFudgedMass(self) -> float: ...

  def getHeadlightCanEmmitLight(self) -> bool: ...

  def getHeadlightsOn(self) -> bool: ...

  def getHeater(self) -> VehiclePart: ...

  def getId(self) -> int: ...

  def getInitialMass(self) -> float: ...

  def getInsideTemperature(self) -> float: ...

  def getJoypad(self) -> int: ...

  def getKeyId(self) -> int: ...

  def getKeySpawned(self) -> bool: ...

  def getLightByIndex(self, index: int) -> VehiclePart: ...

  def getLightCount(self) -> int: ...

  def getLightbarLightsMode(self) -> int: ...

  def getLightbarSirenMode(self) -> int: ...

  def getLinearVelocity(self, out: Vector3f) -> Vector3f: ...

  @overload
  def getLocalPos(self, worldPos: Vector3f, localPos: Vector3f) -> Vector3f: ...

  @overload
  def getLocalPos(self, worldX: float, worldY: float, worldZ: float, localPos: Vector3f) -> Vector3f: ...

  def getMass(self) -> float: ...

  def getMaxPassengers(self) -> int: ...

  def getMaxSpeed(self) -> float: ...

  def getMechanicalID(self) -> int: ...

  def getMinMaxPosition(self) -> BaseVehicle.MinMaxPosition: ...

  def getNearestBodyworkPart(self, chr: IsoGameCharacter) -> VehiclePart: ...

  def getNetPlayerId(self) -> int: ...

  def getNumberOfPartsWithContainers(self) -> int: ...

  def getObjectName(self) -> str: ...

  def getOffroadEfficiency(self) -> float: ...

  def getPartById(self, id: str) -> VehiclePart: ...

  def getPartByIndex(self, index: int) -> VehiclePart: ...

  def getPartCount(self) -> int: ...

  def getPartForSeatContainer(self, seat: int) -> VehiclePart: ...

  def getPassenger(self, seat: int) -> BaseVehicle.Passenger: ...

  def getPassengerAnim(self, seat: int, id: str) -> VehicleScript.Anim: ...

  def getPassengerArea(self, seat: int) -> str: ...

  def getPassengerDoor(self, seat: int) -> VehiclePart: ...

  def getPassengerDoor2(self, seat: int) -> VehiclePart: ...

  def getPassengerLocalPos(self, seat: int, v: Vector3f) -> Vector3f: ...

  def getPassengerPosition(self, seat: int, id: str) -> VehicleScript.Position: ...

  @overload
  def getPassengerPositionWorldPos(self, posn: VehicleScript.Position, out: Vector3f) -> Vector3f: ...

  @overload
  def getPassengerPositionWorldPos(self, x: float, y: float, z: float, out: Vector3f) -> Vector3f: ...

  def getPassengerSwitchSeat(self, seat: int, index: int) -> VehicleScript.Passenger.SwitchSeat: ...

  def getPassengerSwitchSeatCount(self, seat: int) -> int: ...

  def getPassengerWorldPos(self, seat: int, out: Vector3f) -> Vector3f: ...

  def getPlayerTrailerLocalPos(self, attachmentName: str, left: bool, v: Vector3f) -> Vector3f: ...

  def getPlayerTrailerWorldPos(self, attachmentName: str, left: bool, v: Vector3f) -> Vector3f: ...

  def getPoly(self) -> PolygonalMap2.VehiclePoly: ...

  def getPolyPlusRadius(self) -> PolygonalMap2.VehiclePoly: ...

  def getRegulatorSpeed(self) -> float: ...

  def getRemainingFuelPercentage(self) -> float: ...

  def getRust(self) -> float: ...

  def getScript(self) -> VehicleScript: ...

  def getScriptName(self) -> str: ...

  def getSeat(self, chr: IsoGameCharacter) -> int: ...

  def getShadowTexture(self) -> Texture: ...

  def getSirenStartTime(self) -> float: ...

  def getSkin(self) -> str: ...

  def getSkinCount(self) -> int: ...

  def getSkinIndex(self) -> int: ...

  def getSpeed2D(self) -> float: ...

  def getSqlId(self) -> int: ...

  def getSquare(self) -> IsoGridSquare: ...

  def getStoplightsOn(self) -> bool: ...

  def getSurroundVehicle(self) -> SurroundVehicle: ...

  def getSwitchSeatAnimName(self, seatFrom: int, seatTo: int) -> str: ...

  def getSwitchSeatAnimRate(self, seatFrom: int, seatTo: int) -> float: ...

  def getSwitchSeatSound(self, seatFrom: int, seatTo: int) -> str: ...

  @overload
  def getThumpCondition(self) -> float: ...

  @overload
  def getThumpCondition(self) -> float: ...

  @overload
  def getThumpableFor(self, chr: IsoGameCharacter) -> Thumpable: ...

  @overload
  def getThumpableFor(self, chr: IsoGameCharacter) -> Thumpable: ...

  def getTowAttachmentOther(self) -> str: ...

  def getTowAttachmentSelf(self) -> str: ...

  def getTowedByLocalPos(self, attachmentName: str, v: Vector3f) -> Vector3f: ...

  def getTowedByWorldPos(self, attachmentName: str, v: Vector3f) -> Vector3f: ...

  def getTowingLocalPos(self, attachmentName: str, v: Vector3f) -> Vector3f: ...

  def getTowingWorldPos(self, attachmentName: str, v: Vector3f) -> Vector3f: ...

  def getTransmissionNumber(self) -> int: ...

  def getTransmissionNumberLetter(self) -> str: ...

  def getUpVector(self, out: Vector3f) -> Vector3f: ...

  def getUpVectorDot(self) -> float: ...

  @overload
  def getUseablePart(self, chr: IsoGameCharacter) -> VehiclePart: ...

  @overload
  def getUseablePart(self, chr: IsoGameCharacter, checkDir: bool) -> VehiclePart: ...

  def getVehicleEngineRPM(self) -> VehicleEngineRPM: ...

  def getVehicleTowedBy(self) -> BaseVehicle: ...

  def getVehicleTowing(self) -> BaseVehicle: ...

  def getVehicleType(self) -> str: ...

  def getWheelForwardVector(self, wheelIndex: int, out: Vector3f) -> None: ...

  def getWindowLightsOn(self) -> bool: ...

  @overload
  def getWorldPos(self, localPos: Vector3f, worldPos: Vector3f) -> Vector3f: ...

  @overload
  def getWorldPos(self, localPos: Vector3f, worldPos: Vector3f, script: VehicleScript) -> Vector3f: ...

  @overload
  def getWorldPos(self, localX: float, localY: float, localZ: float, worldPos: Vector3f) -> Vector3f: ...

  @overload
  def getWorldPos(self, localX: float, localY: float, localZ: float, worldPos: Vector3f, script: VehicleScript) -> Vector3f: ...

  def getWorldTransform(self, out: Transform) -> Transform: ...

  def getZone(self) -> str: ...

  def hasAuthorization(self, connection: UdpConnection) -> bool: ...

  def hasBackSignal(self) -> bool: ...

  def hasHeadlights(self) -> bool: ...

  def hasHorn(self) -> bool: ...

  def hasLightbar(self) -> bool: ...

  def hasRoof(self, seat: int) -> bool: ...

  def haveOneDoorUnlocked(self) -> bool: ...

  @overload
  def hitCharacter(self, chr: IsoZombie) -> None: ...

  @overload
  def hitCharacter(self, character: IsoGameCharacter, vars: BaseVehicle.HitVars) -> None: ...

  def hitVehicle(self, attacker: IsoGameCharacter, weapon: HandWeapon) -> None: ...

  def isAlarmed(self) -> bool: ...

  def isAnyDoorLocked(self) -> bool: ...

  def isAnyListenerInside(self) -> bool: ...

  def isAtRest(self) -> bool: ...

  def isBackSignalEmitting(self) -> bool: ...

  def isBraking(self) -> bool: ...

  def isCharacterAdjacentTo(self, chr: IsoGameCharacter) -> bool: ...

  def isCollided(self, character: IsoGameCharacter) -> bool: ...

  def isDestroyed(self) -> bool: ...

  def isDoColor(self) -> bool: ...

  def isDoingOffroad(self) -> bool: ...

  def isDriveable(self) -> bool: ...

  def isDriver(self, chr: IsoGameCharacter) -> bool: ...

  def isEngineRunning(self) -> bool: ...

  def isEngineStarted(self) -> bool: ...

  def isEngineWorking(self) -> bool: ...

  def isEnterBlocked(self, chr: IsoGameCharacter, seat: int) -> bool: ...

  def isEnterBlocked2(self, chr: IsoGameCharacter, seat: int) -> bool: ...

  @overload
  def isExitBlocked(self, seat: int) -> bool: ...

  @overload
  def isExitBlocked(self, chr: IsoGameCharacter, seat: int) -> bool: ...

  def isExitBlocked2(self, seat: int) -> bool: ...

  def isGoodCar(self) -> bool: ...

  def isHotwired(self) -> bool: ...

  def isHotwiredBroken(self) -> bool: ...

  def isInArea(self, areaId: str, chr: IsoGameCharacter) -> bool: ...

  def isInBounds(self, worldX: float, worldY: float) -> bool: ...

  def isInForest(self) -> bool: ...

  def isIntersectingSquare(self, x: int, y: int, z: int) -> bool: ...

  def isIntersectingSquareWithShadow(self, x: int, y: int, z: int) -> bool: ...

  def isInvalidChunkAhead(self) -> bool: ...

  @overload
  def isInvalidChunkAround(self) -> bool: ...

  @overload
  def isInvalidChunkAround(self, moveW: bool, moveE: bool, moveN: bool, moveS: bool) -> bool: ...

  def isInvalidChunkBehind(self) -> bool: ...

  def isKeyIsOnDoor(self) -> bool: ...

  def isKeyboardControlled(self) -> bool: ...

  def isKeysInIgnition(self) -> bool: ...

  def isLocalPhysicSim(self) -> bool: ...

  def isMechanicUIOpen(self) -> bool: ...

  def isNetPlayerAuthorization(self, netPlayerAuthorization: BaseVehicle.Authorization) -> bool: ...

  def isNetPlayerId(self, netPlayerId: int) -> bool: ...

  def isOperational(self) -> bool: ...

  def isPassengerUseDoor2(self, chr: IsoGameCharacter, seat: int) -> bool: ...

  def isPositionOnLeftOrRight(self, x: float, y: float) -> bool: ...

  def isPreviouslyEntered(self) -> bool: ...

  def isRegulator(self) -> bool: ...

  def isRemovedFromWorld(self) -> bool: ...

  def isSeatInstalled(self, seat: int) -> bool: ...

  def isSeatOccupied(self, seat: int) -> bool: ...

  def isStarting(self) -> bool: ...

  def isStopped(self) -> bool: ...

  def isTrunkLocked(self) -> bool: ...

  def load(self, input: ByteBuffer, WorldVersion: int, IS_DEBUG_SAVE: bool) -> None: ...

  def loadChange(self, change: str, bb: ByteBuffer) -> None: ...

  def lockServerUpdate(self, lockTimeMs: int) -> None: ...

  def needPartsUpdate(self) -> bool: ...

  def netPlayerFromServerUpdate(self, authorization: BaseVehicle.Authorization, authorizationPlayer: int) -> None: ...

  def netPlayerServerSendAuthorisation(self, bb: ByteBuffer) -> None: ...

  def onBackMoveSignalStart(self) -> None: ...

  def onBackMoveSignalStop(self) -> None: ...

  def onHornStart(self) -> None: ...

  def onHornStop(self) -> None: ...

  def permanentlyRemove(self) -> None: ...

  def playActorAnim(self, part: VehiclePart, animId: str, chr: IsoGameCharacter) -> None: ...

  def playPartAnim(self, part: VehiclePart, animId: str) -> None: ...

  def playPartSound(self, part: VehiclePart, player: IsoPlayer, animId: str) -> None: ...

  @overload
  def playPassengerAnim(self, seat: int, animId: str) -> None: ...

  @overload
  def playPassengerAnim(self, seat: int, animId: str, chr: IsoGameCharacter) -> None: ...

  def playPassengerSound(self, seat: int, animId: str) -> None: ...

  def playSound(self, sound: str) -> None: ...

  def playSoundImpl(self, file: str, parent: IsoObject) -> int: ...

  def playSwitchSeatAnim(self, seatFrom: int, seatTo: int) -> None: ...

  def positionTrailer(self, trailer: BaseVehicle) -> None: ...

  def postupdate(self) -> None: ...

  def putKeyInIgnition(self, key: InventoryItem) -> None: ...

  def putKeyOnDoor(self, key: InventoryItem) -> None: ...

  def putKeyToContainer(self, container: ItemContainer, sq: IsoGridSquare, obj: IsoObject) -> None: ...

  def putKeyToWorld(self, sq: IsoGridSquare) -> None: ...

  def putKeyToZombie(self, zombie: IsoZombie) -> None: ...

  def releaseAnimationPlayers(self) -> None: ...

  def removeFromWorld(self) -> None: ...

  def removeKeyFromDoor(self) -> None: ...

  def removeKeyFromIgnition(self) -> None: ...

  def render(self, x: float, y: float, z: float, col: ColorInfo, bDoAttached: bool, bWallLightingPass: bool, shader: Shader) -> None: ...

  def renderShadow(self) -> None: ...

  def renderlast(self) -> None: ...

  def repair(self) -> None: ...

  def resumeRunningAfterLoad(self) -> None: ...

  def save(self, output: ByteBuffer, IS_DEBUG_SAVE: bool) -> None: ...

  def saveChange(self, change: str, tbl: KahluaTable, bb: ByteBuffer) -> None: ...

  def scriptReloaded(self) -> None: ...

  def setActiveInBullet(self, active: bool) -> None: ...

  def setAddThumpWorldSound(self, add: bool) -> None: ...

  def setAlarmed(self, alarmed: bool) -> None: ...

  def setAngles(self, degreesX: float, degreesY: float, degreesZ: float) -> None: ...

  def setBaseQuality(self, baseQuality: float) -> None: ...

  def setBloodIntensity(self, id: str, intensity: float) -> None: ...

  def setBraking(self, isBraking: bool) -> None: ...

  def setBrakingForce(self, brakingForce: float) -> None: ...

  def setCharacterPosition(self, chr: IsoGameCharacter, seat: int, positionId: str) -> None: ...

  def setCharacterPositionToAnim(self, chr: IsoGameCharacter, seat: int, animId: str) -> None: ...

  def setClientForce(self, force: float) -> None: ...

  def setColor(self, value: float, saturation: float, hue: float) -> None: ...

  def setColorHSV(self, hue: float, saturation: float, value: float) -> None: ...

  def setCurrentKey(self, currentKey: InventoryItem) -> None: ...

  def setCurrentSteering(self, currentSteering: float) -> None: ...

  def setDebugZ(self, z: float) -> None: ...

  def setDoColor(self, doColor: bool) -> None: ...

  def setEngineFeature(self, quality: int, loudness: int, engineForce: int) -> None: ...

  def setForceBrake(self) -> None: ...

  def setGeneralPartCondition(self, baseQuality: float, chanceToSpawnDamaged: float) -> None: ...

  def setGoodCar(self, isGoodCar: bool) -> None: ...

  def setHeadlightsOn(self, __on__: bool) -> None: ...

  def setHotwired(self, hotwired: bool) -> None: ...

  def setHotwiredBroken(self, hotwiredBroken: bool) -> None: ...

  def setInitialMass(self, initialMass: float) -> None: ...

  def setKeyIsOnDoor(self, keyIsOnDoor: bool) -> None: ...

  def setKeysInIgnition(self, keysOnContact: bool) -> None: ...

  def setLightbarLightsMode(self, mode: int) -> None: ...

  def setLightbarSirenMode(self, mode: int) -> None: ...

  def setMass(self, mass: float) -> None: ...

  def setMaxSpeed(self, maxSpeed: float) -> None: ...

  def setMechanicUIOpen(self, mechanicUIOpen: bool) -> None: ...

  def setMechanicalID(self, mechanicalID: int) -> None: ...

  def setNeedPartsUpdate(self, needPartsUpdate: bool) -> None: ...

  def setNetPlayerAuthorization(self, netPlayerAuthorization: BaseVehicle.Authorization, netPlayerId: int) -> None: ...

  def setPassenger(self, seat: int, chr: IsoGameCharacter, offset: Vector3f) -> bool: ...

  def setPhysicsActive(self, active: bool) -> None: ...

  def setPreviouslyEntered(self, arg0: bool) -> None: ...

  def setRegulator(self, regulator: bool) -> None: ...

  def setRegulatorSpeed(self, regulatorSpeed: float) -> None: ...

  def setRust(self, rust: float) -> None: ...

  @overload
  def setScript(self) -> None: ...

  @overload
  def setScript(self, name: str) -> None: ...

  def setScriptName(self, name: str) -> None: ...

  def setSirenStartTime(self, worldAgeHours: float) -> None: ...

  def setSkinIndex(self, index: int) -> None: ...

  @overload
  def setSmashed(self, location: str) -> BaseVehicle: ...

  @overload
  def setSmashed(self, location: str, flipped: bool) -> BaseVehicle: ...

  def setStoplightsOn(self, __on__: bool) -> None: ...

  def setTireInflation(self, wheelIndex: int, inflation: float) -> None: ...

  def setTireRemoved(self, wheelIndex: int, removed: bool) -> None: ...

  def setTrunkLocked(self, locked: bool) -> None: ...

  def setVehicleTowedBy(self, vehicleA: BaseVehicle, attachmentA: str, attachmentB: str) -> None: ...

  def setVehicleTowing(self, vehicleB: BaseVehicle, attachmentA: str, attachmentB: str) -> None: ...

  def setVehicleType(self, type: str) -> None: ...

  def setWindowLightsOn(self, __on__: bool) -> None: ...

  def setWorldTransform(self, __in__: Transform) -> None: ...

  def setZone(self, name: str) -> None: ...

  def shouldCollideWithCharacters(self) -> bool: ...

  def shouldCollideWithObjects(self) -> bool: ...

  @overload
  def showPassenger(self, seat: int) -> bool: ...

  @overload
  def showPassenger(self, chr: IsoGameCharacter) -> bool: ...

  def shutOff(self) -> None: ...

  def sirenShutoffTimeExpired(self) -> bool: ...

  def softReset(self) -> None: ...

  @overload
  def startEvent(self, eventInstance: int, clip: GameSoundClip, parameterSet: BitSet) -> None: ...

  @overload
  def startEvent(self, eventInstance: int, clip: GameSoundClip, parameterSet: BitSet) -> None: ...

  @overload
  def stopEvent(self, eventInstance: int, clip: GameSoundClip, parameterSet: BitSet) -> None: ...

  @overload
  def stopEvent(self, eventInstance: int, clip: GameSoundClip, parameterSet: BitSet) -> None: ...

  def stopSound(self, channel: int) -> int: ...

  def switchSeat(self, chr: IsoGameCharacter, seatTo: int) -> None: ...

  def syncKeyInIgnition(self, inIgnition: bool, onDoor: bool, key: InventoryItem) -> None: ...

  def testCollisionWithCharacter(self, chr: IsoGameCharacter, circleRadius: float, out: Vector2) -> Vector2: ...

  def testCollisionWithCorpse(self, body: IsoDeadBody, doSound: bool) -> int: ...

  def testCollisionWithObject(self, obj: IsoObject, circleRadius: float, out: Vector2) -> Vector2: ...

  @overload
  def testCollisionWithProneCharacter(self, chr: IsoGameCharacter, doSound: bool) -> int: ...

  @overload
  def testCollisionWithProneCharacter(self, chr: IsoMovingObject, angleX: float, angleY: float, doSound: bool) -> int: ...

  def testCollisionWithVehicle(self, obj: BaseVehicle) -> bool: ...

  def toggleLockedDoor(self, part: VehiclePart, chr: IsoGameCharacter, locked: bool) -> None: ...

  def transmitBlood(self) -> None: ...

  def transmitCharacterPosition(self, seat: int, positionId: str) -> None: ...

  def transmitColorHSV(self) -> None: ...

  def transmitEngine(self) -> None: ...

  def transmitPartCondition(self, part: VehiclePart) -> None: ...

  def transmitPartDoor(self, part: VehiclePart) -> None: ...

  def transmitPartItem(self, part: VehiclePart) -> None: ...

  def transmitPartModData(self, part: VehiclePart) -> None: ...

  def transmitPartUsedDelta(self, part: VehiclePart) -> None: ...

  def transmitPartWindow(self, part: VehiclePart) -> None: ...

  def transmitRust(self) -> None: ...

  def transmitSkinIndex(self) -> None: ...

  def triggerAlarm(self) -> None: ...

  def tryHotwire(self, electricityLevel: int) -> None: ...

  def trySpawnKey(self) -> None: ...

  @overload
  def tryStartEngine(self) -> None: ...

  @overload
  def tryStartEngine(self, haveKey: bool) -> None: ...

  def update(self) -> None: ...

  def updateBulletStats(self) -> None: ...

  def updateControls(self) -> None: ...

  @overload
  def updateEvent(self, eventInstance: int, clip: GameSoundClip) -> None: ...

  @overload
  def updateEvent(self, eventInstance: int, clip: GameSoundClip) -> None: ...

  def updateHasExtendOffset(self, chr: IsoGameCharacter) -> None: ...

  def updateHasExtendOffsetForExit(self, chr: IsoGameCharacter) -> None: ...

  def updateHasExtendOffsetForExitEnd(self, chr: IsoGameCharacter) -> None: ...

  def updateHitByVehicle(self, target: IsoGameCharacter) -> bool: ...

  def updateLights(self) -> None: ...

  def updatePartStats(self) -> None: ...

  def updateParts(self) -> None: ...

  def updatePhysics(self) -> None: ...

  def updatePhysicsNetwork(self) -> None: ...

  def updateSkin(self) -> None: ...

  def updateSounds(self) -> None: ...

  def updateTotalMass(self) -> None: ...

  def windowsOpen(self) -> int: ...

  @staticmethod
  def LoadAllVehicleTextures() -> None: ...

  @staticmethod
  @overload
  def LoadVehicleTexture(name: str) -> Texture: ...

  @staticmethod
  @overload
  def LoadVehicleTexture(name: str, flags: int) -> Texture: ...

  @staticmethod
  def LoadVehicleTextures(script: VehicleScript) -> None: ...

  @staticmethod
  def allocVector2() -> Vector2: ...

  @staticmethod
  def allocVector3f() -> Vector3f: ...

  @staticmethod
  def getFakeSpeedModifier() -> float: ...

  @staticmethod
  def releaseVector2(v: Vector2) -> None: ...

  @staticmethod
  def releaseVector3f(vector3f: Vector3f) -> None: ...

  def __init__(self, cell: IsoCell):
    self.addedtoworld: bool
    self.authsimulationhash: int
    self.authsimulationtime: int
    self.chunk: IsoChunk
    self.collidex: float
    self.collidey: float
    self.colorhue: float
    self.colorsaturation: float
    self.colorvalue: float
    self.connectionstate: list[BaseVehicle.ServerVehicleState]
    self.constrainttowing: int
    self.currentfrontenddurability: int
    self.currentrearenddurability: int
    self.enginelastupdatestatetime: int
    self.enginesoundindex: int
    self.enginespeed: float
    self.enginestate: BaseVehicle.engineStateTypes
    self.forcedfriction: float
    self.frontenddurability: int
    self.hasextendoffset: bool
    self.hasextendoffsetexiting: bool
    self.headlightson: bool
    self.hornemitter: BaseSoundEmitter
    self.interpolation: VehicleInterpolation
    self.isactive: bool
    self.isreliable: bool
    self.isstatic: bool
    self.jniiscollide: bool
    self.jnilinearvelocity: Vector3f
    self.jnispeed: float
    self.jnitransform: Transform
    self.justbreakconstrainttimer: int
    self.keyspawned: int
    self.lightbarlightsmode: LightbarLightsMode
    self.lightbarsirenmode: LightbarSirenMode
    self.models: ArrayList[BaseVehicle.ModelInfo]
    self.netplayerauthorization: BaseVehicle.Authorization
    self.netplayerid: int
    self.netplayertimeout: int
    self.new_enginesoundid: list[int]
    self.physicactivecheck: int
    self.polydirty: bool
    self.previouslyentered: bool
    self.ramsound: int
    self.ramsoundtime: int
    self.rearenddurability: int
    self.rendertransform: Matrix4f
    self.rust: float
    self.savedphysicsz: float
    self.savedrot: Quaternionf
    self.serverremovedfromworld: bool
    self.shadowcoord: PolygonalMap2.VehiclePoly
    self.skidding: bool
    self.skidsound: int
    self.soundbackmoveon: bool
    self.soundhornon: bool
    self.soundsirensignal: int
    self.specificdistributionid: str
    self.sqlid: int
    self.starttime: float
    self.stoplightson: bool
    self.throttle: float
    self.transmissionchangetime: UpdateLimit
    self.transmissionnumber: TransmissionNumber
    self.vehicleid: int
    self.vehicletransform: Matrix4f
    self.waitfullupdate: bool
    self.wastowedby: BaseVehicle
    self.wheelinfo: list[BaseVehicle.WheelInfo]
    self.windowlightson: bool

  class UpdateFlags:

    AllPartFlags: int

    Authorization: int

    Engine: int

    Full: int

    Lights: int

    PartCondition: int

    PartDoor: int

    PartItem: int

    PartModData: int

    PartModels: int

    PartUsedDelta: int

    PartWindow: int

    PositionOrientation: int

    Sounds: int

    UpdateCarProperties: int

  class Vector2ObjectPool(ObjectPool): ...

  class Vector3fObjectPool(ObjectPool): ...

  class VehicleImpulse: ...

  class Authorization(Enum):

    Local: BaseVehicle.Authorization

    LocalCollide: BaseVehicle.Authorization

    Remote: BaseVehicle.Authorization

    RemoteCollide: BaseVehicle.Authorization

    Server: BaseVehicle.Authorization

    def index(self) -> int: ...

    @staticmethod
    @overload
    def valueOf(arg0: int) -> BaseVehicle.Authorization: ...

    @staticmethod
    @overload
    def valueOf(arg0: str) -> BaseVehicle.Authorization: ...

    @staticmethod
    def values() -> list[BaseVehicle.Authorization]: ...

  class engineStateTypes(Enum):

    Idle: BaseVehicle.engineStateTypes

    RetryingStarting: BaseVehicle.engineStateTypes

    Running: BaseVehicle.engineStateTypes

    ShutingDown: BaseVehicle.engineStateTypes

    Stalling: BaseVehicle.engineStateTypes

    Starting: BaseVehicle.engineStateTypes

    StartingFailed: BaseVehicle.engineStateTypes

    StartingFailedNoPower: BaseVehicle.engineStateTypes

    StartingSuccess: BaseVehicle.engineStateTypes

    @staticmethod
    def valueOf(arg0: str) -> BaseVehicle.engineStateTypes: ...

    @staticmethod
    def values() -> list[BaseVehicle.engineStateTypes]: ...

  class WheelInfo:

    def __init__(self):
      self.rotation: float
      self.skidinfo: float
      self.steering: float
      self.suspensionlength: float

  class ServerVehicleState:

    def setAuthorization(self, vehicle: BaseVehicle) -> None: ...

    def shouldSend(self, vehicle: BaseVehicle) -> bool: ...

    def __init__(self):
      self.flags: int
      self.netplayerauthorization: BaseVehicle.Authorization
      self.netplayerid: int
      self.orient: Quaternionf
      self.x: float
      self.y: float
      self.z: float

  class Passenger:

    def __init__(self):
      self.character: IsoGameCharacter

  class HitVars:

    def calc(self, target: IsoGameCharacter, vehicle: BaseVehicle) -> None: ...

    def __init__(self):
      self.hitspeed: float
      self.istargethitfrombehind: bool
      self.isvehiclehitfromfront: bool
      self.targetimpulse: Vector3f
      self.vehicledamage: int

  class ModelInfo:

    def getAnimationPlayer(self) -> AnimationPlayer: ...

    def releaseAnimationPlayer(self) -> None: ...

    def __init__(self):
      self.m_animplayer: AnimationPlayer
      self.m_track: AnimationTrack
      self.modelinstance: VehicleSubModelInstance
      self.modelscript: ModelScript
      self.part: VehiclePart
      self.rendertransform: Matrix4f
      self.scriptmodel: VehicleScript.Model
      self.wheelindex: int

  class Matrix4fObjectPool(ObjectPool): ...

  class QuaternionfObjectPool(ObjectPool): ...

  class L_testCollisionWithVehicle: ...

  class Vector2fObjectPool(ObjectPool): ...

  class MinMaxPosition:

    def __init__(self):
      self.maxx: float
      self.maxy: float
      self.minx: float
      self.miny: float


class CircleLineIntersect:

  @staticmethod
  def TEST(vec: Vector3f, x: float, y: float, w: float, h: float, controller: CarController) -> bool: ...

  @staticmethod
  @overload
  def checkforcecirclescollide(forceCircle: List[CircleLineIntersect.ForceCircle], lines: ArrayList[CircleLineIntersect.StaticLine]) -> CircleLineIntersect.Collideresult: ...

  @staticmethod
  @overload
  def checkforcecirclescollide(forceCircle2: List[CircleLineIntersect.ForceCircle], lines: ArrayList[CircleLineIntersect.StaticLine], timepassed: list[float], modified: list[bool], fullcheck: bool) -> CircleLineIntersect.Collideresult: ...

  @staticmethod
  def checkforcecirclescollidetime(forceCircle2: List[CircleLineIntersect.ForceCircle], lines: ArrayList[CircleLineIntersect.StaticLine], timepassed: list[float], modified: list[bool], fullcheck: bool) -> CircleLineIntersect.Collideresult: ...

  def __init__(self): ...

  class PointVector(CircleLineIntersect.Point):

    @overload
    def getLength(self) -> float: ...

    @overload
    def getLength(self) -> float: ...

    def getVector(self) -> CircleLineIntersect.Vector: ...

    def getX1(self) -> float: ...

    def getX2(self) -> float: ...

    def getY1(self) -> float: ...

    def getY2(self) -> float: ...

    @overload
    def getvx(self) -> float: ...

    @overload
    def getvx(self) -> float: ...

    @overload
    def getvy(self) -> float: ...

    @overload
    def getvy(self) -> float: ...

    def setRect(self, arg0: float, arg1: float) -> None: ...

    @overload
    def __init__(self, arg0: CircleLineIntersect.PointVector): ...
    @overload
    def __init__(self, arg0: float, arg1: float): ...
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float): ...

  class Collideclassindex:

    def addCollided(self, arg0: object, arg1: int, arg2: CircleLineIntersect.Vector) -> None: ...

    def collided(self) -> bool: ...

    def contains(self, arg0: object) -> CircleLineIntersect.Collider: ...

    def getColliders(self) -> ArrayList[CircleLineIntersect.Collider]: ...

    def getNumforcecircles(self) -> int: ...

    def reset(self) -> None: ...

    def setCollided(self, arg0: object, arg1: int, arg2: CircleLineIntersect.Vector) -> None: ...

    def size(self) -> int: ...

    def toString(self) -> str: ...

    @overload
    def __init__(self): ...
    @overload
    def __init__(self, arg0: object, arg1: int, arg2: CircleLineIntersect.Vector): ...

  class ForceCircle(CircleLineIntersect.Force):

    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float): ...

  class StaticLine(CircleLineIntersect.Point):

    def getP1(self) -> CircleLineIntersect.Point: ...

    def getP2(self) -> CircleLineIntersect.Point: ...

    def getX1(self) -> float: ...

    def getX2(self) -> float: ...

    def getY1(self) -> float: ...

    def getY2(self) -> float: ...

    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float): ...

  class VectorMath:

    @staticmethod
    def add(arg0: CircleLineIntersect.Vector, arg1: CircleLineIntersect.Vector) -> CircleLineIntersect.Vector: ...

    @staticmethod
    @overload
    def anglebetween(arg0: CircleLineIntersect.Vector, arg1: CircleLineIntersect.Vector) -> float: ...

    @staticmethod
    @overload
    def anglebetween(arg0: float, arg1: float, arg2: float, arg3: float) -> float: ...

    @staticmethod
    @overload
    def closestpointonline(arg0: CircleLineIntersect.StaticLine, arg1: CircleLineIntersect.Point) -> CircleLineIntersect.Point: ...

    @staticmethod
    @overload
    def closestpointonline(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float) -> CircleLineIntersect.Point: ...

    @staticmethod
    @overload
    def cosproj(arg0: CircleLineIntersect.Vector, arg1: CircleLineIntersect.Vector) -> float: ...

    @staticmethod
    @overload
    def cosproj(arg0: float, arg1: float, arg2: float, arg3: float) -> float: ...

    @staticmethod
    @overload
    def crossproduct(arg0: CircleLineIntersect.Vector, arg1: CircleLineIntersect.Vector) -> float: ...

    @staticmethod
    @overload
    def crossproduct(arg0: float, arg1: float, arg2: float, arg3: float) -> float: ...

    @staticmethod
    @overload
    def dotproduct(arg0: CircleLineIntersect.Vector, arg1: CircleLineIntersect.Vector) -> float: ...

    @staticmethod
    @overload
    def dotproduct(arg0: float, arg1: float, arg2: float, arg3: float) -> float: ...

    @staticmethod
    @overload
    def equaldirection(arg0: float, arg1: float, arg2: float) -> bool: ...

    @staticmethod
    @overload
    def equaldirection(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float) -> bool: ...

    @staticmethod
    @overload
    def equaldirection(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float) -> bool: ...

    @staticmethod
    @overload
    def equaldirection(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float) -> bool: ...

    @staticmethod
    def getVector(arg0: CircleLineIntersect.Point, arg1: CircleLineIntersect.Point) -> CircleLineIntersect.Vector: ...

    @staticmethod
    def length(arg0: float, arg1: float) -> float: ...

    @staticmethod
    def linepointdistance(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float) -> float: ...

    @staticmethod
    def linepointdistancesq(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float) -> float: ...

    @staticmethod
    def rotate(arg0: CircleLineIntersect.Vector, arg1: float) -> CircleLineIntersect.Vector: ...

    @staticmethod
    @overload
    def sinproj(arg0: CircleLineIntersect.Vector, arg1: CircleLineIntersect.Vector) -> float: ...

    @staticmethod
    @overload
    def sinproj(arg0: float, arg1: float, arg2: float, arg3: float) -> float: ...

    @staticmethod
    def subtract(arg0: CircleLineIntersect.Vector, arg1: CircleLineIntersect.Vector) -> CircleLineIntersect.Vector: ...

  class Point:

    def distance(self, arg0: CircleLineIntersect.Point) -> float: ...

    @overload
    def distanceSq(self, arg0: CircleLineIntersect.Point) -> float: ...

    @overload
    def distanceSq(self, arg0: float, arg1: float) -> float: ...

    def getX(self) -> float: ...

    def getY(self) -> float: ...

    def setPoint(self, arg0: float, arg1: float) -> None: ...

    @staticmethod
    @overload
    def midpoint(arg0: CircleLineIntersect.Point, arg1: CircleLineIntersect.Point) -> CircleLineIntersect.Point: ...

    @staticmethod
    @overload
    def midpoint(arg0: float, arg1: float, arg2: float, arg3: float) -> CircleLineIntersect.Point: ...

    def __init__(self, arg0: float, arg1: float): ...

  class Vector:

    def getLength(self) -> float: ...

    def getvx(self) -> float: ...

    def getvy(self) -> float: ...

  class Collider:

    def getCollideforce(self) -> CircleLineIntersect.Vector: ...

    def getCollideobj(self) -> object: ...

    def getCollidewith(self) -> Integer: ...

    def setCollideforce(self, arg0: CircleLineIntersect.Vector) -> None: ...

    def toString(self) -> str: ...

    @overload
    def __init__(self, arg0: CircleLineIntersect.Vector, arg1: Integer): ...
    @overload
    def __init__(self, arg0: object, arg1: Integer, arg2: CircleLineIntersect.Vector): ...

  class RectVector:

    @overload
    def getLength(self) -> float: ...

    @overload
    def getLength(self) -> float: ...

    def getUnitVector(self) -> CircleLineIntersect.Vector: ...

    @overload
    def getvx(self) -> float: ...

    @overload
    def getvx(self) -> float: ...

    @overload
    def getvy(self) -> float: ...

    @overload
    def getvy(self) -> float: ...

    def setVector(self, arg0: CircleLineIntersect.Vector) -> None: ...

    @overload
    def __init__(self, arg0: CircleLineIntersect.Vector): ...
    @overload
    def __init__(self, arg0: float, arg1: float): ...

  class Collideresult:

    def toString(self) -> str: ...

    def __init__(self, arg0: list[CircleLineIntersect.PointVector], arg1: list[CircleLineIntersect.Collideclassindex], arg2: ArrayList[Integer], arg3: list[float], arg4: list[float], arg5: list[bool]): ...

  class Force(CircleLineIntersect.PointVector):

    def getLength(self) -> float: ...

    def getRestitution(self, arg0: object) -> float: ...

    def getnormvx(self) -> float: ...

    def getnormvy(self) -> float: ...

    def setPointVector(self, arg0: CircleLineIntersect.PointVector) -> None: ...

    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float): ...


class Clipper:

  def addAABB(self, x1: float, y1: float, x2: float, y2: float) -> None: ...

  def addAABBBevel(self, x1: float, y1: float, x2: float, y2: float, RADIUS: float) -> None: ...

  def addLine(self, x1: float, y1: float, x2: float, y2: float) -> None: ...

  def addPath(self, numPoints: int, points: ByteBuffer, bClip: bool) -> None: ...

  def addPolygon(self, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float, x4: float, y4: float) -> None: ...

  def clear(self) -> None: ...

  def clipAABB(self, x1: float, y1: float, x2: float, y2: float) -> None: ...

  @overload
  def generatePolygons(self) -> int: ...

  @overload
  def generatePolygons(self, delta: float) -> int: ...

  def generateTriangulatePolygons(self, wx: int, wy: int) -> int: ...

  def getPolygon(self, index: int, vertices: ByteBuffer) -> int: ...

  def triangulate(self, index: int, vertices: ByteBuffer) -> int: ...

  @staticmethod
  def init() -> None: ...

  @staticmethod
  def n_init() -> None: ...

  def __init__(self): ...


class ClipperOffset:

  def addPath(self, numPoints: int, points: ByteBuffer, joinType: int, endType: int) -> None: ...

  def clear(self) -> None: ...

  def execute(self, delta: float) -> None: ...

  def getPolygon(self, index: int, vertices: ByteBuffer) -> int: ...

  def getPolygonCount(self) -> int: ...

  def __init__(self): ...

  class EndType(Enum):

    etClosedLine: ClipperOffset.EndType

    etClosedPolygon: ClipperOffset.EndType

    etOpenButt: ClipperOffset.EndType

    etOpenRound: ClipperOffset.EndType

    etOpenSquare: ClipperOffset.EndType

    @staticmethod
    def valueOf(arg0: str) -> ClipperOffset.EndType: ...

    @staticmethod
    def values() -> list[ClipperOffset.EndType]: ...

  class JoinType(Enum):

    jtMiter: ClipperOffset.JoinType

    jtRound: ClipperOffset.JoinType

    jtSquare: ClipperOffset.JoinType

    @staticmethod
    def valueOf(arg0: str) -> ClipperOffset.JoinType: ...

    @staticmethod
    def values() -> list[ClipperOffset.JoinType]: ...


class CollideWithObstacles:

  def getIntersection(self, edge1: CollideWithObstacles.CCEdge, edge2: CollideWithObstacles.CCEdge) -> CollideWithObstacles.CCIntersection: ...

  def __init__(self): ...

  class ImmutableRectF: ...

  class CCObjectOutline: ...

  class CompareIntersection:

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: CollideWithObstacles.CCIntersection, arg1: CollideWithObstacles.CCIntersection) -> int: ...

    def equals(self, arg0: object) -> bool: ...

    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

  class CCNode: ...

  class CCObstacle: ...

  class CCEdge: ...

  class CCIntersection: ...

  class EdgeRingHit(Enum):

    Inside: CollideWithObstacles.EdgeRingHit

    OnEdge: CollideWithObstacles.EdgeRingHit

    Outside: CollideWithObstacles.EdgeRingHit

    @staticmethod
    def valueOf(arg0: str) -> CollideWithObstacles.EdgeRingHit: ...

    @staticmethod
    def values() -> list[CollideWithObstacles.EdgeRingHit]: ...


class CollideWithObstaclesPoly:

  def isNotClear(self, x0: float, y0: float, x1: float, y1: float, z: int, render: bool, ignoreVehicle: BaseVehicle, ignoreDoors: bool, closeToWalls: bool) -> bool: ...

  def render(self) -> None: ...

  def resolveCollision(self, chr: IsoGameCharacter, nx: float, ny: float, finalPos: Vector2f) -> Vector2f: ...

  def vehicleMoved(self, oldPolyPlusRadius: PolygonalMap2.VehiclePoly, newPolyPlusRadius: PolygonalMap2.VehiclePoly) -> None: ...

  def __init__(self): ...

  class ImmutableRectF: ...

  class ClosestPointOnEdge: ...

  class ChunkData:

    def clear(self) -> None: ...

    def init(self, chunk: IsoChunk, z: int, instance: CollideWithObstaclesPoly) -> CollideWithObstaclesPoly.ChunkDataZ: ...

    def __init__(self): ...

  class ChunkDataZ:

    pool: ObjectPool[CollideWithObstaclesPoly.ChunkDataZ]

    def clear(self) -> None: ...

    def init(self, chunk: IsoChunk, z: int, instance: CollideWithObstaclesPoly) -> None: ...

    def __init__(self):
      self.nodes: ArrayList[CollideWithObstaclesPoly.CCNode]
      self.worldvehicleseparate: ArrayList[CollideWithObstaclesPoly.CCObstacle]
      self.worldvehicleunion: ArrayList[CollideWithObstaclesPoly.CCObstacle]
      self.z: int

  class CCObstacle: ...

  class CCEdge: ...

  class CCNode: ...

  class CCEdgeRing(ArrayList): ...

  class EdgeRingHit(Enum):

    Inside: CollideWithObstaclesPoly.EdgeRingHit

    OnEdge: CollideWithObstaclesPoly.EdgeRingHit

    Outside: CollideWithObstaclesPoly.EdgeRingHit

    @staticmethod
    def valueOf(arg0: str) -> CollideWithObstaclesPoly.EdgeRingHit: ...

    @staticmethod
    def values() -> list[CollideWithObstaclesPoly.EdgeRingHit]: ...


class EditVehicleState(GameState):

  instance: EditVehicleState

  def enter(self) -> None: ...

  def exit(self) -> None: ...

  def fromLua0(self, func: str) -> object: ...

  def fromLua1(self, func: str, arg0: object) -> object: ...

  def reenter(self) -> None: ...

  def render(self) -> None: ...

  def setScript(self, scriptName: str) -> None: ...

  def setTable(self, table: KahluaTable) -> None: ...

  def update(self) -> GameStateMachine.StateAction: ...

  @staticmethod
  def checkInstance() -> EditVehicleState: ...

  def __init__(self): ...

  class LuaEnvironment:

    def __init__(self, platform: J2SEPlatform, converterManager: KahluaConverterManager, env: KahluaTable):
      self.caller: LuaCaller
      self.env: KahluaTable
      self.platform: J2SEPlatform
      self.thread: KahluaThread


class EngineRPMData:

  def reset(self) -> None: ...

  @overload
  def __init__(self):
    self.aftergearchange: float

    self.gearchange: float

  @overload
  def __init__(self, gearChange: float, afterGearChange: float): ...


class LightbarLightsMode:

  def get(self) -> int: ...

  def getLightTexIndex(self) -> int: ...

  def isEnable(self) -> bool: ...

  def set(self, v: int) -> None: ...

  def start(self) -> None: ...

  def update(self) -> None: ...

  def __init__(self): ...


class LightbarSirenMode:

  def get(self) -> int: ...

  def getSoundName(self, lightbar: VehicleScript.LightBar) -> str: ...

  def isEnable(self) -> bool: ...

  def set(self, v: int) -> None: ...

  def __init__(self): ...


class PathFindBehavior2:

  @overload
  def Failed(self, mover: Mover) -> None: ...

  @overload
  def Failed(self, mover: Mover) -> None: ...

  @overload
  def Succeeded(self, path: PolygonalMap2.Path, mover: Mover) -> None: ...

  @overload
  def Succeeded(self, path: PolygonalMap2.Path, mover: Mover) -> None: ...

  def cancel(self) -> None: ...

  def getIsCancelled(self) -> bool: ...

  def getPathLength(self) -> float: ...

  def getTargetChar(self) -> IsoGameCharacter: ...

  def getTargetX(self) -> float: ...

  def getTargetY(self) -> float: ...

  def getTargetZ(self) -> float: ...

  def isGoalCharacter(self) -> bool: ...

  def isGoalLocation(self) -> bool: ...

  def isGoalNone(self) -> bool: ...

  def isGoalSound(self) -> bool: ...

  def isGoalVehicleAdjacent(self) -> bool: ...

  def isGoalVehicleArea(self) -> bool: ...

  def isGoalVehicleSeat(self) -> bool: ...

  def isMovingUsingPathFind(self) -> bool: ...

  def isStrafing(self) -> bool: ...

  def isTargetLocation(self, x: float, y: float, z: float) -> bool: ...

  def moveToDir(self, target: IsoMovingObject, speedMul: float) -> None: ...

  def moveToPoint(self, x: float, y: float, speedMul: float) -> None: ...

  def pathToCharacter(self, target: IsoGameCharacter) -> None: ...

  def pathToLocation(self, x: int, y: int, z: int) -> None: ...

  def pathToLocationF(self, x: float, y: float, z: float) -> None: ...

  def pathToNearest(self, locations: TFloatArrayList) -> None: ...

  def pathToNearestTable(self, locationsTable: KahluaTable) -> None: ...

  def pathToSound(self, x: int, y: int, z: int) -> None: ...

  def pathToVehicleAdjacent(self, vehicle: BaseVehicle) -> None: ...

  def pathToVehicleArea(self, vehicle: BaseVehicle, areaId: str) -> None: ...

  def pathToVehicleSeat(self, vehicle: BaseVehicle, seat: int) -> None: ...

  def render(self) -> None: ...

  def reset(self) -> None: ...

  def setData(self, targetX: float, targetY: float, targetZ: float) -> None: ...

  def shouldGetUpFromCrawl(self) -> bool: ...

  def update(self) -> PathFindBehavior2.BehaviorResult: ...

  @staticmethod
  def closestPointOnPath(x3: float, y3: float, z: float, mover: IsoMovingObject, path: PolygonalMap2.Path, pop: PathFindBehavior2.PointOnPath) -> None: ...

  def __init__(self, chr: IsoGameCharacter):
    self.bstopping: bool
    self.listeners: ArrayList[IPathfinder]
    self.npcdata: PathFindBehavior2.NPCData
    self.pathnextisset: bool
    self.pathnextx: float
    self.pathnexty: float
    self.walkingonthespot: WalkingOnTheSpot

  class NPCData:

    def __init__(self, arg0: PathFindBehavior2):
      self.dodirectmovement: bool
      self.maxsteps: int
      self.nexttilex: int
      self.nexttiley: int
      self.nexttilez: int

  class Goal(Enum):

    Character: PathFindBehavior2.Goal

    Location: PathFindBehavior2.Goal

    # None: PathFindBehavior2.Goal

    Sound: PathFindBehavior2.Goal

    VehicleAdjacent: PathFindBehavior2.Goal

    VehicleArea: PathFindBehavior2.Goal

    VehicleSeat: PathFindBehavior2.Goal

    @staticmethod
    def valueOf(arg0: str) -> PathFindBehavior2.Goal: ...

    @staticmethod
    def values() -> list[PathFindBehavior2.Goal]: ...

  class BehaviorResult(Enum):

    Failed: PathFindBehavior2.BehaviorResult

    Succeeded: PathFindBehavior2.BehaviorResult

    Working: PathFindBehavior2.BehaviorResult

    @staticmethod
    def valueOf(arg0: str) -> PathFindBehavior2.BehaviorResult: ...

    @staticmethod
    def values() -> list[PathFindBehavior2.BehaviorResult]: ...

  class DebugPt: ...

  class PointOnPath:

    def __init__(self): ...


class PathFindState2(State):

  def animEvent(self, owner: IsoGameCharacter, event: AnimEvent) -> None: ...

  def enter(self, owner: IsoGameCharacter) -> None: ...

  def execute(self, owner: IsoGameCharacter) -> None: ...

  def exit(self, owner: IsoGameCharacter) -> None: ...

  def isMoving(self, owner: IsoGameCharacter) -> bool: ...

  def __init__(self): ...


class PolyPolyIntersect:

  @staticmethod
  def intersects(a: PolygonalMap2.VehiclePoly, b: PolygonalMap2.VehiclePoly) -> bool: ...

  def __init__(self): ...


class PolygonalMap2:

  CLOSE_TO_WALLS: bool

  COLLIDE_BEVEL: bool

  COLLIDE_CLIPPER: bool

  CXN_FLAG_CAN_PATH: int

  CXN_FLAG_THUMP: int

  instance: PolygonalMap2

  LCC_ALLOW_ON_EDGE: int

  LCC_CHECK_COST: int

  LCC_CLOSE_TO_WALLS: int

  LCC_IGNORE_DOORS: int

  LCC_RENDER: int

  LCC_ZERO: int

  NODE_FLAG_CRAWL: int

  NODE_FLAG_CRAWL_INTERIOR: int

  NODE_FLAG_IN_CHUNK_DATA: int

  NODE_FLAG_KEEP: int

  NODE_FLAG_PERIMETER: int

  PATHS_UNDER_VEHICLES: bool

  RADIUS: float

  def addChunkToWorld(self, chunk: IsoChunk) -> None: ...

  def addRequest(self, pathfinder: PolygonalMap2.IPathfinder, mover: Mover, startX: float, startY: float, startZ: float, targetX: float, targetY: float, targetZ: float) -> PolygonalMap2.PathFindRequest: ...

  def addVehicleToWorld(self, vehicle: BaseVehicle) -> None: ...

  @overload
  def canStandAt(self, x: float, y: float, z: int, ignoreVehicle: BaseVehicle, flags: int) -> bool: ...

  @overload
  def canStandAt(self, x: float, y: float, z: int, ignoreVehicle: IsoMovingObject, ignoreDoors: bool, closeToWalls: bool) -> bool: ...

  def cancelRequest(self, mover: Mover) -> None: ...

  def getCollidepoint(self, fromX: float, fromY: float, toX: float, toY: float, z: int, ignoreVehicle: IsoMovingObject, flags: int) -> Vector2: ...

  def getPointInLine(self, fromX: float, fromY: float, toX: float, toY: float, z: int) -> ArrayList[PolygonalMap2.Point]: ...

  def init(self, metaGrid: IsoMetaGrid) -> None: ...

  def intersectLineWithVehicle(self, x1: float, y1: float, x2: float, y2: float, vehicle: BaseVehicle, out: Vector2) -> bool: ...

  @overload
  def lineClearCollide(self, fromX: float, fromY: float, toX: float, toY: float, z: int) -> bool: ...

  @overload
  def lineClearCollide(self, fromX: float, fromY: float, toX: float, toY: float, z: int, ignoreVehicle: IsoMovingObject) -> bool: ...

  @overload
  def lineClearCollide(self, fromX: float, fromY: float, toX: float, toY: float, z: int, ignoreVehicle: IsoMovingObject, flags: int) -> bool: ...

  @overload
  def lineClearCollide(self, fromX: float, fromY: float, toX: float, toY: float, z: int, ignoreVehicle: IsoMovingObject, ignoreDoors: bool, closeToWalls: bool) -> bool: ...

  def removeChunkFromWorld(self, chunk: IsoChunk) -> None: ...

  def removeVehicleFromWorld(self, vehicle: BaseVehicle) -> None: ...

  def render(self) -> None: ...

  def resolveCollision(self, chr: IsoGameCharacter, nx: float, ny: float, finalPos: Vector2f) -> Vector2f: ...

  def squareChanged(self, square: IsoGridSquare) -> None: ...

  def stop(self) -> None: ...

  def updateMain(self) -> None: ...

  def updateThread(self) -> None: ...

  def updateVehicle(self, vehicle: BaseVehicle) -> None: ...

  def __init__(self): ...

  class ClosestPointOnEdge: ...

  class AdjustStartEndNodeData: ...

  class LineClearCollide: ...

  class VGAStar(AStar):

    class InitProc:

      @overload
      def execute(self, arg0: int, arg1: object) -> bool: ...

      @overload
      def execute(self, arg0: int, arg1: object) -> bool: ...

      @overload
      def execute(self, arg0: int, arg1: PolygonalMap2.Node) -> bool: ...

  class TestRequest:

    @overload
    def Failed(self, arg0: Mover) -> None: ...

    @overload
    def Failed(self, arg0: Mover) -> None: ...

    @overload
    def Succeeded(self, arg0: PolygonalMap2.Path, arg1: Mover) -> None: ...

    @overload
    def Succeeded(self, arg0: PolygonalMap2.Path, arg1: Mover) -> None: ...

  class Path:

    def crossesSquare(self, x: int, y: int, z: int) -> bool: ...

    def __init__(self): ...

  class Sync: ...

  class RequestQueue: ...

  class LineClearCollideMain:

    def drawCircle(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float) -> None: ...

  class VehicleRect: ...

  class VehicleCluster: ...

  class Vehicle: ...

  class VehiclePoly:

    def containsPoint(self, x: float, y: float) -> bool: ...

    @staticmethod
    def lineIntersection(start1: Vector2, end1: Vector2, start2: Vector2, end2: Vector2) -> Vector2: ...

  class Square: ...

  class Node: ...

  class VisibilityGraph:

    def getIntersection(self, arg0: PolygonalMap2.Edge, arg1: PolygonalMap2.Edge) -> PolygonalMap2.Intersection: ...

    class CompareIntersection:

      @overload
      def compare(self, arg0: object, arg1: object) -> int: ...

      @overload
      def compare(self, arg0: object, arg1: object) -> int: ...

      @overload
      def compare(self, arg0: PolygonalMap2.Intersection, arg1: PolygonalMap2.Intersection) -> int: ...

      def equals(self, arg0: object) -> bool: ...

      def reversed(self) -> Comparator[T]: ...

      @overload
      def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

      @overload
      def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

      @overload
      def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

      def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

      def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

      def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

      @staticmethod
      @overload
      def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

      @staticmethod
      @overload
      def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

      @staticmethod
      def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

      @staticmethod
      def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

      @staticmethod
      def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

      @staticmethod
      def naturalOrder() -> Comparator[T]: ...

      @staticmethod
      def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

      @staticmethod
      def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

      @staticmethod
      def reverseOrder() -> Comparator[T]: ...

  class Connection: ...

  class Obstacle: ...

  class PathFindRequest:

    def release(self) -> None: ...

  class PathNode: ...

  class SearchNode(ASearchNode):

    def c(self, arg0: ISearchNode) -> float: ...

    def dist(self, arg0: PolygonalMap2.SearchNode) -> float: ...

    def getParent(self) -> ISearchNode: ...

    def getSuccessors(self, arg0: ArrayList[ISearchNode]) -> None: ...

    def getX(self) -> float: ...

    def getY(self) -> float: ...

    def getZ(self) -> float: ...

    def h(self) -> float: ...

    def keyCode(self) -> Integer: ...

    def setParent(self, arg0: ISearchNode) -> None: ...

  class Edge: ...

  class EdgeRing(ArrayList):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: PolygonalMap2.Edge) -> bool: ...

    def hasNode(self, arg0: PolygonalMap2.Node) -> bool: ...

    def release(self) -> None: ...

  class Chunk: ...

  class L_render: ...

  class IPathfinder:

    def Failed(self, mover: Mover) -> None: ...

    def Succeeded(self, path: PolygonalMap2.Path, mover: Mover) -> None: ...

  class SquareUpdateTask:

    def release(self) -> None: ...

  class PMThread(Thread):

    def run(self) -> None: ...

  class ChunkUpdateTask:

    @overload
    def execute(self) -> None: ...

    @overload
    def execute(self) -> None: ...

    @overload
    def release(self) -> None: ...

    @overload
    def release(self) -> None: ...

  class ChunkRemoveTask:

    @overload
    def execute(self) -> None: ...

    @overload
    def execute(self) -> None: ...

    @overload
    def release(self) -> None: ...

    @overload
    def release(self) -> None: ...

  class VehicleAddTask:

    @overload
    def execute(self) -> None: ...

    @overload
    def execute(self) -> None: ...

    @overload
    def init(self, arg0: PolygonalMap2, arg1: BaseVehicle) -> None: ...

    @overload
    def init(self, arg0: PolygonalMap2, arg1: BaseVehicle) -> None: ...

    @overload
    def release(self) -> None: ...

    @overload
    def release(self) -> None: ...

  class VehicleState: ...

  class VehicleUpdateTask:

    @overload
    def execute(self) -> None: ...

    @overload
    def execute(self) -> None: ...

    @overload
    def init(self, arg0: PolygonalMap2, arg1: BaseVehicle) -> None: ...

    @overload
    def init(self, arg0: PolygonalMap2, arg1: BaseVehicle) -> None: ...

    @overload
    def release(self) -> None: ...

    @overload
    def release(self) -> None: ...

  class VehicleRemoveTask:

    @overload
    def execute(self) -> None: ...

    @overload
    def execute(self) -> None: ...

    @overload
    def init(self, arg0: PolygonalMap2, arg1: BaseVehicle) -> None: ...

    @overload
    def init(self, arg0: PolygonalMap2, arg1: BaseVehicle) -> None: ...

    @overload
    def release(self) -> None: ...

    @overload
    def release(self) -> None: ...

  class Cell: ...

  class IChunkTask:

    def execute(self) -> None: ...

    def release(self) -> None: ...

  class IVehicleTask:

    def execute(self) -> None: ...

    def init(self, arg0: PolygonalMap2, arg1: BaseVehicle) -> None: ...

    def release(self) -> None: ...

  class PathRequestTask:

    def release(self) -> None: ...

  class ChunkDataZ:

    pool: ObjectPool[PolygonalMap2.ChunkDataZ]

    def clear(self) -> None: ...

    def init(self, arg0: PolygonalMap2.Chunk, arg1: int) -> None: ...

  class PointPool: ...

  class Point:

    def equals(self, other: object) -> bool: ...

    def __init__(self):
      self.x: int
      self.y: int

  class ConnectedRegions: ...

  class LiangBarsky:

    @overload
    def lineRectIntersect(self, x: float, y: float, dx: float, dy: float, left: float, top: float, right: float, bottom: float) -> bool: ...

    @overload
    def lineRectIntersect(self, x: float, y: float, dx: float, dy: float, left: float, top: float, right: float, bottom: float, t1t2: list[float]) -> bool: ...

    def __init__(self): ...

  class ChunkData:

    def clear(self) -> None: ...

    def init(self, arg0: PolygonalMap2.Chunk, arg1: int) -> PolygonalMap2.ChunkDataZ: ...

  class GoalNode:

    @overload
    def inGoal(self, arg0: ISearchNode) -> bool: ...

    @overload
    def inGoal(self, arg0: ISearchNode) -> bool: ...

  class ImmutableRectF: ...

  class Intersection: ...

  class ClusterOutlineGrid: ...

  class ClusterOutline: ...

  class ObjectOutline: ...

  class EdgeRingHit(Enum):

    Inside: PolygonalMap2.EdgeRingHit

    OnEdge: PolygonalMap2.EdgeRingHit

    Outside: PolygonalMap2.EdgeRingHit

    @staticmethod
    def valueOf(arg0: str) -> PolygonalMap2.EdgeRingHit: ...

    @staticmethod
    def values() -> list[PolygonalMap2.EdgeRingHit]: ...

  class L_lineSegmentIntersects: ...


class QuadranglesIntersection:

  @staticmethod
  def IsPointInTriangle(p: Vector2, q: list[Vector2]) -> bool: ...

  @staticmethod
  def IsQuadranglesAreIntersected(q1: list[Vector2], q2: list[Vector2]) -> bool: ...

  @staticmethod
  def IsQuadranglesAreTransposed2(q1: Vector4f, q2: Vector4f) -> bool: ...

  @staticmethod
  def det(a: float, b: float, c: float, d: float) -> float: ...

  @staticmethod
  def lineIntersection(start1: Vector2, end1: Vector2, start2: Vector2, end2: Vector2) -> bool: ...

  def __init__(self): ...


class SurroundVehicle:

  def getPositionForZombie(self, zombie: IsoZombie, out: Vector2f) -> Vector2f: ...

  def render(self) -> None: ...

  def reset(self) -> None: ...

  def update(self) -> None: ...

  def __init__(self, vehicle: BaseVehicle):
    self.x1: float
    self.x2: float
    self.x3: float
    self.x4: float
    self.y1: float
    self.y2: float
    self.y3: float
    self.y4: float

  class PositionSide(Enum):

    Front: SurroundVehicle.PositionSide

    Left: SurroundVehicle.PositionSide

    Rear: SurroundVehicle.PositionSide

    Right: SurroundVehicle.PositionSide

    @staticmethod
    def valueOf(arg0: str) -> SurroundVehicle.PositionSide: ...

    @staticmethod
    def values() -> list[SurroundVehicle.PositionSide]: ...

  class Position: ...


class TransmissionNumber(Enum):

  N: TransmissionNumber

  R: TransmissionNumber

  Speed1: TransmissionNumber

  Speed2: TransmissionNumber

  Speed3: TransmissionNumber

  Speed4: TransmissionNumber

  Speed5: TransmissionNumber

  Speed6: TransmissionNumber

  Speed7: TransmissionNumber

  Speed8: TransmissionNumber

  def getIndex(self) -> int: ...

  def getNext(self, gearRatioCount: int) -> TransmissionNumber: ...

  def getPrev(self, gearRatioCount: int) -> TransmissionNumber: ...

  def getString(self) -> str: ...

  @staticmethod
  def fromIndex(index: int) -> TransmissionNumber: ...

  @staticmethod
  def valueOf(arg0: str) -> TransmissionNumber: ...

  @staticmethod
  def values() -> list[TransmissionNumber]: ...


class UI3DScene(UIElement):

  def fromLua0(self, func: str) -> object: ...

  def fromLua1(self, func: str, arg0: object) -> object: ...

  def fromLua2(self, func: str, arg0: object, arg1: object) -> object: ...

  def fromLua3(self, func: str, arg0: object, arg1: object, arg2: object) -> object: ...

  def fromLua4(self, func: str, arg0: object, arg1: object, arg2: object, arg3: object) -> object: ...

  def fromLua6(self, func: str, arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> object: ...

  def fromLua9(self, func: str, arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> object: ...

  def render(self) -> None: ...

  def sceneToUIX(self, sceneX: float, sceneY: float, sceneZ: float) -> float: ...

  def sceneToUIY(self, sceneX: float, sceneY: float, sceneZ: float) -> float: ...

  @overload
  def uiToScene(self, uiX: float, uiY: float, uiZ: float, out: Vector3f) -> Vector3f: ...

  @overload
  def uiToScene(self, modelTransform: Matrix4f, uiX: float, uiY: float, uiZ: float, out: Vector3f) -> Vector3f: ...

  def uiToSceneX(self, uiX: float, uiY: float) -> float: ...

  def uiToSceneY(self, uiX: float, uiY: float) -> float: ...

  @staticmethod
  def intersect_ray_plane(Pn: UI3DScene.Plane, S: UI3DScene.Ray, out: Vector3f) -> int: ...

  def __init__(self, table: KahluaTable): ...

  class View(Enum):

    Back: UI3DScene.View

    Bottom: UI3DScene.View

    Front: UI3DScene.View

    Left: UI3DScene.View

    Right: UI3DScene.View

    Top: UI3DScene.View

    UserDefined: UI3DScene.View

    @staticmethod
    def valueOf(arg0: str) -> UI3DScene.View: ...

    @staticmethod
    def values() -> list[UI3DScene.View]: ...

  class TransformMode(Enum):

    Local: UI3DScene.TransformMode

    @staticmethod
    def valueOf(arg0: str) -> UI3DScene.TransformMode: ...

    @staticmethod
    def values() -> list[UI3DScene.TransformMode]: ...

  class GridPlane(Enum):

    XY: UI3DScene.GridPlane

    XZ: UI3DScene.GridPlane

    YZ: UI3DScene.GridPlane

    @staticmethod
    def valueOf(arg0: str) -> UI3DScene.GridPlane: ...

    @staticmethod
    def values() -> list[UI3DScene.GridPlane]: ...

  class CharacterSceneModelCamera(UI3DScene.SceneModelCamera):

    def Begin(self) -> None: ...

    def End(self) -> None: ...

  class VehicleSceneModelCamera(UI3DScene.SceneModelCamera):

    def Begin(self) -> None: ...

    def End(self) -> None: ...

  class StateData: ...

  class RotateGizmo(UI3DScene.Gizmo): ...

  class ScaleGizmo(UI3DScene.Gizmo): ...

  class TranslateGizmo(UI3DScene.Gizmo): ...

  class SceneObject: ...

  class OriginAttachment(UI3DScene.SceneObject): ...

  class OriginBone(UI3DScene.SceneObject): ...

  class OriginGizmo(UI3DScene.SceneObject): ...

  class GridPlaneDrawer(TextureDraw.GenericDrawer):

    def render(self) -> None: ...

  class OverlaysDrawer(TextureDraw.GenericDrawer):

    def render(self) -> None: ...

  class SceneObjectRenderData: ...

  class Gizmo: ...

  class Axis(Enum):

    # None: UI3DScene.Axis

    X: UI3DScene.Axis

    Y: UI3DScene.Axis

    Z: UI3DScene.Axis

    @staticmethod
    def valueOf(arg0: str) -> UI3DScene.Axis: ...

    @staticmethod
    def values() -> list[UI3DScene.Axis]: ...

  class Plane:

    def set(self, normal: Vector3f, point: Vector3f) -> UI3DScene.Plane: ...

    @overload
    def __init__(self):
      self.normal: Vector3f

      self.point: Vector3f

    @overload
    def __init__(self, normal: Vector3f, point: Vector3f): ...

  class Ray:

    def __init__(self):
      self.direction: Vector3f
      self.origin: Vector3f
      self.t: float

  class SceneCharacter(UI3DScene.SceneObject): ...

  class SceneModel(UI3DScene.SceneObject): ...

  class SceneVehicle(UI3DScene.SceneObject): ...

  class PositionRotation: ...

  class AABB: ...

  class Box3D: ...

  class Circle: ...

  class VehicleDrawer(TextureDraw.GenericDrawer):

    def init(self, arg0: UI3DScene.SceneVehicle, arg1: UI3DScene.VehicleRenderData) -> None: ...

    def postRender(self) -> None: ...

    def render(self) -> None: ...

  class ModelDrawer(TextureDraw.GenericDrawer):

    def init(self, arg0: UI3DScene.SceneModel, arg1: UI3DScene.ModelRenderData) -> None: ...

    def postRender(self) -> None: ...

    def render(self) -> None: ...

  class CharacterDrawer(TextureDraw.GenericDrawer):

    def init(self, arg0: UI3DScene.SceneCharacter, arg1: UI3DScene.CharacterRenderData) -> None: ...

    def postRender(self) -> None: ...

    def render(self) -> None: ...

  class TranslateGizmoRenderData: ...

  class PlaneObjectPool(ObjectPool):

    def __init__(self): ...

  class RayObjectPool(ObjectPool):

    def __init__(self): ...

  class SetModelCamera(TextureDraw.GenericDrawer):

    def postRender(self) -> None: ...

    def render(self) -> None: ...

  class SceneModelCamera(ModelCamera): ...

  class VehicleRenderData(UI3DScene.SceneObjectRenderData): ...

  class ModelRenderData(UI3DScene.SceneObjectRenderData): ...

  class CharacterRenderData(UI3DScene.SceneObjectRenderData): ...


class VehicleCache:

  @staticmethod
  def Reset() -> None: ...

  @staticmethod
  def remove(id: int) -> None: ...

  @staticmethod
  @overload
  def vehicleGet(ax: float, ay: float) -> List[VehicleCache]: ...

  @staticmethod
  @overload
  def vehicleGet(wx: int, wy: int) -> List[VehicleCache]: ...

  @staticmethod
  def vehicleUpdate(id: int, ax: float, ay: float, az: float) -> None: ...

  def __init__(self):
    self.id: int


class VehicleDBHelper:

  @staticmethod
  def isPlayerAlive(saveDir: str, playerSqlId: int) -> bool: ...

  def __init__(self): ...


class VehicleDoor:

  def init(self, scriptDoor: VehicleScript.Door) -> None: ...

  def isLockBroken(self) -> bool: ...

  def isLocked(self) -> bool: ...

  def isOpen(self) -> bool: ...

  def load(self, input: ByteBuffer, WorldVersion: int) -> None: ...

  def save(self, output: ByteBuffer) -> None: ...

  def setLockBroken(self, broken: bool) -> None: ...

  def setLocked(self, locked: bool) -> None: ...

  def setOpen(self, open: bool) -> None: ...

  def __init__(self, part: VehiclePart): ...


class VehicleEngineRPM(BaseScriptObject):

  MAX_GEARS: int

  def Load(self, name: str, totalFile: str) -> None: ...

  def getName(self) -> str: ...

  def reset(self) -> None: ...

  def __init__(self):
    self.m_rpmdata: list[EngineRPMData]


class VehicleIDMap:

  instance: VehicleIDMap

  def Reset(self) -> None: ...

  def allocateID(self) -> int: ...

  def containsKey(self, id: int) -> bool: ...

  def get(self, id: int) -> BaseVehicle: ...

  def put(self, id: int, vehicle: BaseVehicle) -> None: ...

  def remove(self, id: int) -> None: ...

  def toArrayList(self, vehicles: ArrayList[BaseVehicle]) -> None: ...


class VehicleInterpolation:

  def clear(self) -> None: ...

  @overload
  def interpolationDataAdd(self, vehicle: BaseVehicle, data: VehicleInterpolationData) -> None: ...

  @overload
  def interpolationDataAdd(self, bb: ByteBuffer, time: int, x: float, y: float, z: float, currentTime: int) -> None: ...

  @overload
  def interpolationDataGet(self, buf1: list[float], buf2: list[float]) -> bool: ...

  @overload
  def interpolationDataGet(self, buf1: list[float], buf2: list[float], time: int) -> bool: ...

  def reset(self) -> None: ...

  def update(self, time: int) -> None: ...


class VehicleInterpolationData:

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, o: VehicleInterpolationData) -> int: ...

  def __init__(self): ...


class VehicleInterpolationTest(Assert):

  def interpolationMicroStepTest(self) -> None: ...

  def interpolationMicroStepTest2(self) -> None: ...

  def interpolationTest(self) -> None: ...

  def normalTest(self) -> None: ...

  def normalTestBufferRestoring2(self) -> None: ...

  def normalTestBufferRestoring3(self) -> None: ...

  def setup(self) -> None: ...

  def testBufferRestoring(self) -> None: ...

  def __init__(self):
    self.watchman: TestRule


class VehicleLight:

  def canFocusingDown(self) -> bool: ...

  def canFocusingUp(self) -> bool: ...

  def getActive(self) -> bool: ...

  def getDistanization(self) -> float: ...

  def getFocusing(self) -> int: ...

  def getIntensity(self) -> float: ...

  def load(self, input: ByteBuffer, WorldVersion: int) -> None: ...

  def save(self, output: ByteBuffer) -> None: ...

  def setActive(self, active: bool) -> None: ...

  def setFocusingDown(self) -> None: ...

  def setFocusingUp(self) -> None: ...

  def __init__(self):
    self.active: bool
    self.dist: float
    self.dot: float
    self.focusing: int
    self.intensity: float
    self.offset: Vector3f


class VehicleManager:

  instance: VehicleManager

  vehiclePacketTypes: HashMap[Byte, str]

  def clientPacket(self, bb: ByteBuffer) -> None: ...

  def clientUpdate(self) -> None: ...

  def getTowedVehicleID(self, towingID: int) -> int: ...

  def getVehicleByID(self, id: int) -> BaseVehicle: ...

  def getVehicles(self) -> ArrayList[BaseVehicle]: ...

  def registerVehicle(self, vehicle: BaseVehicle) -> None: ...

  def removeFromWorld(self, vehicle: BaseVehicle) -> None: ...

  def sendAddImpulse(self, vehicle: BaseVehicle, impulse: Vector3f, rel_pos: Vector3f) -> None: ...

  def sendCollide(self, vehicle: BaseVehicle, chr: IsoGameCharacter, isCollide: bool) -> None: ...

  @overload
  def sendDetachTowing(self, vehicleTowing: BaseVehicle, vehicleTowedBy: BaseVehicle) -> None: ...

  @overload
  def sendDetachTowing(self, connection: UdpConnection, vehicleA: BaseVehicle, vehicleB: BaseVehicle) -> None: ...

  @overload
  def sendEnter(self, vehicle: BaseVehicle, character: IsoGameCharacter, seatTo: int) -> None: ...

  @overload
  def sendEnter(self, connection: UdpConnection, vehicle: BaseVehicle, character: IsoGameCharacter, seatTo: int) -> None: ...

  @overload
  def sendExit(self, vehicle: BaseVehicle, character: IsoGameCharacter, seatFrom: int) -> None: ...

  @overload
  def sendExit(self, connection: UdpConnection, vehicle: BaseVehicle, character: IsoGameCharacter, seatFrom: int) -> None: ...

  @overload
  def sendPassengerPosition(self, vehicle: BaseVehicle, seat: int, positionId: str) -> None: ...

  @overload
  def sendPassengerPosition(self, vehicle: BaseVehicle, seat: int, positionId: str, ignore: UdpConnection) -> None: ...

  def sendPhysic(self, vehicle: BaseVehicle) -> None: ...

  @overload
  def sendRequestGetFull(self, vehicles: List[VehicleCache]) -> None: ...

  @overload
  def sendRequestGetFull(self, VehicleID: int, packetType: PacketTypes.PacketType) -> None: ...

  def sendRequestGetPosition(self, VehicleID: int, packetType: PacketTypes.PacketType) -> None: ...

  @overload
  def sendSwitchSeat(self, vehicle: BaseVehicle, character: IsoGameCharacter, seatFrom: int, seatTo: int) -> None: ...

  @overload
  def sendSwitchSeat(self, connection: UdpConnection, vehicle: BaseVehicle, character: IsoGameCharacter, seatFrom: int, seatTo: int) -> None: ...

  @overload
  def sendTowing(self, vehicleA: BaseVehicle, vehicleB: BaseVehicle, attachmentA: str, attachmentB: str) -> None: ...

  @overload
  def sendTowing(self, connection: UdpConnection, vehicleA: BaseVehicle, vehicleB: BaseVehicle, attachmentA: str, attachmentB: str) -> None: ...

  def serverPacket(self, bb: ByteBuffer, connection: UdpConnection, type: int) -> None: ...

  def serverSendInitialWorldState(self, connection: UdpConnection) -> None: ...

  def serverUpdate(self) -> None: ...

  def unregisterVehicle(self, vehicle: BaseVehicle) -> None: ...

  @staticmethod
  def sendSound(vehicle: BaseVehicle, id: int) -> None: ...

  @staticmethod
  def sendSoundFromServer(vehicle: BaseVehicle, soundId: int) -> None: ...

  def __init__(self):
    self.connected: list[UdpConnection]

  class PosUpdateVars:

    def __init__(self): ...

  class VehiclePacket:

    AddImpulse: int

    Collide: int

    Config: int

    DetachTowingCar: int

    Enter: int

    Exit: int

    InitialWorldState: int

    PassengerPosition: int

    Physic: int

    Remove: int

    RequestGetFull: int

    RequestGetPosition: int

    Sound: int

    Sound_Crash: int

    SwitchSeat: int

    TowingCar: int

    Update: int

    def __init__(self): ...


class VehicleModelCamera(ModelCamera):

  instance: VehicleModelCamera

  def Begin(self) -> None: ...

  def End(self) -> None: ...

  def __init__(self): ...


class VehiclePart:

  @overload
  def AddDeviceText(self, line: str, r: float, g: float, b: float, guid: str, codes: str, distance: int) -> None: ...

  @overload
  def AddDeviceText(self, line: str, r: float, g: float, b: float, guid: str, codes: str, distance: int) -> None: ...

  @overload
  def AddDeviceText(self, arg0: IsoPlayer, arg1: str, arg2: float, arg3: float, arg4: float, arg5: str, arg6: str, arg7: int) -> None: ...

  @overload
  def HasPlayerInRange(self) -> bool: ...

  @overload
  def HasPlayerInRange(self) -> bool: ...

  def addChild(self, child: VehiclePart) -> None: ...

  def createSignalDevice(self) -> DeviceData: ...

  def createSpotLight(self, xOffset: float, yOffset: float, dist: float, intensity: float, dot: float, focusing: int) -> None: ...

  def damage(self, amount: int) -> None: ...

  def doInventoryItemStats(self, newItem: InventoryItem, mechanicSkill: int) -> None: ...

  def findWindow(self) -> VehicleWindow: ...

  def getAnimById(self, id: str) -> VehicleScript.Anim: ...

  def getArea(self) -> str: ...

  def getCategory(self) -> str: ...

  def getChatElement(self) -> ChatElement: ...

  def getChild(self, index: int) -> VehiclePart: ...

  def getChildCount(self) -> int: ...

  def getChildWindow(self) -> VehiclePart: ...

  def getCondition(self) -> int: ...

  @overload
  def getContainerCapacity(self) -> int: ...

  @overload
  def getContainerCapacity(self, chr: IsoGameCharacter) -> int: ...

  def getContainerContentAmount(self) -> float: ...

  def getContainerContentType(self) -> str: ...

  def getContainerSeatNumber(self) -> int: ...

  @overload
  def getDelta(self) -> float: ...

  @overload
  def getDelta(self) -> float: ...

  @overload
  def getDeviceData(self) -> DeviceData: ...

  @overload
  def getDeviceData(self) -> DeviceData: ...

  def getDoor(self) -> VehicleDoor: ...

  def getEngineLoudness(self) -> float: ...

  def getId(self) -> str: ...

  def getIndex(self) -> int: ...

  def getInventoryItem(self) -> InventoryItem: ...

  def getItemContainer(self) -> ItemContainer: ...

  def getItemType(self) -> ArrayList[str]: ...

  def getLastUpdated(self) -> float: ...

  def getLight(self) -> VehicleLight: ...

  def getLightDistance(self) -> float: ...

  def getLightFocusing(self) -> float: ...

  def getLightIntensity(self) -> float: ...

  def getLuaFunction(self, name: str) -> str: ...

  def getMechanicSkillInstaller(self) -> int: ...

  def getModData(self) -> KahluaTable: ...

  def getParent(self) -> VehiclePart: ...

  def getScriptPart(self) -> VehicleScript.Part: ...

  @overload
  def getSquare(self) -> IsoGridSquare: ...

  @overload
  def getSquare(self) -> IsoGridSquare: ...

  @overload
  def getSquare(self) -> IsoGridSquare: ...

  def getSuspensionCompression(self) -> float: ...

  def getSuspensionDamping(self) -> float: ...

  def getTable(self, id: str) -> KahluaTable: ...

  def getVehicle(self) -> BaseVehicle: ...

  def getWheelFriction(self) -> float: ...

  def getWheelIndex(self) -> int: ...

  def getWindow(self) -> VehicleWindow: ...

  @overload
  def getX(self) -> float: ...

  @overload
  def getX(self) -> float: ...

  @overload
  def getX(self) -> float: ...

  @overload
  def getY(self) -> float: ...

  @overload
  def getY(self) -> float: ...

  @overload
  def getY(self) -> float: ...

  @overload
  def getZ(self) -> float: ...

  @overload
  def getZ(self) -> float: ...

  @overload
  def getZ(self) -> float: ...

  def hasDevicePower(self) -> bool: ...

  def hasModData(self) -> bool: ...

  def isContainer(self) -> bool: ...

  def isInventoryItemUninstalled(self) -> bool: ...

  def isSetAllModelsVisible(self) -> bool: ...

  def isSpecificItem(self) -> bool: ...

  def load(self, input: ByteBuffer, WorldVersion: int) -> None: ...

  def repair(self) -> None: ...

  def save(self, output: ByteBuffer) -> None: ...

  def setAllModelsVisible(self, visible: bool) -> None: ...

  def setCategory(self, category: str) -> None: ...

  def setCondition(self, condition: int) -> None: ...

  def setContainerCapacity(self, cap: int) -> None: ...

  @overload
  def setContainerContentAmount(self, amount: float) -> None: ...

  @overload
  def setContainerContentAmount(self, amount: float, force: bool, noUpdateMass: bool) -> None: ...

  @overload
  def setDelta(self, d: float) -> None: ...

  @overload
  def setDelta(self, d: float) -> None: ...

  @overload
  def setDeviceData(self, data: DeviceData) -> None: ...

  @overload
  def setDeviceData(self, data: DeviceData) -> None: ...

  def setEngineLoudness(self, engineLoudness: float) -> None: ...

  def setGeneralCondition(self, item: InventoryItem, baseQuality: float, chanceToSpawnDamaged: float) -> None: ...

  @overload
  def setInventoryItem(self, item: InventoryItem) -> None: ...

  @overload
  def setInventoryItem(self, item: InventoryItem, mechanicSkill: int) -> None: ...

  def setItemContainer(self, container: ItemContainer) -> None: ...

  def setLastUpdated(self, hours: float) -> None: ...

  def setLightActive(self, active: bool) -> None: ...

  def setMechanicSkillInstaller(self, mechanicSkillInstaller: int) -> None: ...

  def setModelVisible(self, id: str, visible: bool) -> None: ...

  def setRandomCondition(self, item: InventoryItem) -> None: ...

  def setScriptPart(self, scriptPart: VehicleScript.Part) -> None: ...

  def setSpecificItem(self, specificItem: bool) -> None: ...

  def setSuspensionCompression(self, suspensionCompression: float) -> None: ...

  def setSuspensionDamping(self, suspensionDamping: float) -> None: ...

  def setWheelFriction(self, wheelFriction: float) -> None: ...

  def updateSignalDevice(self) -> None: ...

  @staticmethod
  def getNumberByCondition(number: float, cond: float, min: float) -> float: ...

  def __init__(self, vehicle: BaseVehicle): ...


class VehicleType:

  specialVehicles: ArrayList[VehicleType]

  vehicles: HashMap[str, VehicleType]

  def getBaseVehicleQuality(self) -> float: ...

  def getChanceToSpawnKey(self) -> int: ...

  def getRandomBaseVehicleQuality(self) -> float: ...

  def setChanceToSpawnKey(self, chanceToSpawnKey: int) -> None: ...

  @staticmethod
  def Reset() -> None: ...

  @staticmethod
  @overload
  def getRandomVehicleType(zoneName: str) -> VehicleType: ...

  @staticmethod
  @overload
  def getRandomVehicleType(zoneName: str, doNormalWhenSpecific: Boolean) -> VehicleType: ...

  @staticmethod
  def getTypeFromName(name: str) -> VehicleType: ...

  @staticmethod
  def hasTypeForZone(zoneName: str) -> bool: ...

  @staticmethod
  def init() -> None: ...

  def __init__(self, name: str):
    self.basevehiclequality: float
    self.chanceofovercar: int
    self.chancetopartdamage: int
    self.chancetospawnburnt: int
    self.chancetospawnnormal: int
    self.chancetospawnspecial: int
    self.isburntcar: bool
    self.isspecialcar: bool
    self.name: str
    self.randomangle: bool
    self.spawnrate: int
    self.vehiclesdefinition: ArrayList[VehicleType.VehicleTypeDefinition]

  class VehicleTypeDefinition:

    def __init__(self, vehicleType: str, index: int, spawnChance: float):
      self.index: int
      self.spawnchance: float
      self.vehicletype: str


class VehicleWindow:

  def damage(self, amount: int) -> None: ...

  def getHealth(self) -> int: ...

  def getOpenDelta(self) -> float: ...

  def hit(self, chr: IsoGameCharacter) -> None: ...

  def init(self, scriptWindow: VehicleScript.Window) -> None: ...

  def isDestroyed(self) -> bool: ...

  def isHittable(self) -> bool: ...

  def isOpen(self) -> bool: ...

  def isOpenable(self) -> bool: ...

  def load(self, input: ByteBuffer, WorldVersion: int) -> None: ...

  def save(self, output: ByteBuffer) -> None: ...

  def setHealth(self, health: int) -> None: ...

  def setOpen(self, open: bool) -> None: ...

  def setOpenDelta(self, delta: float) -> None: ...


class VehiclesDB2:

  instance: VehiclesDB2

  INVALID_ID: int

  def Reset(self) -> None: ...

  def addVehicle(self, vehicle: BaseVehicle) -> None: ...

  def importPlayersFromOldDB(self, consumer: VehiclesDB2.IImportPlayerFromOldDB) -> None: ...

  def init(self) -> None: ...

  def isChunkSeen(self, wx: int, wy: int) -> bool: ...

  def isVehicleLoaded(self, vehicle: BaseVehicle) -> bool: ...

  def loadChunk(self, chunk: IsoChunk) -> None: ...

  def loadChunkMain(self, chunk: IsoChunk) -> None: ...

  def removeVehicle(self, vehicle: BaseVehicle) -> None: ...

  def renderDebug(self, renderer: ZombiePopulationRenderer) -> None: ...

  def setChunkSeen(self, wx: int, wy: int) -> None: ...

  def setForceSave(self) -> None: ...

  def setVehicleLoaded(self, vehicle: BaseVehicle) -> None: ...

  def setVehicleUnloaded(self, vehicle: BaseVehicle) -> None: ...

  def unloadChunk(self, chunk: IsoChunk) -> None: ...

  def updateMain(self) -> None: ...

  def updateVehicle(self, vehicle: BaseVehicle) -> None: ...

  def updateVehicleAndTrailer(self, vehicle: BaseVehicle) -> None: ...

  def updateWorldStreamer(self) -> None: ...

  def __init__(self): ...

  class MainThread: ...

  class WorldStreamerThread: ...

  class IVehicleStore: ...

  class QueueItem(PooledObject): ...

  class SQLStore(VehiclesDB2.IVehicleStore): ...

  class IImportPlayerFromOldDB:

    def accept(self, sqlId: int, name: str, wx: int, wy: int, x: float, y: float, z: float, WorldVersion: int, bb: list[int], bDead: bool) -> None: ...

  class QueueUpdateVehicle(VehiclesDB2.QueueItem): ...

  class QueueRemoveVehicle(VehiclesDB2.QueueItem): ...

  class QueueLoadChunk(VehiclesDB2.QueueItem): ...

  class QueueAddVehicle(VehiclesDB2.QueueItem): ...

  class MemoryStore(VehiclesDB2.IVehicleStore): ...

  class ThrowingBiConsumer[T1, T2, E]:

    def accept(self, arg0: object, arg1: object) -> None: ...

  class ThrowingConsumer[T1, E]:

    def accept(self, arg0: object) -> None: ...

  class VehicleBuffer: ...


class test_IsQuadranglesAreTransposed(Assert):

  def testIsQuadranglesAreTransposed_1(self) -> None: ...

  def testIsQuadranglesAreTransposed_10(self) -> None: ...

  def testIsQuadranglesAreTransposed_11(self) -> None: ...

  def testIsQuadranglesAreTransposed_12(self) -> None: ...

  def testIsQuadranglesAreTransposed_13(self) -> None: ...

  def testIsQuadranglesAreTransposed_14(self) -> None: ...

  def testIsQuadranglesAreTransposed_2(self) -> None: ...

  def testIsQuadranglesAreTransposed_3(self) -> None: ...

  def testIsQuadranglesAreTransposed_4(self) -> None: ...

  def testIsQuadranglesAreTransposed_5(self) -> None: ...

  def testIsQuadranglesAreTransposed_6(self) -> None: ...

  def testIsQuadranglesAreTransposed_7(self) -> None: ...

  def testIsQuadranglesAreTransposed_8(self) -> None: ...

  def testIsQuadranglesAreTransposed_9(self) -> None: ...

  def __init__(self): ...


class test_VehicleCache(Assert):

  def test_getInsertIndex(self) -> None: ...

  def __init__(self): ...


class testall_vehicles:

  def __init__(self): ...

