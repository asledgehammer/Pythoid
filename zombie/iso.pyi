from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from gnu.trove.list.array import TShortArrayList, TIntArrayList
from gnu.trove.map.hash import TLongObjectHashMap
from java.awt import Dimension, Point
from java.io import DataOutputStream, ObjectOutputStream, RandomAccessFile, InputStream
from java.lang import Enum, Integer, Double, Thread, Float, Boolean, Class
from java.nio import ByteBuffer, FloatBuffer
from java.util import ArrayList, HashSet, ArrayDeque, HashMap, Stack, List, Set, Comparator
from java.util.concurrent import ConcurrentLinkedQueue
from java.util.concurrent.locks import ReentrantReadWriteLock, ReentrantLock
from java.util.function import Consumer, Function, ToDoubleFunction, ToIntFunction, ToLongFunction, BiConsumer, Predicate
from java.util.zip import CRC32
from org.joml import Vector2f, Vector2i, Vector4f
from org.junit import Assert
from se.krka.kahlua.j2se import KahluaTableImpl
from se.krka.kahlua.vm import KahluaTable
from zombie import FliesSound, WorldSoundManager, ZomboidBitFlag
from zombie.ai.astar import Mover
from zombie.audio import ObjectAmbientEmitters, BaseSoundEmitter
from zombie.characters import IsoGameCharacter, IsoZombie, IsoSurvivor, IsoPlayer, SurvivorDesc
from zombie.core.VBO import IGLBufferObject
from zombie.core.network import ByteBufferWriter
from zombie.core.opengl import Shader, SharedVertexBufferObjects
from zombie.core.profiling import PerformanceProfileProbe
from zombie.core.properties import PropertyContainer
from zombie.core.raknet import UdpConnection, UdpEngine
from zombie.core.textures import TextureDraw, Texture, ColorInfo
from zombie.core.utils import OnceEvery, IntGrid, BoundedQueue
from zombie.erosion import ErosionData
from zombie.interfaces import ITexture
from zombie.inventory import InventoryItem, ItemContainer
from zombie.inventory.types import HandWeapon
from zombie.iso.SpriteDetails import IsoObjectType, IsoFlagType
from zombie.iso.areas import IsoRoom, BuildingScore, IsoBuilding
from zombie.iso.areas.isoregion.regions import IWorldRegion, IsoWorldRegion
from zombie.iso.objects import IsoTree, IsoWorldInventoryObject, IsoWindow, IsoThumpable, IsoBrokenGlass, IsoDeadBody, IsoTrap, IsoCompost, IsoCurtain, IsoGenerator, IsoDoor, IsoRaindrop, IsoRainSplash, IsoLightSwitch, IsoMannequin, ObjectRenderEffects, RenderEffectType
from zombie.iso.objects.interfaces import Thumpable
from zombie.iso.sprite import IsoSprite, IsoSpriteManager, IsoSpriteInstance, SkyBox
from zombie.iso.sprite.shapers import WallShaperWhole
from zombie.iso.weather import ClimateManager
from zombie.iso.weather.fx import IsoWeatherFX
from zombie.network import ClientChunkRequest
from zombie.popman import ObjectPool
from zombie.randomizedWorld.randomizedBuilding import RandomizedBuildingBase
from zombie.randomizedWorld.randomizedVehicleStory import VehicleStorySpawnData, RandomizedVehicleStoryBase
from zombie.randomizedWorld.randomizedZoneStory import RandomizedZoneStoryBase
from zombie.ui import ObjectTooltip
from zombie.util import BufferedRandomAccessFile, AddCoopPlayer
from zombie.util.list import PZArrayList
from zombie.vehicles import BaseVehicle, VehicleType, CollideWithObstaclesPoly

U = TypeVar('U', default=Any)
T = TypeVar('T', default=Any)
E = TypeVar('E', default=Any)

class Alarm:

  def update(self) -> None: ...

  def __init__(self, x: int, y: int):
    self.finished: bool


class BentFences:

  def Reset(self) -> None: ...

  def addFenceTiles(self, VERSION: int, tiles: KahluaTableImpl) -> None: ...

  def bendFence(self, obj: IsoObject, dir: IsoDirections) -> None: ...

  def isBentObject(self, obj: IsoObject) -> bool: ...

  def isUnbentObject(self, obj: IsoObject) -> bool: ...

  def swapTiles(self, obj: IsoObject, dir: IsoDirections) -> None: ...

  def unbendFence(self, obj: IsoObject) -> None: ...

  @staticmethod
  def getInstance() -> BentFences: ...

  def __init__(self): ...

  class Entry: ...


class BrokenFences:

  def Reset(self) -> None: ...

  def addBrokenTiles(self, tiles: KahluaTableImpl) -> None: ...

  def addDebrisTiles(self, tiles: KahluaTableImpl) -> None: ...

  def destroyFence(self, obj: IsoObject, dir: IsoDirections) -> None: ...

  def isBreakableObject(self, obj: IsoObject) -> bool: ...

  def setDamagedLeft(self, obj: IsoObject) -> None: ...

  def setDamagedRight(self, obj: IsoObject) -> None: ...

  def setDestroyed(self, obj: IsoObject) -> None: ...

  def updateSprite(self, obj: IsoObject, brokenLeft: bool, brokenRight: bool) -> None: ...

  @staticmethod
  def getInstance() -> BrokenFences: ...

  def __init__(self): ...

  class Tile: ...


class BuildingDef:

  def CalculateBounds(self, tempRooms: ArrayList[RoomDef]) -> None: ...

  def Dispose(self) -> None: ...

  def calculateMetaID(self, cellX: int, cellY: int) -> int: ...

  def containsRoom(self, name: str) -> bool: ...

  def getChunkX(self) -> int: ...

  def getChunkY(self) -> int: ...

  def getClosestPoint(self, x: float, y: float, closestXY: Vector2f) -> float: ...

  def getFirstRoom(self) -> RoomDef: ...

  def getFreeSquareInRoom(self) -> IsoGridSquare: ...

  def getH(self) -> int: ...

  def getID(self) -> int: ...

  def getKeyId(self) -> int: ...

  def getKeySpawned(self) -> int: ...

  def getRandomRoom(self, minArea: int) -> RoomDef: ...

  def getRoom(self, roomName: str) -> RoomDef: ...

  def getRooms(self) -> ArrayList[RoomDef]: ...

  def getTable(self) -> KahluaTable: ...

  def getW(self) -> int: ...

  def getX(self) -> int: ...

  def getX2(self) -> int: ...

  def getY(self) -> int: ...

  def getY2(self) -> int: ...

  def getZone(self) -> IsoMetaGrid.Zone: ...

  def isAlarmed(self) -> bool: ...

  def isAllExplored(self) -> bool: ...

  def isAnyChunkNewlyLoaded(self) -> bool: ...

  def isFullyStreamedIn(self) -> bool: ...

  def isHasBeenVisited(self) -> bool: ...

  def overlapsChunk(self, wx: int, wy: int) -> bool: ...

  def recalculate(self) -> None: ...

  def refreshSquares(self) -> None: ...

  def setAlarmed(self, alarm: bool) -> None: ...

  def setAllExplored(self, b: bool) -> None: ...

  def setHasBeenVisited(self, hasBeenVisited: bool) -> None: ...

  def setKeyId(self, keyId: int) -> None: ...

  def setKeySpawned(self, keySpawned: int) -> None: ...

  def __init__(self):
    self.balarmed: bool
    self.emptyoutside: ArrayList[RoomDef]
    self.food: int
    self.hasbeenvisited: bool
    self.items: ArrayList[InventoryItem]
    self.itemtypes: HashSet[str]
    self.lootrespawnhour: int
    self.metaid: int
    self.overlappedchunks: TShortArrayList
    self.rooms: ArrayList[RoomDef]
    self.seen: bool
    self.stash: str
    self.table: KahluaTable
    self.x: int
    self.x2: int
    self.y: int
    self.y2: int
    self.zone: IsoMetaGrid.Zone


class CellLoader:

  isoObjectCache: ArrayDeque[IsoObject]

  isoTreeCache: ArrayDeque[IsoTree]

  smashedWindowSpriteMap: HashMap[IsoSprite, IsoSprite]

  @staticmethod
  def DoTileObjectCreation(spr: IsoSprite, type: IsoObjectType, sq: IsoGridSquare, cell: IsoCell, x: int, y: int, height: int, name: str) -> None: ...

  @staticmethod
  @overload
  def LoadCellBinaryChunk(spr: IsoSpriteManager, wx: int, wy: int) -> IsoCell: ...

  @staticmethod
  @overload
  def LoadCellBinaryChunk(cell: IsoCell, wx: int, wy: int, chunk: IsoChunk) -> bool: ...

  def __init__(self): ...


class ChunkSaveWorker:

  instance: ChunkSaveWorker

  def Add(self, ch: IsoChunk) -> None: ...

  @overload
  def SaveNow(self) -> None: ...

  @overload
  def SaveNow(self, aboutToLoad: ArrayList[IsoChunk]) -> None: ...

  def Update(self, aboutToLoad: IsoChunk) -> None: ...

  def __init__(self):
    self.bsaving: bool
    self.tosavequeue: ConcurrentLinkedQueue[IsoChunk]


class ContainerOverlays:

  instance: ContainerOverlays

  def Reset(self) -> None: ...

  def addOverlays(self, overlayMap: KahluaTableImpl) -> None: ...

  def hasOverlays(self, obj: IsoObject) -> bool: ...

  def updateContainerOverlaySprite(self, obj: IsoObject) -> None: ...

  def __init__(self): ...

  class ContainerOverlay:

    def getEntries(self, arg0: str, arg1: ArrayList[ContainerOverlays.ContainerOverlayEntry]) -> None: ...

    def pickRandom(self, arg0: str, arg1: int, arg2: int, arg3: int) -> ContainerOverlays.ContainerOverlayEntry: ...

  class ContainerOverlayEntry: ...


class DiamondMatrixIterator:

  def i2line(self, a: int) -> Vector2i: ...

  def line2coord(self, a: Vector2i) -> Vector2i: ...

  def next(self, vec: Vector2i) -> bool: ...

  @overload
  def reset(self) -> None: ...

  @overload
  def reset(self, size: int) -> DiamondMatrixIterator: ...

  def __init__(self, size: int): ...


class FireShader(Shader):

  def updateFireParams(self, texd: TextureDraw, userId: int, in_firetime: float) -> None: ...

  def __init__(self, name: str): ...


class Helicopter:

  def clientSync(self, x: float, y: float, active: bool) -> None: ...

  def deactivate(self) -> None: ...

  def isActive(self) -> bool: ...

  def pickRandomTarget(self) -> None: ...

  def setTarget(self, chr: IsoGameCharacter) -> None: ...

  def update(self) -> None: ...

  def __init__(self):
    self.target: IsoGameCharacter
    self.x: float
    self.y: float

  class State(Enum):

    Arriving: Helicopter.State

    Hovering: Helicopter.State

    Leaving: Helicopter.State

    Searching: Helicopter.State

    @staticmethod
    def valueOf(arg0: str) -> Helicopter.State: ...

    @staticmethod
    def values() -> list[Helicopter.State]: ...


class IsoCamera:

  CamCharacter: IsoGameCharacter

  cameras: list[PlayerCamera]

  FakePos: Vector2

  FakePosVec: Vector2

  frameState: IsoCamera.FrameState

  PLAYER_OFFSET_X: int

  PLAYER_OFFSET_Y: int

  TargetTileX: int

  TargetTileY: int

  @staticmethod
  def SetCharacterToFollow(GameChar: IsoGameCharacter) -> None: ...

  @staticmethod
  def getCamCharacter() -> IsoGameCharacter: ...

  @staticmethod
  def getFakePos() -> Vector2: ...

  @staticmethod
  def getFakePosVec() -> Vector2: ...

  @staticmethod
  def getLastOffX() -> float: ...

  @staticmethod
  def getLastOffY() -> float: ...

  @staticmethod
  def getOffX() -> float: ...

  @staticmethod
  def getOffY() -> float: ...

  @staticmethod
  def getOffscreenHeight(playerIndex: int) -> int: ...

  @staticmethod
  def getOffscreenLeft(playerIndex: int) -> int: ...

  @staticmethod
  def getOffscreenTop(playerIndex: int) -> int: ...

  @staticmethod
  def getOffscreenWidth(playerIndex: int) -> int: ...

  @staticmethod
  def getRightClickOffX() -> float: ...

  @staticmethod
  def getRightClickOffY() -> float: ...

  @staticmethod
  def getScreenHeight(playerIndex: int) -> int: ...

  @staticmethod
  def getScreenLeft(playerIndex: int) -> int: ...

  @staticmethod
  def getScreenTop(playerIndex: int) -> int: ...

  @staticmethod
  def getScreenWidth(playerIndex: int) -> int: ...

  @staticmethod
  def getTOffX() -> float: ...

  @staticmethod
  def getTOffY() -> float: ...

  @staticmethod
  def getTargetTileX() -> int: ...

  @staticmethod
  def getTargetTileY() -> int: ...

  @staticmethod
  def init() -> None: ...

  @staticmethod
  def setCamCharacter(aCamCharacter: IsoGameCharacter) -> None: ...

  @staticmethod
  def setFakePos(aFakePos: Vector2) -> None: ...

  @staticmethod
  def setFakePosVec(aFakePosVec: Vector2) -> None: ...

  @staticmethod
  def setLastOffX(aLastOffX: float) -> None: ...

  @staticmethod
  def setLastOffY(aLastOffY: float) -> None: ...

  @staticmethod
  def setOffX(aOffX: float) -> None: ...

  @staticmethod
  def setOffY(aOffY: float) -> None: ...

  @staticmethod
  def setTargetTileX(aTargetTileX: int) -> None: ...

  @staticmethod
  def setTargetTileY(aTargetTileY: int) -> None: ...

  @staticmethod
  def update() -> None: ...

  @staticmethod
  def updateAll() -> None: ...

  def __init__(self): ...

  class FrameState:

    def set(self, playerIndex: int) -> None: ...

    def __init__(self):
      self.camcharacter: IsoGameCharacter
      self.camcharacterroom: IsoRoom
      self.camcharactersquare: IsoGridSquare
      self.camcharacterx: float
      self.camcharactery: float
      self.camcharacterz: float
      self.framecount: int
      self.offscreenheight: int
      self.offscreenwidth: int
      self.offx: float
      self.offy: float
      self.paused: bool
      self.playerindex: int


class IsoCell:

  ENABLE_SQUARE_CACHE: bool

  ISOANGLEFACTOR: int

  MaxHeight: int

  perPlayerRender: list[IsoCell.PerPlayerRender]

  RTF_MinusFloorCharacters: int

  RTF_ShadedFloor: int

  RTF_Shadows: int

  RTF_SolidFloor: int

  RTF_VegetationCorpses: int

  def CalculateVertColoursForTile(self, sqThis: IsoGridSquare, x: int, y: int, zz: int, playerIndex: int) -> None: ...

  def CanBuildingSquareOccludePlayer(self, square: IsoGridSquare, playerIndex: int) -> bool: ...

  def ConnectNewSquare(self, newSquare: IsoGridSquare, bDoSurrounds: bool) -> IsoGridSquare: ...

  def DeleteAllMovingObjects(self) -> None: ...

  def Dispose(self) -> None: ...

  def DistanceFromSupport(self, x: int, y: int, z: int) -> float: ...

  def DoBuilding(self, player: int, bRender: bool) -> bool: ...

  def DoGridNav(self, newSquare: IsoGridSquare, getter: IsoGridSquare.GetSquare) -> None: ...

  def DrawStencilMask(self) -> None: ...

  def EnsureSurroundNotNull(self, xx: int, yy: int, zz: int) -> None: ...

  def GetEffectivePlayerRoomId(self) -> int: ...

  def IsPlayerWindowPeeking(self, playerIndex: int) -> bool: ...

  def LoadPlayer(self, WorldVersion: int) -> bool: ...

  @overload
  def PlaceLot(self, filename: str, sx: int, sy: int, sz: int, bClearExisting: bool) -> None: ...

  @overload
  def PlaceLot(self, lot: IsoLot, sx: int, sy: int, sz: int, bClearExisting: bool) -> None: ...

  @overload
  def PlaceLot(self, lot: IsoLot, sx: int, sy: int, sz: int, ch: IsoChunk, WX: int, WY: int) -> None: ...

  def ProcessSpottedRooms(self) -> None: ...

  def Remove(self, obj: IsoMovingObject) -> None: ...

  def RenderFloorShading(self, zza: int) -> None: ...

  def RenderTiles(self, MaxHeight: int) -> None: ...

  def addHeatSource(self, heatSource: IsoHeatSource) -> None: ...

  @overload
  def addLamppost(self, light: IsoLightSource) -> None: ...

  @overload
  def addLamppost(self, x: int, y: int, z: int, r: float, g: float, b: float, rad: int) -> IsoLightSource: ...

  def addMovingObject(self, o: IsoMovingObject) -> None: ...

  def addToProcessIsoObject(self, object: IsoObject) -> None: ...

  def addToProcessIsoObjectRemove(self, object: IsoObject) -> None: ...

  @overload
  def addToProcessItems(self, items: ArrayList[InventoryItem]) -> None: ...

  @overload
  def addToProcessItems(self, item: InventoryItem) -> None: ...

  @overload
  def addToProcessItemsRemove(self, items: ArrayList[InventoryItem]) -> None: ...

  @overload
  def addToProcessItemsRemove(self, item: InventoryItem) -> None: ...

  def addToProcessWorldItems(self, worldItem: IsoWorldInventoryObject) -> None: ...

  def addToProcessWorldItemsRemove(self, worldItem: IsoWorldInventoryObject) -> None: ...

  def addToStaticUpdaterObjectList(self, object: IsoObject) -> None: ...

  def addToWindowList(self, window: IsoWindow) -> None: ...

  def blocked(self, mover: Mover, x: int, y: int, z: int, lx: int, ly: int, lz: int) -> bool: ...

  def checkHaveRoof(self, x: int, y: int) -> None: ...

  def clearCacheGridSquare(self, playerIndex: int) -> None: ...

  def createNewGridSquare(self, x: int, y: int, z: int, recalcAll: bool) -> IsoGridSquare: ...

  def getAddList(self) -> ArrayList[IsoMovingObject]: ...

  def getBestBuildings(self, criteria: IsoCell.BuildingSearchCriteria, count: int) -> Stack[BuildingScore]: ...

  def getBuildingList(self) -> ArrayList[IsoBuilding]: ...

  def getBuildingScores(self) -> HashMap[Integer, BuildingScore]: ...

  def getChunk(self, wx: int, wy: int) -> IsoChunk: ...

  def getChunkForGridSquare(self, x: int, y: int, z: int) -> IsoChunk: ...

  def getChunkMap(self, pl: int) -> IsoChunkMap: ...

  def getClosestBuildingExcept(self, chr: IsoGameCharacter, arg1: IsoRoom) -> IsoBuilding: ...

  def getCurrentLightX(self) -> int: ...

  def getCurrentLightY(self) -> int: ...

  def getCurrentLightZ(self) -> int: ...

  def getCurrentLotHeader(self) -> LotHeader: ...

  def getDangerScore(self, x: int, y: int) -> int: ...

  def getDangerUpdate(self) -> OnceEvery: ...

  def getDrag(self, player: int) -> KahluaTable: ...

  def getFakeZombieForHit(self) -> IsoZombie: ...

  def getFreeTile(self, arg0: RoomDef) -> IsoGridSquare: ...

  # @LuaMethod
  @overload
  def getGridSquare(self, x: float, y: float, z: float) -> IsoGridSquare: ...

  @overload
  def getGridSquare(self, x: int, y: int, z: int) -> IsoGridSquare: ...

  @overload
  def getGridSquare(self, x: Double, y: Double, z: Double) -> IsoGridSquare: ...

  def getGridSquareDirect(self, x: int, y: int, z: int, playerIndex: int) -> IsoGridSquare: ...

  def getHeatSourceHighestTemperature(self, surroundingAirTemperature: float, x: int, y: int, z: int) -> float: ...

  def getHeatSourceTemperature(self, x: int, y: int, z: int) -> int: ...

  def getHeight(self) -> int: ...

  def getHeightInTiles(self) -> int: ...

  def getLamppostPositions(self) -> Stack[IsoLightSource]: ...

  def getLightInfoUpdate(self) -> Thread: ...

  def getLightSourceAt(self, x: int, y: int, z: int) -> IsoLightSource: ...

  def getLuaObjectList(self) -> KahluaTable: ...

  # @LuaMethod
  def getMaxFloors(self) -> int: ...

  def getMaxX(self) -> int: ...

  def getMaxY(self) -> int: ...

  def getMaxZ(self) -> int: ...

  def getMinX(self) -> int: ...

  def getMinY(self) -> int: ...

  def getMinZ(self) -> int: ...

  def getNearestVisibleZombie(self, playerIndex: int) -> IsoZombie: ...

  def getNetworkPlayer(self, RemoteID: int) -> IsoSurvivor: ...

  def getObjectList(self) -> ArrayList[IsoMovingObject]: ...

  # @LuaMethod
  def getOrCreateGridSquare(self, x: float, y: float, z: float) -> IsoGridSquare: ...

  def getProcessIsoObjectRemove(self) -> ArrayList[IsoObject]: ...

  def getProcessIsoObjects(self) -> ArrayList[IsoObject]: ...

  def getProcessItems(self) -> ArrayList[InventoryItem]: ...

  def getProcessItemsRemove(self) -> ArrayList[InventoryItem]: ...

  def getProcessWorldItems(self) -> ArrayList[IsoWorldInventoryObject]: ...

  def getPushableObjectList(self) -> ArrayList[IsoPushableObject]: ...

  def getRandomFreeTileInRoom(self) -> IsoGridSquare: ...

  def getRandomOutdoorTile(self) -> IsoGridSquare: ...

  def getRelativeGridSquare(self, x: int, y: int, z: int) -> IsoGridSquare: ...

  def getRemoteSurvivorList(self) -> ArrayList[IsoGameCharacter]: ...

  def getRemoveList(self) -> ArrayList[IsoMovingObject]: ...

  def getRoom(self, ID: int) -> IsoRoom: ...

  def getRoomList(self) -> ArrayList[IsoRoom]: ...

  def getSpriteManager(self) -> IsoSpriteManager: ...

  def getStaticUpdaterObjectList(self) -> ArrayList[IsoObject]: ...

  def getStencilValue(self, x: int, y: int, z: int) -> int: ...

  def getStencilValue2z(self, x: int, y: int, z: int) -> int: ...

  def getSurvivorList(self) -> ArrayList[IsoSurvivor]: ...

  def getVehicles(self) -> ArrayList[BaseVehicle]: ...

  def getWeatherFX(self) -> IsoWeatherFX: ...

  def getWidth(self) -> int: ...

  def getWidthInTiles(self) -> int: ...

  def getWindowList(self) -> ArrayList[IsoWindow]: ...

  def getWorldX(self) -> int: ...

  def getWorldY(self) -> int: ...

  def getZombieList(self) -> ArrayList[IsoZombie]: ...

  def gridSquareIsSnow(self, x: int, y: int, z: int) -> bool: ...

  def invalidatePeekedRoom(self, playerIndex: int) -> None: ...

  def isInChunkMap(self, x: int, y: int) -> bool: ...

  def isNull(self, x: int, y: int, z: int) -> bool: ...

  def isSafeToAdd(self) -> bool: ...

  def putInVehicle(self, chr: IsoGameCharacter) -> None: ...

  def reloadRainTextures(self) -> None: ...

  def removeFromWindowList(self, window: IsoWindow) -> None: ...

  def removeHeatSource(self, heatSource: IsoHeatSource) -> None: ...

  @overload
  def removeLamppost(self, light: IsoLightSource) -> None: ...

  @overload
  def removeLamppost(self, x: int, y: int, z: int) -> None: ...

  def render(self) -> None: ...

  def resumeVehicleSounds(self, chr: IsoGameCharacter) -> None: ...

  def roomSpotted(self, room: IsoRoom) -> None: ...

  def save(self, output: DataOutputStream, bDoChars: bool) -> None: ...

  def savePlayer(self) -> None: ...

  @overload
  def setCacheChunk(self, chunk: IsoChunk) -> None: ...

  @overload
  def setCacheChunk(self, chunk: IsoChunk, playerIndex: int) -> None: ...

  def setCacheGridSquare(self, x: int, y: int, z: int, square: IsoGridSquare) -> None: ...

  def setCacheGridSquareLocal(self, x: int, y: int, z: int, square: IsoGridSquare, playerIndex: int) -> None: ...

  def setCurrentLightX(self, currentLX: int) -> None: ...

  def setCurrentLightY(self, currentLY: int) -> None: ...

  def setCurrentLightZ(self, currentLZ: int) -> None: ...

  def setDangerUpdate(self, dangerUpdate: OnceEvery) -> None: ...

  def setDrag(self, item: KahluaTable, player: int) -> None: ...

  def setHeight(self, height: int) -> None: ...

  def setLightInfoUpdate(self, LightInfoUpdate: Thread) -> None: ...

  def setMaxX(self, maxX: int) -> None: ...

  def setMaxY(self, maxY: int) -> None: ...

  def setMaxZ(self, maxZ: int) -> None: ...

  def setMinX(self, minX: int) -> None: ...

  def setMinY(self, minY: int) -> None: ...

  def setMinZ(self, minZ: int) -> None: ...

  def setRainAlpha(self, alpha: int) -> None: ...

  def setRainIntensity(self, intensity: int) -> None: ...

  def setRainSpeed(self, speed: int) -> None: ...

  def setSafeToAdd(self, safeToAdd: bool) -> None: ...

  def setSnowTarget(self, target: int) -> None: ...

  def setStencilValue(self, x: int, y: int, z: int, stencil: int) -> None: ...

  def setStencilValue2z(self, x: int, y: int, z: int, stencil: int) -> None: ...

  def setWidth(self, width: int) -> None: ...

  def setWorldX(self, worldX: int) -> None: ...

  def setWorldY(self, worldY: int) -> None: ...

  def update(self) -> None: ...

  def updateHeatSources(self) -> None: ...

  @staticmethod
  def FromMouseTile() -> IsoDirections: ...

  @staticmethod
  def getBComponent(col: int) -> int: ...

  @staticmethod
  def getBuildings() -> Stack[BuildingScore]: ...

  @staticmethod
  def getGComponent(col: int) -> int: ...

  @staticmethod
  def getInstance() -> IsoCell: ...

  @staticmethod
  def getMaxHeight() -> int: ...

  @staticmethod
  def getRComponent(col: int) -> int: ...

  @staticmethod
  def setBuildings(scores: Stack[BuildingScore]) -> None: ...

  @staticmethod
  def toIntColor(r: float, g: float, b: float, a: float) -> int: ...

  def __init__(self, width: int, height: int):
    self.addvehicles: ArrayList[BaseVehicle]
    self.brendering: bool
    self.buildinglist: ArrayList[IsoBuilding]
    self.chunkmap: list[IsoChunkMap]
    self.dangerscore: IntGrid
    self.deferredcharactertick: int
    self.processworlditemsremove: ArrayList[IsoWorldInventoryObject]
    self.recalcfloors: bool
    self.roomlights: ArrayList[IsoRoomLight]
    self.stencilx1: int
    self.stencilx2: int
    self.stencily1: int
    self.stencily2: int
    self.trees: ArrayList[IsoGridSquare]
    self.vehicles: ArrayList[BaseVehicle]

  class PerPlayerRender:

    def setSize(self, w: int, h: int) -> None: ...

    def __init__(self):
      self.flattengrassetc: list[list[bool]]
      self.gridstacks: IsoGridStack
      self.maxx: int
      self.maxy: int
      self.minx: int
      self.miny: int
      self.stencilvalues: list[list[list[int]]]
      self.visiculledflags: list[list[bool]]
      self.visioccludedflags: list[list[list[bool]]]

  class s_performance:

    class renderTiles:

      class PperformRenderTilesLayer(PerformanceProfileProbe): ...

  class SnowGrid:

    A: int

    B: int

    E: int

    N: int

    S: int

    W: int

    def check(self, arg0: int, arg1: int) -> bool: ...

    def checkAny(self, arg0: int, arg1: int) -> bool: ...

    def init(self, arg0: int) -> IsoCell.SnowGrid: ...

    def set(self, arg0: int, arg1: int, arg2: int, arg3: IsoCell.SnowGridTiles) -> None: ...

    def subtract(self, arg0: IsoCell.SnowGrid) -> None: ...

    def __init__(self, arg0: IsoCell, arg1: int):
      self.frac: int
      self.grid: list[list[list[Texture]]]
      self.gridtype: list[list[list[int]]]
      self.h: int
      self.w: int

  class SnowGridTiles:

    def __init__(self, arg0: IsoCell, arg1: int): ...

  class BuildingSearchCriteria(Enum):

    Defense: IsoCell.BuildingSearchCriteria

    Food: IsoCell.BuildingSearchCriteria

    General: IsoCell.BuildingSearchCriteria

    Weapons: IsoCell.BuildingSearchCriteria

    Wood: IsoCell.BuildingSearchCriteria

    @staticmethod
    def valueOf(arg0: str) -> IsoCell.BuildingSearchCriteria: ...

    @staticmethod
    def values() -> list[IsoCell.BuildingSearchCriteria]: ...


class IsoChunk:

  bDoServerRequests: bool

  loadGridSquare: ConcurrentLinkedQueue[IsoChunk]

  renderByIndex: list[list[int]]

  WriteLock: object

  def AddBlood(self, wx: int, wy: int) -> None: ...

  def AddCorpses(self, wx: int, wy: int) -> None: ...

  def AddVehicles(self) -> None: ...

  def Blam(self, wx: int, wy: int) -> None: ...

  def LoadBrandNew(self, wx: int, wy: int) -> bool: ...

  def LoadFromBuffer(self, wx: int, wy: int, bb: ByteBuffer) -> bool: ...

  def LoadFromDisk(self) -> None: ...

  def LoadFromDiskOrBuffer(self, bb: ByteBuffer) -> None: ...

  def LoadOrCreate(self, wx: int, wy: int, fromServer: ByteBuffer) -> bool: ...

  def RandomizeModel(self, v: BaseVehicle, zone: IsoMetaGrid.Zone, name: str, type: VehicleType) -> bool: ...

  @overload
  def Save(self, bSaveQuit: bool) -> None: ...

  @overload
  def Save(self, bb: ByteBuffer, crc: CRC32) -> ByteBuffer: ...

  def SaveLoadedChunk(self, ccrc: ClientChunkRequest.Chunk, crc32: CRC32) -> None: ...

  def addBloodSplat(self, x: float, y: float, z: float, Type: int) -> None: ...

  def addGeneratorPos(self, x: int, y: int, z: int) -> None: ...

  def addObjectAmbientEmitter(self, object: IsoObject, logic: ObjectAmbientEmitters.PerObjectLogic) -> None: ...

  def addRandomCarCrash(self, zone: IsoMetaGrid.Zone, addToWorld: bool) -> None: ...

  def addSpawnedRoom(self, roomID: int) -> None: ...

  def addSurvivorInHorde(self, forced: bool) -> None: ...

  def canAddRandomCarCrash(self, zone: IsoMetaGrid.Zone, force: bool) -> bool: ...

  def checkForMissingGenerators(self) -> None: ...

  def doLoadGridsquare(self) -> None: ...

  def doReuseGridsquares(self) -> None: ...

  def getErosionData(self) -> ErosionData.Chunk: ...

  def getGridSquare(self, x: int, y: int, z: int) -> IsoGridSquare: ...

  def getHashCodeObjects(self) -> int: ...

  def getNumberOfWaterTiles(self) -> int: ...

  def getRoom(self, roomID: int) -> IsoRoom: ...

  def getScavengeZone(self) -> IsoMetaGrid.Zone: ...

  def hasObjectAmbientEmitter(self, object: IsoObject) -> bool: ...

  def hashCodeNoOverride(self) -> int: ...

  def isGeneratorPoweringSquare(self, x: int, y: int, z: int) -> bool: ...

  def isNewChunk(self) -> bool: ...

  def isSpawnedRoom(self, roomID: int) -> bool: ...

  def loadInMainThread(self) -> None: ...

  def loadInWorldStreamerThread(self) -> None: ...

  def loadObjectState(self, bb: ByteBuffer) -> None: ...

  def recalcHashCodeObjects(self) -> None: ...

  def recalcNeighboursNow(self) -> None: ...

  def removeFromWorld(self) -> None: ...

  def removeGeneratorPos(self, x: int, y: int, z: int) -> None: ...

  def removeObjectAmbientEmitter(self, object: IsoObject) -> None: ...

  def resetForStore(self) -> None: ...

  def saveObjectState(self, bb: ByteBuffer) -> bool: ...

  def setCache(self) -> None: ...

  def setCacheIncludingNull(self) -> None: ...

  def setRandomVehicleStoryToSpawnLater(self, spawnData: VehicleStorySpawnData) -> None: ...

  def setSquare(self, x: int, y: int, z: int, square: IsoGridSquare) -> None: ...

  def update(self) -> None: ...

  def updateBuildings(self) -> None: ...

  def updateSounds(self) -> None: ...

  def updateVehicleStory(self) -> None: ...

  @staticmethod
  def FileExists(wx: int, wy: int) -> bool: ...

  @staticmethod
  @overload
  def Fix2x(tileName: str) -> str: ...

  @staticmethod
  @overload
  def Fix2x(square: IsoGridSquare, spriteID: int) -> int: ...

  @staticmethod
  def IsDebugSave() -> bool: ...

  @staticmethod
  def Reset() -> None: ...

  @staticmethod
  def SafeRead(prefix: str, wx: int, wy: int, bb: ByteBuffer) -> ByteBuffer: ...

  @staticmethod
  def SafeWrite(prefix: str, wx: int, wy: int, bb: ByteBuffer) -> None: ...

  @staticmethod
  def addFromCheckedVehicles(v: BaseVehicle) -> None: ...

  @staticmethod
  def doSpawnedVehiclesInInvalidPosition(v: BaseVehicle) -> bool: ...

  @staticmethod
  def removeFromCheckedVehicles(v: BaseVehicle) -> None: ...

  @staticmethod
  def updatePlayerInBullet() -> None: ...

  def __init__(self, cell: IsoCell):
    self.blightingneverdone: list[bool]
    self.bloaded: bool
    self.collision: CollideWithObstaclesPoly.ChunkData
    self.corpsedata: FliesSound.ChunkData
    self.floorbloodsplats: BoundedQueue[IsoFloorBloodSplat]
    self.floorbloodsplatsfade: ArrayList[IsoFloorBloodSplat]
    self.jobtype: IsoChunk.JobType
    self.lightcheck: list[bool]
    self.lootrespawnhour: int
    self.lotheader: LotHeader
    self.m_adjacentchunkloadedcounter: int
    self.m_loadvehiclesobject: object
    self.m_objectemitterdata: ObjectAmbientEmitters.ChunkData
    self.m_vehiclestoryspawndata: VehicleStorySpawnData
    self.maxlevel: int
    self.nearestwalls: NearestWalls.ChunkData
    self.next: IsoChunk
    self.objectssynccount: int
    self.randomid: int
    self.refs: ArrayList[IsoChunkMap]
    self.revision: int
    self.roomlights: ArrayList[IsoRoomLight]
    self.soundlist: ArrayList[WorldSoundManager.WorldSound]
    self.squares: list[list[IsoGridSquare]]
    self.vehicles: ArrayList[BaseVehicle]
    self.vehiclesforaddtoworld: ArrayList[BaseVehicle]
    self.vehiclesforaddtoworldlock: object
    self.wx: int
    self.wy: int

  class JobType(Enum):

    Convert: IsoChunk.JobType

    # None: IsoChunk.JobType

    SoftReset: IsoChunk.JobType

    @staticmethod
    def valueOf(arg0: str) -> IsoChunk.JobType: ...

    @staticmethod
    def values() -> list[IsoChunk.JobType]: ...

  class PhysicsShapes(Enum):

    Floor: IsoChunk.PhysicsShapes

    Solid: IsoChunk.PhysicsShapes

    Tree: IsoChunk.PhysicsShapes

    WallE: IsoChunk.PhysicsShapes

    WallN: IsoChunk.PhysicsShapes

    WallS: IsoChunk.PhysicsShapes

    WallW: IsoChunk.PhysicsShapes

    @staticmethod
    def valueOf(arg0: str) -> IsoChunk.PhysicsShapes: ...

    @staticmethod
    def values() -> list[IsoChunk.PhysicsShapes]: ...

  class ChunkGetter:

    @overload
    def getGridSquare(self, arg0: int, arg1: int, arg2: int) -> IsoGridSquare: ...

    @overload
    def getGridSquare(self, arg0: int, arg1: int, arg2: int) -> IsoGridSquare: ...

  class SanityCheck:

    def beginLoad(self, arg0: IsoChunk) -> None: ...

    def beginLoadFile(self, arg0: str) -> None: ...

    def beginSave(self, arg0: IsoChunk) -> None: ...

    def beginSaveFile(self, arg0: str) -> None: ...

    def checkCRC(self, arg0: int, arg1: int) -> None: ...

    def checkLength(self, arg0: int, arg1: int) -> None: ...

    def endLoad(self, arg0: IsoChunk) -> None: ...

    def endLoadFile(self, arg0: str) -> None: ...

    def endSave(self, arg0: IsoChunk) -> None: ...

    def endSaveFile(self) -> None: ...

    def log(self, arg0: str) -> None: ...

  class ChunkLock:

    def deref(self) -> int: ...

    def lockForReading(self) -> None: ...

    def lockForWriting(self) -> None: ...

    def ref(self) -> IsoChunk.ChunkLock: ...

    def set(self, arg0: int, arg1: int) -> IsoChunk.ChunkLock: ...

    def unlockForReading(self) -> None: ...

    def unlockForWriting(self) -> None: ...

    def __init__(self, arg0: int, arg1: int):
      self.count: int
      self.rw: ReentrantReadWriteLock
      self.wx: int
      self.wy: int


class IsoChunkMap:

  bSettingChunk: ReentrantLock

  ChunkGridWidth: int

  ChunksPerWidth: int

  chunkStore: ConcurrentLinkedQueue[IsoChunk]

  ChunkWidthInTiles: int

  LEVELS: int

  MPWorldXA: int

  MPWorldYA: int

  MPWorldZA: int

  SharedChunks: HashMap[Integer, IsoChunk]

  SWorldX: list[int]

  SWorldY: list[int]

  WorldXA: int

  WorldYA: int

  WorldZA: int

  def Dispose(self) -> None: ...

  def LoadChunk(self, wx: int, wy: int, x: int, y: int) -> None: ...

  def LoadChunkForLater(self, wx: int, wy: int, x: int, y: int) -> IsoChunk: ...

  def ProcessChunkPos(self, chr: IsoGameCharacter) -> None: ...

  def Save(self) -> None: ...

  def SwapChunkBuffers(self) -> None: ...

  def Unload(self) -> None: ...

  def checkIntegrity(self) -> None: ...

  def checkIntegrityThread(self) -> None: ...

  def copy(self, arg0: IsoChunkMap) -> None: ...

  def drawDebugChunkMap(self) -> None: ...

  def getChunk(self, x: int, y: int) -> IsoChunk: ...

  def getChunkCurrent(self, x: int, y: int) -> IsoChunk: ...

  def getChunkForGridSquare(self, x: int, y: int) -> IsoChunk: ...

  def getGridSquare(self, x: int, y: int, z: int) -> IsoGridSquare: ...

  def getGridSquareDirect(self, tileX: int, tileY: int, tileZ: int) -> IsoGridSquare: ...

  def getRoom(self, iD: int) -> IsoRoom: ...

  def getWidthInTiles(self) -> int: ...

  def getWorldXMaxTiles(self) -> int: ...

  def getWorldXMin(self) -> int: ...

  def getWorldXMinTiles(self) -> int: ...

  def getWorldYMaxTiles(self) -> int: ...

  def getWorldYMin(self) -> int: ...

  def getWorldYMinTiles(self) -> int: ...

  def processAllLoadGridSquare(self) -> None: ...

  def renderBloodForChunks(self, zza: int) -> None: ...

  def setChunkDirect(self, c: IsoChunk, bRequireLock: bool) -> bool: ...

  def setGridSquare(self, square: IsoGridSquare, x: int, y: int, z: int) -> None: ...

  def setInitialPos(self, wx: int, wy: int) -> None: ...

  def update(self) -> None: ...

  @staticmethod
  def CalcChunkWidth() -> None: ...

  @staticmethod
  def setWorldStartPos(x: int, y: int) -> None: ...

  def __init__(self, cell: IsoCell):
    self.filenameserverrequests: ArrayList[str]
    self.ignore: bool
    self.playerid: int
    self.worldx: int
    self.worldy: int


class IsoDirectionSet:

  def getNext(self) -> IsoDirections: ...

  @staticmethod
  def rotate(dir: IsoDirections, amount: int) -> IsoDirections: ...

  def __init__(self):
    self.set: int


class IsoDirections(Enum):

  E: IsoDirections

  Max: IsoDirections

  N: IsoDirections

  NE: IsoDirections

  NW: IsoDirections

  S: IsoDirections

  SE: IsoDirections

  SW: IsoDirections

  W: IsoDirections

  @overload
  def RotLeft(self) -> IsoDirections: ...

  @overload
  def RotLeft(self, time: int) -> IsoDirections: ...

  @overload
  def RotRight(self) -> IsoDirections: ...

  @overload
  def RotRight(self, time: int) -> IsoDirections: ...

  def ToVector(self) -> Vector2: ...

  def index(self) -> int: ...

  def toAngle(self) -> float: ...

  def toCompassString(self) -> str: ...

  @staticmethod
  def cardinalFromAngle(angle: Vector2) -> IsoDirections: ...

  @staticmethod
  @overload
  def fromAngle(angleRadians: float) -> IsoDirections: ...

  @staticmethod
  @overload
  def fromAngle(angle: Vector2) -> IsoDirections: ...

  @staticmethod
  @overload
  def fromAngle(angleX: float, angleY: float) -> IsoDirections: ...

  @staticmethod
  def fromAngleActual(angle: Vector2) -> IsoDirections: ...

  @staticmethod
  def fromIndex(index: int) -> IsoDirections: ...

  @staticmethod
  def generateTables() -> None: ...

  @staticmethod
  def getRandom() -> IsoDirections: ...

  @staticmethod
  def reverse(dir: IsoDirections) -> IsoDirections: ...

  @staticmethod
  def valueOf(arg0: str) -> IsoDirections: ...

  @staticmethod
  def values() -> list[IsoDirections]: ...


class IsoFloorBloodSplat:

  FADE_HOURS: float

  FloorBloodTypes: list[str]

  SpriteMap: HashMap[str, IsoSprite]

  def load(self, input: ByteBuffer, WorldVersion: int) -> None: ...

  def save(self, output: ByteBuffer) -> None: ...

  @overload
  def __init__(self):
    self.fade: int

    self.index: int

    self.type: int

    self.worldage: float

    self.x: float

    self.y: float

    self.z: float

  @overload
  def __init__(self, x: float, y: float, z: float, Type: int, worldAge: float): ...


class IsoGridOcclusionData:

  MAXBUILDINGOCCLUDERS: int

  def Reset(self) -> None: ...

  def getBuildingsCouldBeOccluders(self, filter: IsoGridOcclusionData.OcclusionFilter) -> ArrayList[IsoBuilding]: ...

  def getCouldBeOccludedByOrphanStructures(self, filter: IsoGridOcclusionData.OcclusionFilter) -> bool: ...

  @staticmethod
  def SquareChanged() -> None: ...

  def __init__(self, inOwnerSquare: IsoGridSquare): ...

  class OcclusionFilter(Enum):

    All: IsoGridOcclusionData.OcclusionFilter

    Left: IsoGridOcclusionData.OcclusionFilter

    Right: IsoGridOcclusionData.OcclusionFilter

    @staticmethod
    def valueOf(arg0: str) -> IsoGridOcclusionData.OcclusionFilter: ...

    @staticmethod
    def values() -> list[IsoGridOcclusionData.OcclusionFilter]: ...

  class OccluderType(Enum):

    Full: IsoGridOcclusionData.OccluderType

    NotFull: IsoGridOcclusionData.OccluderType

    Unknown: IsoGridOcclusionData.OccluderType

    @staticmethod
    def valueOf(arg0: str) -> IsoGridOcclusionData.OccluderType: ...

    @staticmethod
    def values() -> list[IsoGridOcclusionData.OccluderType]: ...


class IsoGridSquare:

  bmod: float

  cellGetSquare: IsoGridSquare.CellGetSquare

  choices: ArrayList[IsoGridSquare]

  CircleStencil: bool

  gmod: float

  gridSquareCacheEmptyTimer: int

  IDMax: int

  isoGridSquareCache: ConcurrentLinkedQueue[IsoGridSquare]

  isOnScreenLast: bool

  loadGridSquareCache: ArrayDeque[IsoGridSquare]

  RecalcLightTime: int

  rmod: float

  USE_WALL_SHADER: bool

  UseSlowCollision: bool

  WALL_TYPE_E: int

  WALL_TYPE_N: int

  WALL_TYPE_S: int

  WALL_TYPE_W: int

  @overload
  def AddSpecialObject(self, obj: IsoObject) -> None: ...

  @overload
  def AddSpecialObject(self, obj: IsoObject, index: int) -> None: ...

  def AddSpecialTileObject(self, obj: IsoObject) -> None: ...

  def AddStairs(self, north: bool, level: int, sprite: str, pillarSprite: str, table: KahluaTable) -> IsoThumpable: ...

  @overload
  def AddTileObject(self, obj: IsoObject) -> None: ...

  @overload
  def AddTileObject(self, obj: IsoObject, index: int) -> None: ...

  @overload
  def AddWorldInventoryItem(self, String: str, x: float, y: float, height: float) -> InventoryItem: ...

  @overload
  def AddWorldInventoryItem(self, item: InventoryItem, x: float, y: float, height: float) -> InventoryItem: ...

  @overload
  def AddWorldInventoryItem(self, String: str, x: float, y: float, height: float, nbr: int) -> None: ...

  @overload
  def AddWorldInventoryItem(self, item: InventoryItem, x: float, y: float, height: float, transmit: bool) -> InventoryItem: ...

  @overload
  def Burn(self) -> None: ...

  @overload
  def Burn(self, explode: bool) -> None: ...

  def BurnTick(self) -> None: ...

  def BurnWalls(self, explode: bool) -> None: ...

  def BurnWallsTCOnly(self) -> None: ...

  def CalcVisibility(self, playerIndex: int) -> None: ...

  @overload
  def CalculateCollide(self, gridSquare: IsoGridSquare, bVision: bool, bPathfind: bool, bIgnoreSolidTrans: bool) -> bool: ...

  @overload
  def CalculateCollide(self, gridSquare: IsoGridSquare, bVision: bool, bPathfind: bool, bIgnoreSolidTrans: bool, bIgnoreSolid: bool) -> bool: ...

  @overload
  def CalculateCollide(self, gridSquare: IsoGridSquare, bVision: bool, bPathfind: bool, bIgnoreSolidTrans: bool, bIgnoreSolid: bool, getter: IsoGridSquare.GetSquare) -> bool: ...

  @overload
  def CalculateVisionBlocked(self, gridSquare: IsoGridSquare) -> bool: ...

  @overload
  def CalculateVisionBlocked(self, gridSquare: IsoGridSquare, getter: IsoGridSquare.GetSquare) -> bool: ...

  def ClearTileObjects(self) -> None: ...

  def ClearTileObjectsExceptFloor(self) -> None: ...

  def DeleteTileObject(self, obj: IsoObject) -> None: ...

  def DirtySlice(self) -> None: ...

  @overload
  def DistTo(self, sq: IsoGridSquare) -> float: ...

  @overload
  def DistTo(self, other: IsoMovingObject) -> float: ...

  @overload
  def DistTo(self, x: int, y: int) -> float: ...

  @overload
  def DistToProper(self, sq: IsoGridSquare) -> float: ...

  @overload
  def DistToProper(self, other: IsoMovingObject) -> float: ...

  def DoCutawayShader(self, obj: IsoObject, dir: IsoDirections, cutawaySW: bool, cutawayNW: bool, cutawayNE: bool, bHasDoorN: bool, bHasDoorW: bool, bHasWindowN: bool, bHasWindowW: bool, texdModifier: WallShaperWhole) -> None: ...

  def DoCutawayShaderSprite(self, sprite: IsoSprite, dir: IsoDirections, cutawaySW: bool, cutawayNW: bool, cutawayNE: bool) -> None: ...

  def DoSplat(self, id: str, bFlip: bool, prop: IsoFlagType, offX: float, offZ: float, alpha: float) -> None: ...

  def DoWallLightingN(self, obj: IsoObject, stenciled: int, cutawayNW: bool, cutawayNE: bool, bHasDoorN: bool, bHasWindowN: bool, wallRenderShader: Shader) -> int: ...

  def DoWallLightingNW(self, obj: IsoObject, stenciled: int, cutawaySW: bool, cutawayNW: bool, cutawayNE: bool, bHasDoorN: bool, bHasDoorW: bool, bHasWindowN: bool, bHasWindowW: bool, wallRenderShader: Shader) -> int: ...

  def DoWallLightingW(self, obj: IsoObject, stenciled: int, cutawaySW: bool, cutawayNW: bool, bHasDoorW: bool, bHasWindowW: bool, wallRenderShader: Shader) -> int: ...

  def EnsureSurroundNotNull(self) -> None: ...

  @overload
  def FindEnemy(self, g: IsoGameCharacter, range: int, EnemyList: ArrayList[IsoMovingObject]) -> IsoGameCharacter: ...

  @overload
  def FindEnemy(self, g: IsoGameCharacter, range: int, EnemyList: ArrayList[IsoMovingObject], RangeTest: IsoGameCharacter, TestRangeMax: int) -> IsoGameCharacter: ...

  def FindFriend(self, g: IsoGameCharacter, range: int, EnemyList: Stack[IsoGameCharacter]) -> IsoGameCharacter: ...

  def FixStackableObjects(self) -> None: ...

  def Has(self, type: IsoObjectType) -> bool: ...

  def HasElevatedFloor(self) -> bool: ...

  def HasPushable(self) -> bool: ...

  def HasSlopedRoof(self) -> bool: ...

  def HasSlopedRoofNorth(self) -> bool: ...

  def HasSlopedRoofWest(self) -> bool: ...

  def HasStairs(self) -> bool: ...

  def HasStairsBelow(self) -> bool: ...

  def HasStairsNorth(self) -> bool: ...

  def HasStairsWest(self) -> bool: ...

  def HasTree(self) -> bool: ...

  def InvalidateSpecialObjectPaths(self) -> None: ...

  @overload
  def Is(self, flag: str) -> bool: ...

  @overload
  def Is(self, flag: IsoFlagType) -> bool: ...

  @overload
  def IsOnScreen(self) -> bool: ...

  @overload
  def IsOnScreen(self, halfTileBorder: bool) -> bool: ...

  @overload
  def ReCalculateCollide(self, square: IsoGridSquare) -> None: ...

  @overload
  def ReCalculateCollide(self, square: IsoGridSquare, getter: IsoGridSquare.GetSquare) -> None: ...

  @overload
  def ReCalculatePathFind(self, square: IsoGridSquare) -> None: ...

  @overload
  def ReCalculatePathFind(self, square: IsoGridSquare, getter: IsoGridSquare.GetSquare) -> None: ...

  @overload
  def ReCalculateVisionBlocked(self, square: IsoGridSquare) -> None: ...

  @overload
  def ReCalculateVisionBlocked(self, square: IsoGridSquare, getter: IsoGridSquare.GetSquare) -> None: ...

  @overload
  def RecalcAllWithNeighbours(self, bDoReverse: bool) -> None: ...

  @overload
  def RecalcAllWithNeighbours(self, bDoReverse: bool, getter: IsoGridSquare.GetSquare) -> None: ...

  def RecalcAllWithNeighboursMineOnly(self) -> None: ...

  def RecalcProperties(self) -> None: ...

  def RecalcPropertiesIfNeeded(self) -> None: ...

  def RemoveTileObject(self, obj: IsoObject) -> int: ...

  def RemoveTileObjectErosionNoRecalc(self, obj: IsoObject) -> int: ...

  def RenderMinusFloorFxMask(self, maxZ: int, doSE: bool, vegitationRender: bool) -> bool: ...

  def RenderOpenDoorOnly(self) -> None: ...

  def ResetIsoWorldRegion(self) -> None: ...

  def StartFire(self) -> None: ...

  def TreatAsSolidFloor(self) -> bool: ...

  def addBrokenGlass(self) -> IsoBrokenGlass: ...

  def addCorpse(self, body: IsoDeadBody, bRemote: bool) -> None: ...

  def addDeferredCharacter(self, chr: IsoGameCharacter) -> None: ...

  def addFloor(self, sprite: str) -> IsoObject: ...

  def checkRoomSeen(self, playerIndex: int) -> None: ...

  def clearPuddles(self) -> None: ...

  def clearWater(self) -> None: ...

  def connectedWithFloor(self) -> bool: ...

  def damageSpriteSheetRopeFromBottom(self, player: IsoPlayer, north: bool) -> bool: ...

  def disableErosion(self) -> None: ...

  def discard(self) -> None: ...

  def drawCircleExplosion(self, radius: int, trap: IsoTrap, explosionMode: IsoTrap.ExplosionMode) -> None: ...

  def explode(self) -> None: ...

  def explodeTrap(self) -> None: ...

  def explosion(self, trap: IsoTrap) -> None: ...

  def fixPlacedItemRenderOffsets(self) -> None: ...

  def getAdjacentPathSquare(self, dir: IsoDirections) -> IsoGridSquare: ...

  def getAdjacentSquare(self, dir: IsoDirections) -> IsoGridSquare: ...

  def getApparentZ(self, dx: float, dy: float) -> float: ...

  def getBedTo(self, next: IsoGridSquare) -> IsoObject: ...

  def getBrokenGlass(self) -> IsoBrokenGlass: ...

  def getBuilding(self) -> IsoBuilding: ...

  def getCanSee(self, playerIndex: int) -> bool: ...

  def getCell(self) -> IsoCell: ...

  def getChunk(self) -> IsoChunk: ...

  def getCollideMatrix(self, dx: int, dy: int, dz: int) -> bool: ...

  def getCompost(self) -> IsoCompost: ...

  def getContainerItem(self, type: str) -> IsoObject: ...

  def getCurtain(self, curtainType: IsoObjectType) -> IsoCurtain: ...

  def getDarkMulti(self, playerIndex: int) -> float: ...

  def getDeadBody(self) -> IsoDeadBody: ...

  def getDeadBodys(self) -> List[IsoDeadBody]: ...

  def getDeferedCharacters(self) -> ArrayList[IsoGameCharacter]: ...

  def getDoor(self, north: bool) -> IsoObject: ...

  def getDoorFrameTo(self, next: IsoGridSquare) -> IsoObject: ...

  def getDoorOrWindow(self, north: bool) -> IsoObject: ...

  def getDoorOrWindowOrWindowFrame(self, dir: IsoDirections, ignoreOpen: bool) -> IsoObject: ...

  def getDoorTo(self, next: IsoGridSquare) -> IsoObject: ...

  def getE(self) -> IsoGridSquare: ...

  def getErosionData(self) -> ErosionData.Square: ...

  def getFloor(self) -> IsoObject: ...

  def getGenerator(self) -> IsoGenerator: ...

  def getGridSneakModifier(self, onlySolidTrans: bool) -> float: ...

  def getHasTypes(self) -> ZomboidBitFlag: ...

  def getHashCodeObjects(self) -> int: ...

  def getHashCodeObjectsInt(self) -> int: ...

  def getHoppable(self, north: bool) -> IsoObject: ...

  def getHoppableThumpable(self, north: bool) -> IsoThumpable: ...

  def getHoppableThumpableTo(self, next: IsoGridSquare) -> IsoThumpable: ...

  def getHoppableTo(self, next: IsoGridSquare) -> IsoObject: ...

  def getHoppableWall(self, bNorth: bool) -> IsoObject: ...

  def getHourLastSeen(self) -> int: ...

  def getHoursSinceLastSeen(self) -> float: ...

  def getID(self) -> Integer: ...

  def getIsDissolved(self, playerIndex: int, currentTimeMillis: int) -> bool: ...

  def getIsoDoor(self) -> IsoDoor: ...

  def getIsoWorldRegion(self) -> IWorldRegion: ...

  def getLampostTotalB(self) -> float: ...

  def getLampostTotalG(self) -> float: ...

  def getLampostTotalR(self) -> float: ...

  def getLightInfluenceB(self) -> ArrayList[Float]: ...

  def getLightInfluenceG(self) -> ArrayList[Float]: ...

  def getLightInfluenceR(self) -> ArrayList[Float]: ...

  def getLightLevel(self, playerIndex: int) -> float: ...

  def getLocalTemporaryObjects(self) -> PZArrayList[IsoObject]: ...

  def getLuaMovingObjectList(self) -> KahluaTable: ...

  def getLuaTileObjectList(self) -> KahluaTable: ...

  def getModData(self) -> KahluaTable: ...

  def getMovingObjects(self) -> ArrayList[IsoMovingObject]: ...

  def getN(self) -> IsoGridSquare: ...

  def getObjects(self) -> PZArrayList[IsoObject]: ...

  def getOcclusionData(self) -> IsoGridOcclusionData: ...

  def getOpenDoor(self, dir: IsoDirections) -> IsoObject: ...

  def getOrCreateOcclusionData(self) -> IsoGridOcclusionData: ...

  def getPathMatrix(self, dx: int, dy: int, dz: int) -> bool: ...

  def getPlayer(self) -> IsoPlayer: ...

  def getPlayerBuiltFloor(self) -> IsoObject: ...

  def getPlayerCutawayFlag(self, playerIndex: int, currentTimeMillis: int) -> bool: ...

  def getProperties(self) -> PropertyContainer: ...

  def getPuddles(self) -> IsoPuddlesGeometry: ...

  def getPuddlesDir(self) -> int: ...

  def getPuddlesInGround(self) -> float: ...

  def getRainDrop(self) -> IsoRaindrop: ...

  def getRainSplash(self) -> IsoRainSplash: ...

  def getRoofHideBuilding(self) -> IsoBuilding: ...

  def getRoom(self) -> IsoRoom: ...

  def getRoomID(self) -> int: ...

  def getRoomSize(self) -> int: ...

  def getS(self) -> IsoGridSquare: ...

  def getSeen(self, playerIndex: int) -> bool: ...

  def getSheetRope(self) -> IsoObject: ...

  def getSpecialObjects(self) -> ArrayList[IsoObject]: ...

  def getStaticMovingObjects(self) -> ArrayList[IsoMovingObject]: ...

  def getTargetDarkMulti(self, playerIndex: int) -> float: ...

  def getThumpableWall(self, bNorth: bool) -> IsoObject: ...

  def getThumpableWallOrHoppable(self, bNorth: bool) -> IsoObject: ...

  def getThumpableWindow(self, north: bool) -> IsoThumpable: ...

  def getTileInDirection(self, directions: IsoDirections) -> IsoGridSquare: ...

  def getTotalWeightOfItemsOnFloor(self) -> float: ...

  def getTransparentWallTo(self, other: IsoGridSquare) -> IsoObject: ...

  def getTrapPositionX(self) -> int: ...

  def getTrapPositionY(self) -> int: ...

  def getTrapPositionZ(self) -> int: ...

  def getTree(self) -> IsoTree: ...

  def getVehicleContainer(self) -> BaseVehicle: ...

  def getVertLight(self, i: int, playerIndex: int) -> int: ...

  def getVisionMatrix(self, dx: int, dy: int, dz: int) -> bool: ...

  def getW(self) -> IsoGridSquare: ...

  def getWall(self, bNorth: bool) -> IsoObject: ...

  def getWallFull(self) -> Boolean: ...

  def getWallHoppable(self, north: bool) -> IsoObject: ...

  def getWallHoppableTo(self, next: IsoGridSquare) -> IsoObject: ...

  def getWallSE(self) -> IsoObject: ...

  def getWallType(self) -> int: ...

  def getWater(self) -> IsoWaterGeometry: ...

  @overload
  def getWindow(self) -> IsoWindow: ...

  @overload
  def getWindow(self, north: bool) -> IsoWindow: ...

  def getWindowFrame(self, north: bool) -> IsoObject: ...

  def getWindowFrameTo(self, next: IsoGridSquare) -> IsoObject: ...

  def getWindowThumpableTo(self, next: IsoGridSquare) -> IsoThumpable: ...

  def getWindowTo(self, next: IsoGridSquare) -> IsoWindow: ...

  def getWorldObjects(self) -> ArrayList[IsoWorldInventoryObject]: ...

  def getX(self) -> int: ...

  def getY(self) -> int: ...

  def getZ(self) -> int: ...

  def getZombie(self) -> IsoZombie: ...

  def getZone(self) -> IsoMetaGrid.Zone: ...

  def getZoneType(self) -> str: ...

  def hasBlockedDoor(self, north: bool) -> bool: ...

  def hasBlockedWindow(self, north: bool) -> bool: ...

  def hasClosedDoorOnEdge(self, arg0: IsoDirections) -> bool: ...

  def hasDoorOnEdge(self, edge: IsoDirections, ignoreOpen: bool) -> bool: ...

  def hasFlies(self) -> bool: ...

  def hasFloor(self, north: bool) -> bool: ...

  def hasModData(self) -> bool: ...

  def hasOpenDoorOnEdge(self, arg0: IsoDirections) -> bool: ...

  def hasSupport(self) -> bool: ...

  def hasWindowFrame(self) -> bool: ...

  def hasWindowOrWindowFrame(self) -> bool: ...

  def hashCodeNoOverride(self) -> int: ...

  def haveBlood(self) -> bool: ...

  def haveDoor(self) -> bool: ...

  def haveElectricity(self) -> bool: ...

  def haveFire(self) -> bool: ...

  def interpolateLight(self, inf: ColorInfo, x: float, y: float) -> None: ...

  def isAdjacentToWindow(self) -> bool: ...

  def isBlockedTo(self, other: IsoGridSquare) -> bool: ...

  def isCacheIsFree(self) -> bool: ...

  def isCachedIsFree(self) -> bool: ...

  def isCanSee(self, playerIndex: int) -> bool: ...

  def isCommonGrass(self) -> bool: ...

  def isCouldSee(self, playerIndex: int) -> bool: ...

  def isDoorBlockedTo(self, other: IsoGridSquare) -> bool: ...

  def isDoorTo(self, other: IsoGridSquare) -> bool: ...

  def isFree(self, bCountOtherCharacters: bool) -> bool: ...

  @overload
  def isFreeOrMidair(self, bCountOtherCharacters: bool) -> bool: ...

  @overload
  def isFreeOrMidair(self, bCountOtherCharacters: bool, bDoZombie: bool) -> bool: ...

  def isHoppableTo(self, other: IsoGridSquare) -> bool: ...

  def isInARoom(self) -> bool: ...

  def isNotBlocked(self, bCountOtherCharacters: bool) -> bool: ...

  def isOutside(self) -> bool: ...

  def isOverlayDone(self) -> bool: ...

  @overload
  def isSafeToSpawn(self) -> bool: ...

  @overload
  def isSafeToSpawn(self, sq: IsoGridSquare, depth: int) -> None: ...

  def isSameStaircase(self, x: int, y: int, z: int) -> bool: ...

  def isSeen(self, playerIndex: int) -> bool: ...

  def isSolid(self) -> bool: ...

  def isSolidFloor(self) -> bool: ...

  def isSolidFloorCached(self) -> bool: ...

  def isSolidTrans(self) -> bool: ...

  def isSomethingTo(self, other: IsoGridSquare) -> bool: ...

  def isVehicleIntersecting(self) -> bool: ...

  def isWallTo(self, other: IsoGridSquare) -> bool: ...

  def isWindowBlockedTo(self, other: IsoGridSquare) -> bool: ...

  def isWindowTo(self, other: IsoGridSquare) -> bool: ...

  @overload
  def load(self, b: ByteBuffer, WorldVersion: int) -> None: ...

  @overload
  def load(self, b: ByteBuffer, WorldVersion: int, IS_DEBUG_SAVE: bool) -> None: ...

  def placeWallAndDoorCheck(self, obj: IsoObject, index: int) -> int: ...

  @overload
  def playSound(self, file: str) -> int: ...

  @overload
  def playSound(self, file: str, doWorldSound: bool) -> int: ...

  def recalcHashCodeObjects(self) -> None: ...

  def removeAllWorldObjects(self) -> None: ...

  def removeBlood(self, remote: bool, onlyWall: bool) -> None: ...

  def removeCorpse(self, body: IsoDeadBody, bRemote: bool) -> None: ...

  def removeErosionObject(self, type: str) -> None: ...

  def removeLightSwitch(self) -> None: ...

  def removeSheetRopeFromBottom(self, player: IsoPlayer, north: bool) -> bool: ...

  def removeWorldObject(self, object: IsoWorldInventoryObject) -> None: ...

  def renderCharacters(self, maxZ: int, deadRender: bool, doBlendFunc: bool) -> None: ...

  def renderDeferredCharacters(self, maxZ: int) -> None: ...

  def restackSheetRope(self) -> None: ...

  @overload
  def save(self, output: ByteBuffer, outputObj: ObjectOutputStream) -> None: ...

  @overload
  def save(self, output: ByteBuffer, outputObj: ObjectOutputStream, IS_DEBUG_SAVE: bool) -> None: ...

  def scoreAsWaypoint(self, x: int, y: int) -> float: ...

  def setCacheIsFree(self, CacheIsFree: bool) -> None: ...

  def setCachedIsFree(self, CachedIsFree: bool) -> None: ...

  def setCanSee(self, playerIndex: int, canSee: bool) -> None: ...

  def setCouldSee(self, playerIndex: int, bCouldSee: bool) -> None: ...

  def setDarkMulti(self, playerIndex: int, darkMulti: float) -> None: ...

  def setE(self, e: IsoGridSquare) -> None: ...

  def setHasFlies(self, hasFlies: bool) -> None: ...

  def setHaveElectricity(self, haveElectricity: bool) -> None: ...

  def setHourSeenToCurrent(self) -> None: ...

  def setID(self, ID: int) -> None: ...

  def setIsDissolved(self, playerIndex: int, bDissolved: bool, currentTimeMillis: int) -> None: ...

  def setIsSeen(self, playerIndex: int, bSeen: bool) -> None: ...

  def setIsoWorldRegion(self, mr: IsoWorldRegion) -> None: ...

  def setLampostTotalB(self, lampostTotalB: float) -> None: ...

  def setLampostTotalG(self, lampostTotalG: float) -> None: ...

  def setLampostTotalR(self, lampostTotalR: float) -> None: ...

  def setLightInfluenceB(self, LightInfluenceB: ArrayList[Float]) -> None: ...

  def setLightInfluenceG(self, LightInfluenceG: ArrayList[Float]) -> None: ...

  def setLightInfluenceR(self, LightInfluenceR: ArrayList[Float]) -> None: ...

  def setLightInfoServerGUIOnly(self, c: ColorInfo) -> None: ...

  def setN(self, n: IsoGridSquare) -> None: ...

  def setOverlayDone(self, overlayDone: bool) -> None: ...

  def setPlayerCutawayFlag(self, playerIndex: int, bCutaway: bool, currentTimeMillis: int) -> None: ...

  def setRainDrop(self, drop: IsoRaindrop) -> None: ...

  def setRainSplash(self, splash: IsoRainSplash) -> None: ...

  def setRoom(self, room: IsoRoom) -> None: ...

  def setRoomID(self, roomID: int) -> None: ...

  def setS(self, s: IsoGridSquare) -> None: ...

  def setSolidFloor(self, SolidFloor: bool) -> None: ...

  def setSolidFloorCached(self, SolidFloorCached: bool) -> None: ...

  def setTargetDarkMulti(self, playerIndex: int, targetDarkMulti: float) -> None: ...

  def setTrapPositionX(self, trapPositionX: int) -> None: ...

  def setTrapPositionY(self, trapPositionY: int) -> None: ...

  def setTrapPositionZ(self, trapPositionZ: int) -> None: ...

  def setVertLight(self, i: int, col: int, playerIndex: int) -> None: ...

  def setW(self, w: IsoGridSquare) -> None: ...

  def setX(self, x: int) -> None: ...

  def setY(self, y: int) -> None: ...

  def setZ(self, z: int) -> None: ...

  def shouldSave(self) -> bool: ...

  def smoke(self) -> None: ...

  def softClear(self) -> None: ...

  def splatBlood(self, dist: int, alpha: float) -> None: ...

  def stopFire(self) -> None: ...

  def switchLight(self, active: bool) -> None: ...

  def syncIsoTrap(self, weapon: HandWeapon) -> None: ...

  def testCollideAdjacent(self, collideObject: IsoMovingObject, x: int, y: int, z: int) -> bool: ...

  def testCollideAdjacentAdvanced(self, x: int, y: int, z: int, ignoreDoors: bool) -> bool: ...

  def testCollideSpecialObjects(self, next: IsoGridSquare) -> IsoObject: ...

  @overload
  def testPathFindAdjacent(self, mover: IsoMovingObject, x: int, y: int, z: int) -> bool: ...

  @overload
  def testPathFindAdjacent(self, mover: IsoMovingObject, x: int, y: int, z: int, getter: IsoGridSquare.GetSquare) -> bool: ...

  def testVisionAdjacent(self, x: int, y: int, z: int, specialDiag: bool, bIgnoreDoors: bool) -> LosUtil.TestResults: ...

  def transmitAddObjectToSquare(self, obj: IsoObject, index: int) -> None: ...

  def transmitModdata(self) -> None: ...

  def transmitRemoveItemFromSquare(self, obj: IsoObject) -> int: ...

  def transmitRemoveItemFromSquareOnServer(self, obj: IsoObject) -> None: ...

  def transmitStopFire(self) -> None: ...

  @staticmethod
  def auth(username: str, pw: list[str]) -> bool: ...

  @staticmethod
  def getDarkStep() -> float: ...

  @staticmethod
  def getDefColorInfo() -> ColorInfo: ...

  @staticmethod
  def getLightcache() -> int: ...

  @staticmethod
  @overload
  def getMatrixBit(matrix: int, x: int, y: int, z: int) -> bool: ...

  @staticmethod
  @overload
  def getMatrixBit(matrix: int, x: int, y: int, z: int) -> bool: ...

  @staticmethod
  @overload
  def getNew(cell: IsoCell, slice: SliceY, x: int, y: int, z: int) -> IsoGridSquare: ...

  @staticmethod
  @overload
  def getNew(isoGridSquareCache: ArrayDeque[IsoGridSquare], cell: IsoCell, slice: SliceY, x: int, y: int, z: int) -> IsoGridSquare: ...

  @staticmethod
  def getRecalcLightTime() -> int: ...

  @staticmethod
  def getSquaresForThread(isoGridSquareCacheDest: ArrayDeque[IsoGridSquare], count: int) -> None: ...

  @staticmethod
  def isbDoSlowPathfinding() -> bool: ...

  @staticmethod
  def setCollisionMode() -> None: ...

  @staticmethod
  def setDarkStep(aDarkStep: float) -> None: ...

  @staticmethod
  def setLightcache(aLightcache: int) -> None: ...

  @staticmethod
  @overload
  def setMatrixBit(matrix: int, x: int, y: int, z: int, val: bool) -> int: ...

  @staticmethod
  @overload
  def setMatrixBit(matrix: int, x: int, y: int, z: int, val: bool) -> int: ...

  @staticmethod
  def setRecalcLightTime(aRecalcLightTime: int) -> None: ...

  @staticmethod
  def setbDoSlowPathfinding(abDoSlowPathfinding: bool) -> None: ...

  @staticmethod
  def toBoolean(data: list[int]) -> bool: ...

  def __init__(self, cell: IsoCell, slice: SliceY, x: int, y: int, z: int):
    self.bflattengrassetc: bool
    self.cachedscreenx: float
    self.cachedscreeny: float
    self.chunk: IsoChunk
    self.collidematrix: int
    self.e: IsoGridSquare
    self.hashcodeobjects: int
    self.haveroof: bool
    self.havesheetrope: bool
    self.hourlastseen: int
    self.id: Integer
    self.isexteriorcache: bool
    self.issolidfloorcache: bool
    self.isvegitationcache: bool
    self.lighting: list[IsoGridSquare.ILighting]
    self.n: IsoGridSquare
    self.nav: list[IsoGridSquare]
    self.ne: IsoGridSquare
    self.nw: IsoGridSquare
    self.objectssynccount: int
    self.pathmatrix: int
    self.propertiesdirty: bool
    self.roofhidebuilding: IsoBuilding
    self.room: IsoRoom
    self.roomid: int
    self.s: IsoGridSquare
    self.se: IsoGridSquare
    self.solidfloor: bool
    self.solidfloorcached: bool
    self.sw: IsoGridSquare
    self.visionmatrix: int
    self.w: IsoGridSquare
    self.x: int
    self.y: int
    self.z: int
    self.zone: IsoMetaGrid.Zone

  class ILighting:

    @overload
    def bCanSee(self) -> bool: ...

    @overload
    def bCanSee(self, canSee: bool) -> None: ...

    @overload
    def bCouldSee(self) -> bool: ...

    @overload
    def bCouldSee(self, couldSee: bool) -> None: ...

    @overload
    def bSeen(self) -> bool: ...

    @overload
    def bSeen(self, seen: bool) -> None: ...

    @overload
    def darkMulti(self) -> float: ...

    @overload
    def darkMulti(self, f: float) -> None: ...

    def getResultLight(self, index: int) -> IsoGridSquare.ResultLight: ...

    @overload
    def lampostTotalB(self) -> float: ...

    @overload
    def lampostTotalB(self, b: float) -> None: ...

    @overload
    def lampostTotalG(self) -> float: ...

    @overload
    def lampostTotalG(self, g: float) -> None: ...

    @overload
    def lampostTotalR(self) -> float: ...

    @overload
    def lampostTotalR(self, r: float) -> None: ...

    def lightInfo(self) -> ColorInfo: ...

    @overload
    def lightverts(self, i: int) -> int: ...

    @overload
    def lightverts(self, i: int, value: int) -> None: ...

    def reset(self) -> None: ...

    def resultLightCount(self) -> int: ...

    @overload
    def targetDarkMulti(self) -> float: ...

    @overload
    def targetDarkMulti(self, f: float) -> None: ...

  class CircleStencilShader(Shader):

    instance: IsoGridSquare.CircleStencilShader

    def __init__(self):
      self.a_wallshadecolor: int

  class Lighting:

    @overload
    def bCanSee(self) -> bool: ...

    @overload
    def bCanSee(self) -> bool: ...

    @overload
    def bCanSee(self, canSee: bool) -> None: ...

    @overload
    def bCanSee(self, canSee: bool) -> None: ...

    @overload
    def bCouldSee(self) -> bool: ...

    @overload
    def bCouldSee(self) -> bool: ...

    @overload
    def bCouldSee(self, couldSee: bool) -> None: ...

    @overload
    def bCouldSee(self, couldSee: bool) -> None: ...

    @overload
    def bSeen(self) -> bool: ...

    @overload
    def bSeen(self) -> bool: ...

    @overload
    def bSeen(self, seen: bool) -> None: ...

    @overload
    def bSeen(self, seen: bool) -> None: ...

    @overload
    def darkMulti(self) -> float: ...

    @overload
    def darkMulti(self) -> float: ...

    @overload
    def darkMulti(self, f: float) -> None: ...

    @overload
    def darkMulti(self, f: float) -> None: ...

    @overload
    def getResultLight(self, index: int) -> IsoGridSquare.ResultLight: ...

    @overload
    def getResultLight(self, index: int) -> IsoGridSquare.ResultLight: ...

    @overload
    def lampostTotalB(self) -> float: ...

    @overload
    def lampostTotalB(self) -> float: ...

    @overload
    def lampostTotalB(self, b: float) -> None: ...

    @overload
    def lampostTotalB(self, b: float) -> None: ...

    @overload
    def lampostTotalG(self) -> float: ...

    @overload
    def lampostTotalG(self) -> float: ...

    @overload
    def lampostTotalG(self, g: float) -> None: ...

    @overload
    def lampostTotalG(self, g: float) -> None: ...

    @overload
    def lampostTotalR(self) -> float: ...

    @overload
    def lampostTotalR(self) -> float: ...

    @overload
    def lampostTotalR(self, r: float) -> None: ...

    @overload
    def lampostTotalR(self, r: float) -> None: ...

    @overload
    def lightInfo(self) -> ColorInfo: ...

    @overload
    def lightInfo(self) -> ColorInfo: ...

    @overload
    def lightverts(self, i: int) -> int: ...

    @overload
    def lightverts(self, i: int) -> int: ...

    @overload
    def lightverts(self, i: int, value: int) -> None: ...

    @overload
    def lightverts(self, i: int, value: int) -> None: ...

    @overload
    def reset(self) -> None: ...

    @overload
    def reset(self) -> None: ...

    @overload
    def resultLightCount(self) -> int: ...

    @overload
    def resultLightCount(self) -> int: ...

    @overload
    def targetDarkMulti(self) -> float: ...

    @overload
    def targetDarkMulti(self) -> float: ...

    @overload
    def targetDarkMulti(self, f: float) -> None: ...

    @overload
    def targetDarkMulti(self, f: float) -> None: ...

    def __init__(self): ...

  class CellGetSquare:

    @overload
    def getGridSquare(self, x: int, y: int, z: int) -> IsoGridSquare: ...

    @overload
    def getGridSquare(self, x: int, y: int, z: int) -> IsoGridSquare: ...

    def __init__(self): ...

  class GetSquare:

    def getGridSquare(self, x: int, y: int, z: int) -> IsoGridSquare: ...

  class s_performance: ...

  class PuddlesDirection:

    PUDDLES_DIR_ALL: int

    PUDDLES_DIR_NE: int

    PUDDLES_DIR_NONE: int

    PUDDLES_DIR_NW: int

    def __init__(self): ...

  class NoCircleStencilShader:

    instance: IsoGridSquare.NoCircleStencilShader

    def __init__(self):
      self.a_wallshadecolor: int
      self.shaderid: int

  class RenderWallCallback:

    def invoke(self, arg0: Texture, arg1: float, arg2: float) -> None: ...

  class ResultLight:

    RLF_NONE: int

    RLF_ROOMLIGHT: int

    RLF_TORCH: int

    def copyFrom(self, other: IsoGridSquare.ResultLight) -> IsoGridSquare.ResultLight: ...

    def __init__(self):
      self.b: float
      self.flags: int
      self.g: float
      self.id: int
      self.r: float
      self.radius: int
      self.x: int
      self.y: int
      self.z: int


class IsoGridStack:

  def __init__(self, count: int):
    self.squares: ArrayList[ArrayList[IsoGridSquare]]


class IsoHeatSource:

  def getRadius(self) -> int: ...

  def getTemperature(self) -> int: ...

  def getX(self) -> int: ...

  def getY(self) -> int: ...

  def getZ(self) -> int: ...

  @overload
  def isInBounds(self) -> bool: ...

  @overload
  def isInBounds(self, minX: int, minY: int, maxX: int, maxY: int) -> bool: ...

  def setRadius(self, radius: int) -> None: ...

  def setTemperature(self, temperature: int) -> None: ...

  def __init__(self, x: int, y: int, z: int, radius: int, temperature: int): ...


class IsoLightSource:

  NextID: int

  def clearInfluence(self) -> None: ...

  def getB(self) -> float: ...

  def getG(self) -> float: ...

  def getLocalToBuilding(self) -> IsoBuilding: ...

  def getR(self) -> float: ...

  def getRadius(self) -> int: ...

  def getSwitches(self) -> ArrayList[IsoLightSwitch]: ...

  def getX(self) -> int: ...

  def getY(self) -> int: ...

  def getZ(self) -> int: ...

  def isActive(self) -> bool: ...

  def isHydroPowered(self) -> bool: ...

  @overload
  def isInBounds(self) -> bool: ...

  @overload
  def isInBounds(self, minX: int, minY: int, maxX: int, maxY: int) -> bool: ...

  def setActive(self, bActive: bool) -> None: ...

  def setB(self, b: float) -> None: ...

  def setG(self, g: float) -> None: ...

  def setR(self, r: float) -> None: ...

  def setRadius(self, radius: int) -> None: ...

  def setSwitches(self, switches: ArrayList[IsoLightSwitch]) -> None: ...

  def setWasActive(self, bWasActive: bool) -> None: ...

  def setX(self, x: int) -> None: ...

  def setY(self, y: int) -> None: ...

  def setZ(self, z: int) -> None: ...

  def update(self) -> None: ...

  def wasActive(self) -> bool: ...

  @overload
  def __init__(self, x: int, y: int, z: int, r: float, g: float, b: float, radius: int):
    self.b: float

    self.bactive: bool

    self.bactivejni: bool

    self.bhydropowered: bool

    self.bjni: float

    self.bwasactive: bool

    self.chunk: IsoChunk

    self.g: float

    self.gjni: float

    self.id: int

    self.life: int

    self.lightmap: object

    self.localtobuilding: IsoBuilding

    self.r: float

    self.radius: int

    self.rjni: float

    self.startlife: int

    self.switches: ArrayList[IsoLightSwitch]

    self.x: int

    self.y: int

    self.z: int

  @overload
  def __init__(self, x: int, y: int, z: int, r: float, g: float, b: float, radius: int, life: int): ...
  @overload
  def __init__(self, x: int, y: int, z: int, r: float, g: float, b: float, radius: int, building: IsoBuilding): ...


class IsoLot:

  InfoFileNames: HashMap[str, str]

  InfoHeaderNames: ArrayList[str]

  InfoHeaders: HashMap[str, LotHeader]

  pool: ObjectPool[IsoLot]

  def load(self, cX: Integer, cY: Integer, wX: Integer, wY: Integer, ch: IsoChunk) -> None: ...

  @staticmethod
  def Dispose() -> None: ...

  @staticmethod
  def get(cX: Integer, cY: Integer, wX: Integer, wY: Integer, ch: IsoChunk) -> IsoLot: ...

  @staticmethod
  def put(lot: IsoLot) -> None: ...

  @staticmethod
  def readInt(__in__: RandomAccessFile) -> int: ...

  @staticmethod
  def readShort(__in__: RandomAccessFile) -> int: ...

  @staticmethod
  def readString(__in__: BufferedRandomAccessFile) -> str: ...

  def __init__(self):
    self.wx: int
    self.wy: int


class IsoLuaMover(IsoGameCharacter):

  def getObjectName(self) -> str: ...

  def playAnim(self, name: str, seconds: float, looped: bool, playing: bool) -> None: ...

  def render(self, x: float, y: float, z: float, col: ColorInfo, bDoAttached: bool, bWallLightingPass: bool, shader: Shader) -> None: ...

  def update(self) -> None: ...

  def __init__(self, table: KahluaTable):
    self.luamovertable: KahluaTable


class IsoMarkers:

  instance: IsoMarkers

  def addCircleIsoMarker(self, gs: IsoGridSquare, r: float, g: float, b: float, a: float) -> IsoMarkers.CircleIsoMarker: ...

  @overload
  def addIsoMarker(self, spriteName: str, gs: IsoGridSquare, r: float, g: float, b: float, doAlpha: bool, doIsoObject: bool) -> IsoMarkers.IsoMarker: ...

  @overload
  def addIsoMarker(self, textureTable: KahluaTable, textureOverlayTable: KahluaTable, gs: IsoGridSquare, r: float, g: float, b: float, doAlpha: bool, doIsoObject: bool) -> IsoMarkers.IsoMarker: ...

  @overload
  def addIsoMarker(self, textureTable: KahluaTable, textureOverlayTable: KahluaTable, gs: IsoGridSquare, r: float, g: float, b: float, doAlpha: bool, doIsoObject: bool, fadeSpeed: float, fadeMin: float, fadeMax: float) -> IsoMarkers.IsoMarker: ...

  def getCircleIsoMarker(self, id: int) -> IsoMarkers.CircleIsoMarker: ...

  def getIsoMarker(self, id: int) -> IsoMarkers.IsoMarker: ...

  def init(self) -> None: ...

  @overload
  def removeCircleIsoMarker(self, id: int) -> bool: ...

  @overload
  def removeCircleIsoMarker(self, marker: IsoMarkers.CircleIsoMarker) -> bool: ...

  @overload
  def removeIsoMarker(self, id: int) -> bool: ...

  @overload
  def removeIsoMarker(self, marker: IsoMarkers.IsoMarker) -> bool: ...

  def render(self) -> None: ...

  def renderCircleIsoMarkers(self, perPlayerRender: IsoCell.PerPlayerRender, zLayer: int, playerIndex: int) -> None: ...

  def renderIsoMarkers(self, perPlayerRender: IsoCell.PerPlayerRender, zLayer: int, playerIndex: int) -> None: ...

  def renderIsoMarkersDeferred(self, perPlayerRender: IsoCell.PerPlayerRender, zLayer: int, playerIndex: int) -> None: ...

  def renderIsoMarkersOnSquare(self, perPlayerRender: IsoCell.PerPlayerRender, zLayer: int, playerIndex: int) -> None: ...

  def reset(self) -> None: ...

  def update(self) -> None: ...

  class IsoMarker:

    def addTempSquareObject(self, tempObject: IsoObject) -> None: ...

    def getA(self) -> float: ...

    def getAlpha(self) -> float: ...

    def getAlphaMax(self) -> float: ...

    def getAlphaMin(self) -> float: ...

    def getB(self) -> float: ...

    def getFadeSpeed(self) -> float: ...

    def getG(self) -> float: ...

    def getID(self) -> int: ...

    def getR(self) -> float: ...

    def getSquare(self) -> IsoGridSquare: ...

    def getX(self) -> float: ...

    def getY(self) -> float: ...

    def getZ(self) -> float: ...

    def hasTempSquareObject(self) -> bool: ...

    @overload
    def init(self, spriteName: str, x: int, y: int, z: int, gs: IsoGridSquare, doTempIsoObject: bool) -> None: ...

    @overload
    def init(self, textureTable: KahluaTable, textureOverlayTable: KahluaTable, x: int, y: int, z: int, gs: IsoGridSquare) -> None: ...

    @overload
    def init(self, textureTable: KahluaTable, textureOverlayTable: KahluaTable, x: int, y: int, z: int, gs: IsoGridSquare, doTempIsoObject: bool) -> None: ...

    def isActive(self) -> bool: ...

    def isDoAlpha(self) -> bool: ...

    def isRemoved(self) -> bool: ...

    def remove(self) -> None: ...

    def removeTempSquareObjects(self) -> None: ...

    def setA(self, a: float) -> None: ...

    def setActive(self, active: bool) -> None: ...

    def setAlpha(self, alpha: float) -> None: ...

    def setAlphaMax(self, alphaMax: float) -> None: ...

    def setAlphaMin(self, alphaMin: float) -> None: ...

    def setB(self, b: float) -> None: ...

    def setDoAlpha(self, doAlpha: bool) -> None: ...

    def setFadeSpeed(self, fadeSpeed: float) -> None: ...

    def setG(self, g: float) -> None: ...

    def setPos(self, x: int, y: int, z: int) -> None: ...

    def setR(self, r: float) -> None: ...

    def setSquare(self, square: IsoGridSquare) -> None: ...

    def __init__(self): ...

  class CircleIsoMarker:

    def getA(self) -> float: ...

    def getAlpha(self) -> float: ...

    def getAlphaMax(self) -> float: ...

    def getAlphaMin(self) -> float: ...

    def getB(self) -> float: ...

    def getFadeSpeed(self) -> float: ...

    def getG(self) -> float: ...

    def getID(self) -> int: ...

    def getR(self) -> float: ...

    def getSize(self) -> float: ...

    def getSquare(self) -> IsoGridSquare: ...

    def getX(self) -> float: ...

    def getY(self) -> float: ...

    def getZ(self) -> float: ...

    def init(self, x: int, y: int, z: int, gs: IsoGridSquare) -> None: ...

    def isActive(self) -> bool: ...

    def isDoAlpha(self) -> bool: ...

    def isRemoved(self) -> bool: ...

    def remove(self) -> None: ...

    def setA(self, a: float) -> None: ...

    def setActive(self, active: bool) -> None: ...

    def setAlpha(self, alpha: float) -> None: ...

    def setAlphaMax(self, alphaMax: float) -> None: ...

    def setAlphaMin(self, alphaMin: float) -> None: ...

    def setB(self, b: float) -> None: ...

    def setDoAlpha(self, doAlpha: bool) -> None: ...

    def setFadeSpeed(self, fadeSpeed: float) -> None: ...

    def setG(self, g: float) -> None: ...

    def setPos(self, x: int, y: int, z: int) -> None: ...

    def setR(self, r: float) -> None: ...

    def setSize(self, size: float) -> None: ...

    def setSquare(self, square: IsoGridSquare) -> None: ...

    def __init__(self): ...


class IsoMetaCell:

  def Dispose(self) -> None: ...

  def addRoom(self, room: RoomDef, cellX: int, cellY: int) -> None: ...

  def addTrigger(self, arg0: BuildingDef, triggerRange: int, zombieExclusionRange: int, type: str) -> None: ...

  def addZone(self, zone: IsoMetaGrid.Zone, cellX: int, cellY: int) -> None: ...

  def checkTriggers(self) -> None: ...

  def getChunk(self, x: int, y: int) -> IsoMetaChunk: ...

  def getRoomsIntersecting(self, x: int, y: int, w: int, h: int, result: ArrayList[RoomDef]) -> None: ...

  def getZonesIntersecting(self, x: int, y: int, z: int, w: int, h: int, result: ArrayList[IsoMetaGrid.Zone]) -> None: ...

  def getZonesUnique(self, result: Set[IsoMetaGrid.Zone]) -> None: ...

  def removeZone(self, zone: IsoMetaGrid.Zone) -> None: ...

  def __init__(self, wx: int, wy: int):
    self.chunkmap: list[IsoMetaChunk]
    self.info: LotHeader
    self.mannequinzones: ArrayList[IsoMannequin.MannequinZone]
    self.roomtones: ArrayList[IsoMetaGrid.RoomTone]
    self.triggers: ArrayList[IsoMetaGrid.Trigger]
    self.vehiclezones: ArrayList[IsoMetaGrid.VehicleZone]


class IsoMetaChunk:

  zombiesFullPerChunk: float

  zombiesMinPerChunk: float

  def Dispose(self) -> None: ...

  def addRoom(self, room: RoomDef) -> None: ...

  def addZone(self, zone: IsoMetaGrid.Zone) -> None: ...

  def clearRooms(self) -> None: ...

  def clearZones(self) -> None: ...

  def getEmptyOutsideAt(self, x: int, y: int, z: int) -> RoomDef: ...

  def getLootZombieIntensity(self) -> float: ...

  def getNumRooms(self) -> int: ...

  def getRoomAt(self, x: int, y: int, z: int) -> RoomDef: ...

  def getRoomsIntersecting(self, x: int, y: int, w: int, h: int, result: ArrayList[RoomDef]) -> None: ...

  def getUnadjustedZombieIntensity(self) -> int: ...

  @overload
  def getZombieIntensity(self) -> float: ...

  @overload
  def getZombieIntensity(self, bRandom: bool) -> float: ...

  def getZone(self, index: int) -> IsoMetaGrid.Zone: ...

  def getZoneAt(self, x: int, y: int, z: int) -> IsoMetaGrid.Zone: ...

  def getZonesAt(self, x: int, y: int, z: int, result: ArrayList[IsoMetaGrid.Zone]) -> ArrayList[IsoMetaGrid.Zone]: ...

  def getZonesIntersecting(self, x: int, y: int, z: int, w: int, h: int, result: ArrayList[IsoMetaGrid.Zone]) -> None: ...

  def getZonesUnique(self, result: Set[IsoMetaGrid.Zone]) -> None: ...

  def numZones(self) -> int: ...

  def removeZone(self, zone: IsoMetaGrid.Zone) -> None: ...

  def setZombieIntensity(self, zombieIntensity: int) -> None: ...

  def __init__(self): ...


class IsoMetaGrid:

  def AddToMeta(self, isoPlayer: IsoGameCharacter) -> None: ...

  def Create(self) -> None: ...

  def CreateStep1(self) -> None: ...

  def CreateStep2(self) -> None: ...

  def Dispose(self) -> None: ...

  def RemoveFromMeta(self, isoPlayer: IsoPlayer) -> None: ...

  def checkVehiclesZones(self) -> None: ...

  def countNearbyBuildingsRooms(self, isoPlayer: IsoPlayer) -> int: ...

  def countRoomsIntersecting(self, x: int, y: int, w: int, h: int) -> int: ...

  def getBuildingAt(self, x: int, y: int) -> BuildingDef: ...

  def getBuildingAtRelax(self, x: int, y: int) -> BuildingDef: ...

  def getCellData(self, x: int, y: int) -> IsoMetaCell: ...

  def getCellDataAbs(self, x: int, y: int) -> IsoMetaCell: ...

  def getChunkData(self, cx: int, cy: int) -> IsoMetaChunk: ...

  def getChunkDataFromTile(self, x: int, y: int) -> IsoMetaChunk: ...

  def getCurrentCellData(self) -> IsoMetaCell: ...

  def getCurrentChunkData(self) -> IsoMetaChunk: ...

  def getEmptyOutsideAt(self, x: int, y: int, z: int) -> RoomDef: ...

  def getHeight(self) -> int: ...

  def getLotDirectories(self) -> ArrayList[str]: ...

  def getMaxX(self) -> int: ...

  def getMaxY(self) -> int: ...

  def getMetaGridFromTile(self, wx: int, wy: int) -> IsoMetaCell: ...

  def getMinX(self) -> int: ...

  def getMinY(self) -> int: ...

  def getRandomIndoorCoord(self) -> Vector2: ...

  def getRandomRoomBetweenRange(self, x: float, y: float, min: float, max: float) -> RoomDef: ...

  def getRandomRoomNotInRange(self, x: float, y: float, range: int) -> RoomDef: ...

  def getRoomAt(self, x: int, y: int, z: int) -> RoomDef: ...

  def getRoomsIntersecting(self, x: int, y: int, w: int, h: int, roomDefs: ArrayList[RoomDef]) -> None: ...

  def getVehicleZoneAt(self, x: int, y: int, z: int) -> IsoMetaGrid.VehicleZone: ...

  def getWidth(self) -> int: ...

  def getZoneAt(self, x: int, y: int, z: int) -> IsoMetaGrid.Zone: ...

  def getZoneWithBoundsAndType(self, x: int, y: int, z: int, w: int, h: int, type: str) -> IsoMetaGrid.Zone: ...

  @overload
  def getZonesAt(self, x: int, y: int, z: int) -> ArrayList[IsoMetaGrid.Zone]: ...

  @overload
  def getZonesAt(self, x: int, y: int, z: int, result: ArrayList[IsoMetaGrid.Zone]) -> ArrayList[IsoMetaGrid.Zone]: ...

  @overload
  def getZonesIntersecting(self, x: int, y: int, z: int, w: int, h: int) -> ArrayList[IsoMetaGrid.Zone]: ...

  @overload
  def getZonesIntersecting(self, x: int, y: int, z: int, w: int, h: int, result: ArrayList[IsoMetaGrid.Zone]) -> ArrayList[IsoMetaGrid.Zone]: ...

  def isValidChunk(self, wx: int, wy: int) -> bool: ...

  def isValidSquare(self, x: int, y: int) -> bool: ...

  def isZoneAbove(self, zone1: IsoMetaGrid.Zone, zone2: IsoMetaGrid.Zone, x: int, y: int, z: int) -> bool: ...

  @overload
  def load(self) -> None: ...

  @overload
  def load(self, input: ByteBuffer) -> None: ...

  def loadZone(self, input: ByteBuffer, WorldVersion: int) -> None: ...

  def loadZones(self) -> None: ...

  def processZones(self) -> None: ...

  def registerGeometryZone(self, name: str, type: str, z: int, geometry: str, pointsTable: KahluaTable, properties: KahluaTable) -> IsoMetaGrid.Zone: ...

  def registerMannequinZone(self, name: str, type: str, x: int, y: int, z: int, width: int, height: int, properties: KahluaTable) -> IsoMetaGrid.Zone: ...

  def registerRoomTone(self, name: str, type: str, x: int, y: int, z: int, width: int, height: int, properties: KahluaTable) -> None: ...

  def registerVehiclesZone(self, name: str, type: str, x: int, y: int, z: int, width: int, height: int, properties: KahluaTable) -> IsoMetaGrid.Zone: ...

  @overload
  def registerZone(self, name: str, type: str, x: int, y: int, z: int, width: int, height: int) -> IsoMetaGrid.Zone: ...

  @overload
  def registerZone(self, name: str, type: str, x: int, y: int, z: int, width: int, height: int, geometryType: IsoMetaGrid.ZoneGeometryType, points: TIntArrayList, polylineWidth: int) -> IsoMetaGrid.Zone: ...

  def registerZoneNoOverlap(self, name: str, type: str, x: int, y: int, z: int, width: int, height: int) -> IsoMetaGrid.Zone: ...

  def removeZone(self, zone: IsoMetaGrid.Zone) -> None: ...

  def removeZonesForCell(self, cellX: int, cellY: int) -> None: ...

  def removeZonesForLotDirectory(self, lotDir: str) -> None: ...

  @overload
  def save(self) -> None: ...

  @overload
  def save(self, output: ByteBuffer) -> None: ...

  def savePart(self, output: ByteBuffer, part: int, fromServer: bool) -> None: ...

  def saveZone(self, output: ByteBuffer) -> None: ...

  @staticmethod
  def isPreferredZoneForSquare(type: str) -> bool: ...

  def __init__(self):
    self.buildings: ArrayList[BuildingDef]
    self.grid: list[list[IsoMetaCell]]
    self.maxx: int
    self.maxy: int
    self.metacharacters: ArrayList[IsoGameCharacter]
    self.minx: int
    self.miny: int
    self.vehicleszones: ArrayList[IsoMetaGrid.VehicleZone]
    self.zones: ArrayList[IsoMetaGrid.Zone]

  class MetaGridLoaderThread(Thread):

    def run(self) -> None: ...

  class Zone:

    def Dispose(self) -> None: ...

    def addSquare(self, sq: IsoGridSquare) -> None: ...

    def contains(self, x: int, y: int, z: int) -> bool: ...

    def difference(self, x: int, y: int, z: int, w: int, h: int, result: ArrayList[IsoMetaGrid.Zone]) -> bool: ...

    def getClippedSegmentOfPolyline(self, clipX1: int, clipY1: int, clipX2: int, clipY2: int, t1t2: list[float]) -> int: ...

    def getHeight(self) -> int: ...

    def getHoursSinceLastSeen(self) -> float: ...

    def getLastActionTimestamp(self) -> int: ...

    def getName(self) -> str: ...

    def getOriginalName(self) -> str: ...

    def getPolygonTriangles(self) -> list[float]: ...

    def getPolylineLength(self) -> float: ...

    def getPolylineOutlineTriangles(self) -> list[float]: ...

    def getRandomSquareInZone(self) -> IsoGridSquare: ...

    def getRandomUnseenSquareInZone(self) -> IsoGridSquare: ...

    def getSquares(self) -> ArrayList[IsoGridSquare]: ...

    def getTotalArea(self) -> float: ...

    def getType(self) -> str: ...

    def getWidth(self) -> int: ...

    def getX(self) -> int: ...

    def getY(self) -> int: ...

    def getZ(self) -> int: ...

    def getZombieDensity(self) -> int: ...

    def haveCons(self) -> bool: ...

    def intersects(self, x: int, y: int, z: int, w: int, h: int) -> bool: ...

    def isPoint(self) -> bool: ...

    def isPolygon(self) -> bool: ...

    def isPolyline(self) -> bool: ...

    def isRectangle(self) -> bool: ...

    def pickRandomLocation(self, location: IsoGameCharacter.Location) -> IsoGameCharacter.Location: ...

    def removeSquare(self, sq: IsoGridSquare) -> None: ...

    def sendToServer(self) -> None: ...

    def setH(self, h: int) -> None: ...

    def setHaveConstruction(self, have: bool) -> None: ...

    def setHourSeenToCurrent(self) -> None: ...

    def setLastActionTimestamp(self, lastActionTimestamp: int) -> None: ...

    def setName(self, name: str) -> None: ...

    def setOriginalName(self, originalName: str) -> None: ...

    def setPickedXForZoneStory(self, pickedXForZoneStory: int) -> None: ...

    def setPickedYForZoneStory(self, pickedYForZoneStory: int) -> None: ...

    def setType(self, type: str) -> None: ...

    def setW(self, w: int) -> None: ...

    def setX(self, x: int) -> None: ...

    def setY(self, y: int) -> None: ...

    def __init__(self, name: str, type: str, x: int, y: int, z: int, w: int, h: int):
      self.geometrytype: IsoMetaGrid.ZoneGeometryType
      self.h: int
      self.haveconstruction: bool
      self.hourlastseen: int
      self.id: Double
      self.ispreferredzoneforsquare: bool
      self.lastactiontimestamp: int
      self.name: str
      self.pickedrzstory: RandomizedZoneStoryBase
      self.pickedxforzonestory: int
      self.pickedyforzonestory: int
      self.points: TIntArrayList
      self.polylineoutlinepoints: list[float]
      self.polylinewidth: int
      self.spawnedzombies: HashMap[str, Integer]
      self.spawnspecialzombies: Boolean
      self.totalarea: float
      self.triangleareas: list[float]
      self.triangles: list[float]
      self.type: str
      self.w: int
      self.x: int
      self.y: int
      self.z: int
      self.zombiestypetospawn: str

    class PolygonHit(Enum):

      Inside: IsoMetaGrid.Zone.PolygonHit

      OnEdge: IsoMetaGrid.Zone.PolygonHit

      Outside: IsoMetaGrid.Zone.PolygonHit

      @staticmethod
      def valueOf(arg0: str) -> IsoMetaGrid.Zone.PolygonHit: ...

      @staticmethod
      def values() -> list[IsoMetaGrid.Zone.PolygonHit]: ...

  class VehicleZone(IsoMetaGrid.Zone):

    VZF_FaceDirection: int

    def isFaceDirection(self) -> bool: ...

    def __init__(self, name: str, type: str, x: int, y: int, z: int, w: int, h: int, properties: KahluaTable):
      self.dir: IsoDirections
      self.flags: int

  class ZoneGeometryType(Enum):

    INVALID: IsoMetaGrid.ZoneGeometryType

    Point: IsoMetaGrid.ZoneGeometryType

    Polygon: IsoMetaGrid.ZoneGeometryType

    Polyline: IsoMetaGrid.ZoneGeometryType

    @staticmethod
    def valueOf(arg0: str) -> IsoMetaGrid.ZoneGeometryType: ...

    @staticmethod
    def values() -> list[IsoMetaGrid.ZoneGeometryType]: ...

  class RoomTone:

    def __init__(self):
      self.entirebuilding: bool
      self.enumvalue: str
      self.x: int
      self.y: int
      self.z: int

  class Trigger:

    def getModData(self) -> KahluaTable: ...

    def __init__(self, arg0: BuildingDef, triggerRange: int, zombieExclusionRange: int, type: str):
      self.data: KahluaTable
      # self.def: BuildingDef
      self.triggered: bool
      self.triggerrange: int
      self.type: str
      self.zombieexclusionrange: int


class IsoMovingObject(IsoObject):

  MAX_ZOMBIES_EATING: int

  treeSoundMgr: IsoMovingObject.TreeSoundManager

  def Despawn(self) -> None: ...

  @overload
  def DistTo(self, other: IsoMovingObject) -> float: ...

  @overload
  def DistTo(self, x: int, y: int) -> float: ...

  def DistToProper(self, other: IsoObject) -> float: ...

  @overload
  def DistToSquared(self, other: IsoMovingObject) -> float: ...

  @overload
  def DistToSquared(self, x: float, y: float) -> float: ...

  def DoCollideNorS(self) -> None: ...

  def DoCollideWorE(self) -> None: ...

  def Hit(self, weapon: HandWeapon, wielder: IsoGameCharacter, damageSplit: float, bIgnoreDamage: bool, modDelta: float) -> float: ...

  def Move(self, dir: Vector2) -> None: ...

  def MoveUnmodded(self, dir: Vector2) -> None: ...

  def canHaveMultipleHits(self) -> int: ...

  def collideWith(self, obj: IsoObject) -> None: ...

  def compareToY(self, other: IsoMovingObject) -> int: ...

  def distToNearestCamCharacter(self) -> float: ...

  def doStairs(self) -> None: ...

  def ensureOnTile(self) -> None: ...

  def getBuilding(self) -> IsoBuilding: ...

  def getBumpedType(self, bumped: IsoGameCharacter) -> str: ...

  def getCollideType(self) -> str: ...

  def getCollidedObject(self) -> IsoObject: ...

  def getCurrentBuilding(self) -> IsoBuilding: ...

  def getCurrentSquare(self) -> IsoGridSquare: ...

  def getCurrentZone(self) -> IsoMetaGrid.Zone: ...

  def getDistanceSq(self, other: IsoMovingObject) -> float: ...

  def getEatingZombies(self) -> ArrayList[IsoZombie]: ...

  def getFacingPosition(self, pos: Vector2) -> Vector2: ...

  def getFeelerTile(self, dist: float) -> IsoGridSquare: ...

  def getFeelersize(self) -> float: ...

  def getFuturWalkedSquare(self) -> IsoGridSquare: ...

  @overload
  def getGlobalMovementMod(self) -> float: ...

  @overload
  def getGlobalMovementMod(self, bDoNoises: bool) -> float: ...

  def getHitDir(self) -> Vector2: ...

  def getHitForce(self) -> float: ...

  def getHitFromAngle(self) -> float: ...

  @overload
  def getID(self) -> int: ...

  @overload
  def getID(self) -> int: ...

  def getImpulsex(self) -> float: ...

  def getImpulsey(self) -> float: ...

  def getLastCollideTime(self) -> float: ...

  def getLastSquare(self) -> IsoGridSquare: ...

  def getLastTargettedBy(self) -> IsoZombie: ...

  def getLimpulsex(self) -> float: ...

  def getLimpulsey(self) -> float: ...

  def getLx(self) -> float: ...

  def getLy(self) -> float: ...

  def getLz(self) -> float: ...

  def getMasterRegion(self) -> IWorldRegion: ...

  def getMovementLastFrame(self) -> Vector2: ...

  def getNoDamage(self) -> bool: ...

  def getNx(self) -> float: ...

  def getNy(self) -> float: ...

  def getObjectName(self) -> str: ...

  @overload
  def getPathFindIndex(self) -> int: ...

  @overload
  def getPathFindIndex(self) -> int: ...

  def getPosition(self, out: Vector3) -> Vector3: ...

  def getScreenX(self) -> float: ...

  def getScreenY(self) -> float: ...

  def getScriptModule(self) -> str: ...

  def getScriptnx(self) -> float: ...

  def getScriptny(self) -> float: ...

  def getSquare(self) -> IsoGridSquare: ...

  def getStateEventDelayTimer(self) -> float: ...

  def getThumpTarget(self) -> Thumpable: ...

  def getTimeSinceZombieAttack(self) -> int: ...

  def getVectorFromDirection(self, moveForwardVec: Vector2) -> Vector2: ...

  @overload
  def getWeight(self) -> float: ...

  @overload
  def getWeight(self, x: float, y: float) -> float: ...

  def getWidth(self) -> float: ...

  def getX(self) -> float: ...

  def getY(self) -> float: ...

  def getZ(self) -> float: ...

  def isCharacter(self) -> bool: ...

  def isCloseKilled(self) -> bool: ...

  def isCollidable(self) -> bool: ...

  def isCollided(self) -> bool: ...

  def isCollidedE(self) -> bool: ...

  def isCollidedN(self) -> bool: ...

  def isCollidedS(self) -> bool: ...

  def isCollidedThisFrame(self) -> bool: ...

  def isCollidedW(self) -> bool: ...

  def isCollidedWithDoor(self) -> bool: ...

  def isCollidedWithVehicle(self) -> bool: ...

  def isDestroyed(self) -> bool: ...

  def isEatingOther(self, other: IsoMovingObject) -> bool: ...

  def isFirstUpdate(self) -> bool: ...

  def isOnFloor(self) -> bool: ...

  def isPushableForSeparate(self) -> bool: ...

  def isPushedByForSeparate(self, other: IsoMovingObject) -> bool: ...

  def isShootable(self) -> bool: ...

  def isSolid(self) -> bool: ...

  def isSolidForSeparate(self) -> bool: ...

  def isZombiesDontAttack(self) -> bool: ...

  def isbAltCollide(self) -> bool: ...

  def load(self, input: ByteBuffer, WorldVersion: int, IS_DEBUG_SAVE: bool) -> None: ...

  def onMouseRightClick(self, lx: int, ly: int) -> None: ...

  def onMouseRightReleased(self) -> None: ...

  def postupdate(self) -> None: ...

  def preupdate(self) -> None: ...

  def removeFromSquare(self) -> None: ...

  def removeFromWorld(self) -> None: ...

  def renderlast(self) -> None: ...

  def save(self, output: ByteBuffer, IS_DEBUG_SAVE: bool) -> None: ...

  def separate(self) -> None: ...

  def setCloseKilled(self, closeKilled: bool) -> None: ...

  def setCollidable(self, Collidable: bool) -> None: ...

  def setCollideType(self, collideType: str) -> None: ...

  def setCollidedE(self, collidedE: bool) -> None: ...

  def setCollidedN(self, collidedN: bool) -> None: ...

  def setCollidedObject(self, CollidedObject: IsoObject) -> None: ...

  def setCollidedS(self, collidedS: bool) -> None: ...

  def setCollidedThisFrame(self, collidedThisFrame: bool) -> None: ...

  def setCollidedW(self, collidedW: bool) -> None: ...

  def setCollidedWithDoor(self, CollidedWithDoor: bool) -> None: ...

  def setCurrent(self, current: IsoGridSquare) -> None: ...

  def setDestroyed(self, destroyed: bool) -> None: ...

  def setEatingZombies(self, zeds: ArrayList[IsoZombie]) -> None: ...

  def setFeelersize(self, feelersize: float) -> None: ...

  def setFirstUpdate(self, firstUpdate: bool) -> None: ...

  def setHitDir(self, hitDir: Vector2) -> None: ...

  def setHitForce(self, hitForce: float) -> None: ...

  def setHitFromAngle(self, hitFromAngle: float) -> None: ...

  def setID(self, ID: int) -> None: ...

  def setImpulsex(self, impulsex: float) -> None: ...

  def setImpulsey(self, impulsey: float) -> None: ...

  def setLast(self, last: IsoGridSquare) -> None: ...

  def setLastCollideTime(self, lastCollideTime: float) -> None: ...

  def setLastTargettedBy(self, lastTargettedBy: IsoZombie) -> None: ...

  def setLimpulsex(self, limpulsex: float) -> None: ...

  def setLimpulsey(self, limpulsey: float) -> None: ...

  def setLx(self, lx: float) -> None: ...

  def setLy(self, ly: float) -> None: ...

  def setLz(self, lz: float) -> None: ...

  def setMovementLastFrame(self, movementLastFrame: Vector2) -> None: ...

  def setMovingSquareNow(self) -> None: ...

  def setNoDamage(self, dmg: bool) -> None: ...

  def setNx(self, nx: float) -> None: ...

  def setNy(self, ny: float) -> None: ...

  def setOnFloor(self, bOnFloor: bool) -> None: ...

  def setPathFindIndex(self, PathFindIndex: int) -> None: ...

  def setScriptModule(self, ScriptModule: str) -> None: ...

  def setScriptnx(self, scriptnx: float) -> None: ...

  def setScriptny(self, scriptny: float) -> None: ...

  def setShootable(self, shootable: bool) -> None: ...

  def setSolid(self, solid: bool) -> None: ...

  def setStateEventDelayTimer(self, StateEventDelayTimer: float) -> None: ...

  def setThumpTarget(self, thumpTarget: Thumpable) -> None: ...

  def setTimeSinceZombieAttack(self, TimeSinceZombieAttack: int) -> None: ...

  def setWeight(self, weight: float) -> None: ...

  def setWidth(self, width: float) -> None: ...

  def setX(self, x: float) -> None: ...

  def setY(self, y: float) -> None: ...

  def setZ(self, z: float) -> None: ...

  def setZombiesDontAttack(self, b: bool) -> None: ...

  def setbAltCollide(self, bAltCollide: bool) -> None: ...

  def spotted(self, other: IsoMovingObject, bForced: bool) -> None: ...

  def update(self) -> None: ...

  @staticmethod
  def getIDCount() -> int: ...

  @staticmethod
  def setIDCount(aIDCount: int) -> None: ...

  @overload
  def __init__(self):
    self.boutline: list[bool]

    # self.def: IsoSpriteInstance

    self.last: IsoGridSquare

    self.lx: float

    self.ly: float

    self.lz: float

    self.nodamage: bool

    self.nx: float

    self.ny: float

    self.outlinecolor: list[ColorInfo]

    self.x: float

    self.y: float

    self.z: float

  @overload
  def __init__(self, cell: IsoCell): ...
  @overload
  def __init__(self, cell: IsoCell, bObjectListAdd: bool): ...
  @overload
  def __init__(self, cell: IsoCell, square: IsoGridSquare, spr: IsoSprite, bObjectListAdd: bool): ...

  class TreeSoundManager:

    def addSquare(self, square: IsoGridSquare) -> None: ...

    def update(self) -> None: ...

    def __init__(self): ...

  class L_postUpdate: ...

  class L_slideAwayFromWalls: ...


class IsoObject:

  bmod: float

  gmod: float

  lastRendered: IsoObject

  lastRenderedRendered: IsoObject

  LowLightingQualityHack: bool

  MAX_WALL_SPLATS: int

  OBF_Blink: int

  OBF_Highlighted: int

  OBF_HighlightRenderOnce: int

  rmod: float

  def AttachAnim(self, ObjectName: str, AnimName: str, NumFrames: int, frameIncrease: float, OffsetX: int, OffsetY: int, Looping: bool, FinishHoldFrameIndex: int, DeleteWhenFinished: bool, zBias: float, TintMod: ColorInfo) -> None: ...

  @overload
  def AttachExistingAnim(self, spr: IsoSprite, OffsetX: int, OffsetY: int, Looping: bool, FinishHoldFrameIndex: int, DeleteWhenFinished: bool, zBias: float) -> None: ...

  @overload
  def AttachExistingAnim(self, spr: IsoSprite, OffsetX: int, OffsetY: int, Looping: bool, FinishHoldFrameIndex: int, DeleteWhenFinished: bool, zBias: float, TintMod: ColorInfo) -> None: ...

  def AttackObject(self, owner: IsoGameCharacter) -> None: ...

  def Collision(self, collision: Vector2, object: IsoObject) -> None: ...

  def Damage(self, amount: float) -> None: ...

  def DirtySlice(self) -> None: ...

  def DoSpecialTooltip(self, tooltipUI: ObjectTooltip, square: IsoGridSquare) -> None: ...

  def DoTooltip(self, tooltipUI: ObjectTooltip) -> None: ...

  def GetVehicleSlowFactor(self, vehicle: BaseVehicle) -> float: ...

  def HasTooltip(self) -> bool: ...

  def Hit(self, collision: Vector2, obj: IsoObject, damage: float) -> None: ...

  def HitByVehicle(self, vehicle: BaseVehicle, amount: float) -> None: ...

  def RemoveAttachedAnim(self, index: int) -> None: ...

  def RemoveAttachedAnims(self) -> None: ...

  def Serialize(self) -> bool: ...

  def SetName(self, name: str) -> None: ...

  def TestCollide(self, obj: IsoMovingObject, arg1: IsoGridSquare, to: IsoGridSquare) -> bool: ...

  def TestPathfindCollide(self, obj: IsoMovingObject, arg1: IsoGridSquare, to: IsoGridSquare) -> bool: ...

  def TestVision(self, arg0: IsoGridSquare, to: IsoGridSquare) -> IsoObject.VisionResult: ...

  @overload
  def Thump(self, thumper: IsoMovingObject) -> None: ...

  @overload
  def Thump(self, thumper: IsoMovingObject) -> None: ...

  def UnCollision(self, object: IsoObject) -> None: ...

  @overload
  def WeaponHit(self, chr: IsoGameCharacter, weapon: HandWeapon) -> None: ...

  @overload
  def WeaponHit(self, chr: IsoGameCharacter, weapon: HandWeapon) -> None: ...

  def addChild(self, child: IsoObject) -> None: ...

  def addSecondaryContainer(self, container: ItemContainer) -> None: ...

  def addSheetRope(self, player: IsoPlayer, itemType: str) -> bool: ...

  def addToWorld(self) -> None: ...

  def canAddSheetRope(self) -> bool: ...

  def checkAmbientSound(self) -> None: ...

  def checkHaveElectricity(self) -> None: ...

  def cleanWallBlood(self) -> None: ...

  def clearAttachedAnimSprite(self) -> None: ...

  def countAddSheetRope(self) -> int: ...

  def createContainersFromSpriteProperties(self) -> None: ...

  def customHashCode(self) -> int: ...

  def debugPrintout(self) -> None: ...

  def destroyFence(self, dir: IsoDirections) -> None: ...

  def doFindExternalWaterSource(self) -> None: ...

  @overload
  def getAlpha(self) -> float: ...

  @overload
  def getAlpha(self, playerIndex: int) -> float: ...

  def getAttachedAnimSprite(self) -> ArrayList[IsoSpriteInstance]: ...

  def getCell(self) -> IsoCell: ...

  def getChildSprites(self) -> ArrayList[IsoSpriteInstance]: ...

  def getChunk(self) -> IsoChunk: ...

  def getContainer(self) -> ItemContainer: ...

  def getContainerByEitherType(self, type1: str, type2: str) -> ItemContainer: ...

  def getContainerByIndex(self, index: int) -> ItemContainer: ...

  def getContainerByType(self, type: str) -> ItemContainer: ...

  def getContainerCount(self) -> int: ...

  def getContainerIndex(self, container: ItemContainer) -> int: ...

  def getCustomColor(self) -> ColorInfo: ...

  def getDamage(self) -> int: ...

  def getDir(self) -> IsoDirections: ...

  def getFacingPosition(self, pos: Vector2) -> Vector2: ...

  def getFacingPositionAlt(self, pos: Vector2) -> Vector2: ...

  def getHighlightColor(self) -> ColorInfo: ...

  def getIsSurfaceNormalOffset(self) -> bool: ...

  def getItemContainer(self) -> ItemContainer: ...

  def getKeyId(self) -> int: ...

  def getMaskClickedY(self, x: int, y: int, flip: bool) -> float: ...

  def getModData(self) -> KahluaTable: ...

  def getMovingObjectIndex(self) -> int: ...

  def getName(self) -> str: ...

  def getObjectIndex(self) -> int: ...

  def getObjectName(self) -> str: ...

  def getObjectRenderEffects(self) -> ObjectRenderEffects: ...

  def getObjectRenderEffectsToApply(self) -> ObjectRenderEffects: ...

  def getOffsetX(self) -> float: ...

  def getOffsetY(self) -> float: ...

  @overload
  def getOutlineHighlightCol(self) -> int: ...

  @overload
  def getOutlineHighlightCol(self, playerIndex: int) -> int: ...

  def getOutlineThickness(self) -> float: ...

  def getOverlaySprite(self) -> IsoSprite: ...

  def getOverlaySpriteColor(self) -> ColorInfo: ...

  def getPipedFuelAmount(self) -> int: ...

  def getProperties(self) -> PropertyContainer: ...

  def getRenderEffectMaster(self) -> IsoObject: ...

  def getRenderYOffset(self) -> float: ...

  def getRerouteCollide(self) -> IsoObject: ...

  def getRerouteMask(self) -> IsoObject: ...

  def getRerouteMaskObject(self) -> IsoObject: ...

  def getScriptName(self) -> str: ...

  def getSpecialObjectIndex(self) -> int: ...

  def getSprite(self) -> IsoSprite: ...

  def getSpriteGridObjects(self, result: ArrayList[IsoObject]) -> None: ...

  def getSpriteName(self) -> str: ...

  def getSquare(self) -> IsoGridSquare: ...

  def getStaticMovingObjectIndex(self) -> int: ...

  def getSurfaceNormalOffset(self) -> float: ...

  def getSurfaceOffset(self) -> float: ...

  def getSurfaceOffsetNoTable(self) -> float: ...

  def getTable(self) -> KahluaTable: ...

  @overload
  def getTargetAlpha(self) -> float: ...

  @overload
  def getTargetAlpha(self, playerIndex: int) -> float: ...

  def getTextureName(self) -> str: ...

  @overload
  def getThumpCondition(self) -> float: ...

  @overload
  def getThumpCondition(self) -> float: ...

  @overload
  def getThumpableFor(self, chr: IsoGameCharacter) -> Thumpable: ...

  @overload
  def getThumpableFor(self, chr: IsoGameCharacter) -> Thumpable: ...

  def getTile(self) -> str: ...

  def getType(self) -> IsoObjectType: ...

  def getUsesExternalWaterSource(self) -> bool: ...

  def getWaterAmount(self) -> int: ...

  def getWaterMax(self) -> int: ...

  def getWindRenderEffects(self) -> ObjectRenderEffects: ...

  def getWorldObjectIndex(self) -> int: ...

  def getX(self) -> float: ...

  def getY(self) -> float: ...

  def getZ(self) -> float: ...

  def hasExternalWaterSource(self) -> bool: ...

  def hasModData(self) -> bool: ...

  def hasWater(self) -> bool: ...

  def haveSheetRope(self) -> bool: ...

  def haveSpecialTooltip(self) -> bool: ...

  @overload
  def isAlphaAndTargetZero(self) -> bool: ...

  @overload
  def isAlphaAndTargetZero(self, playerIndex: int) -> bool: ...

  @overload
  def isAlphaZero(self) -> bool: ...

  @overload
  def isAlphaZero(self, playerIndex: int) -> bool: ...

  def isBlink(self) -> bool: ...

  def isCharacter(self) -> bool: ...

  @overload
  def isDestroyed(self) -> bool: ...

  @overload
  def isDestroyed(self) -> bool: ...

  def isExistInTheWorld(self) -> bool: ...

  def isFloor(self) -> bool: ...

  def isHighlighted(self) -> bool: ...

  def isHoppable(self) -> bool: ...

  def isItemAllowedInContainer(self, container: ItemContainer, item: InventoryItem) -> bool: ...

  @overload
  def isMaskClicked(self, x: int, y: int) -> bool: ...

  @overload
  def isMaskClicked(self, x: int, y: int, flip: bool) -> bool: ...

  def isMovedThumpable(self) -> bool: ...

  def isNoPicking(self) -> bool: ...

  def isNorthHoppable(self) -> bool: ...

  @overload
  def isOutlineHighlight(self) -> bool: ...

  @overload
  def isOutlineHighlight(self, playerIndex: int) -> bool: ...

  @overload
  def isOutlineHlAttached(self) -> bool: ...

  @overload
  def isOutlineHlAttached(self, playerIndex: int) -> bool: ...

  @overload
  def isOutlineHlBlink(self) -> bool: ...

  @overload
  def isOutlineHlBlink(self, playerIndex: int) -> bool: ...

  def isOutlineOnMouseover(self) -> bool: ...

  def isRemoveItemAllowedFromContainer(self, container: ItemContainer, item: InventoryItem) -> bool: ...

  def isSpriteInvisible(self) -> bool: ...

  def isStairsNorth(self) -> bool: ...

  def isStairsObject(self) -> bool: ...

  def isStairsWest(self) -> bool: ...

  def isTableSurface(self) -> bool: ...

  def isTableTopObject(self) -> bool: ...

  def isTaintedWater(self) -> bool: ...

  def isTargetAlphaZero(self, playerIndex: int) -> bool: ...

  def isZombie(self) -> bool: ...

  @overload
  def load(self, input: ByteBuffer, WorldVersion: int) -> None: ...

  @overload
  def load(self, input: ByteBuffer, WorldVersion: int, IS_DEBUG_SAVE: bool) -> None: ...

  def loadChange(self, change: str, bb: ByteBuffer) -> None: ...

  @overload
  def loadFromRemoteBuffer(self, b: ByteBuffer) -> None: ...

  @overload
  def loadFromRemoteBuffer(self, b: ByteBuffer, addToObjects: bool) -> None: ...

  def loadState(self, bb: ByteBuffer) -> None: ...

  def onMouseLeftClick(self, x: int, y: int) -> bool: ...

  def onMouseRightClick(self, lx: int, ly: int) -> None: ...

  def onMouseRightReleased(self) -> None: ...

  def removeAllContainers(self) -> None: ...

  def removeFromSquare(self) -> None: ...

  def removeFromWorld(self) -> None: ...

  def removeRenderEffect(self, o: ObjectRenderEffects) -> None: ...

  def removeSheetRope(self, player: IsoPlayer) -> bool: ...

  def render(self, x: float, y: float, z: float, col: ColorInfo, bDoAttached: bool, bWallLightingPass: bool, shader: Shader) -> None: ...

  def renderAttachedAndOverlaySprites(self, x: float, y: float, z: float, col: ColorInfo, bDoAttached: bool, bWallLightingPass: bool, shader: Shader, texdModifier: Consumer[TextureDraw]) -> None: ...

  def renderFloorTile(self, x: float, y: float, z: float, col: ColorInfo, bDoAttached: bool, bWallLightingPass: bool, shader: Shader, texdModifier: Consumer[TextureDraw], attachedAndOverlayModifier: Consumer[TextureDraw]) -> None: ...

  def renderFxMask(self, x: float, y: float, z: float, bDoAttached: bool) -> None: ...

  def renderObjectPicker(self, x: float, y: float, z: float, lightInfo: ColorInfo) -> None: ...

  def renderWallTile(self, x: float, y: float, z: float, col: ColorInfo, bDoAttached: bool, bWallLightingPass: bool, shader: Shader, texdModifier: Consumer[TextureDraw]) -> None: ...

  def renderWallTileOnly(self, x: float, y: float, z: float, col: ColorInfo, shader: Shader, texdModifier: Consumer[TextureDraw]) -> None: ...

  def renderlast(self) -> None: ...

  def replaceItem(self, item: InventoryItem) -> InventoryItem: ...

  def reset(self) -> None: ...

  def reuseGridSquare(self) -> None: ...

  @overload
  def save(self, output: ByteBuffer) -> None: ...

  @overload
  def save(self, output: ByteBuffer, IS_DEBUG_SAVE: bool) -> None: ...

  def saveChange(self, change: str, tbl: KahluaTable, bb: ByteBuffer) -> None: ...

  def saveState(self, bb: ByteBuffer) -> None: ...

  @overload
  def sendObjectChange(self, change: str) -> None: ...

  @overload
  def sendObjectChange(self, arg0: str, arg1: list[object]) -> None: ...

  @overload
  def sendObjectChange(self, change: str, tbl: KahluaTable) -> None: ...

  @overload
  def setAlpha(self, alpha: float) -> None: ...

  @overload
  def setAlpha(self, playerIndex: int, alpha: float) -> None: ...

  @overload
  def setAlphaAndTarget(self, alpha: float) -> None: ...

  @overload
  def setAlphaAndTarget(self, playerIndex: int, alpha: float) -> None: ...

  def setAlphaToTarget(self, playerIndex: int) -> None: ...

  def setAttachedAnimSprite(self, AttachedAnimSprite: ArrayList[IsoSpriteInstance]) -> None: ...

  def setBlink(self, blink: bool) -> None: ...

  def setChildSprites(self, AttachedAnimSprite: ArrayList[IsoSpriteInstance]) -> None: ...

  def setContainer(self, container: ItemContainer) -> None: ...

  @overload
  def setCustomColor(self, col: ColorInfo) -> None: ...

  @overload
  def setCustomColor(self, r: float, g: float, b: float, a: float) -> None: ...

  def setDamage(self, Damage: int) -> None: ...

  @overload
  def setDir(self, dir: int) -> None: ...

  @overload
  def setDir(self, dir: IsoDirections) -> None: ...

  @overload
  def setHighlightColor(self, highlightColor: ColorInfo) -> None: ...

  @overload
  def setHighlightColor(self, r: float, g: float, b: float, a: float) -> None: ...

  @overload
  def setHighlighted(self, highlight: bool) -> None: ...

  @overload
  def setHighlighted(self, highlight: bool, renderOnce: bool) -> None: ...

  def setKeyId(self, keyId: int) -> None: ...

  def setMovedThumpable(self, movedThumpable: bool) -> None: ...

  def setName(self, name: str) -> None: ...

  def setNoPicking(self, NoPicking: bool) -> None: ...

  def setOffsetX(self, offsetX: float) -> None: ...

  def setOffsetY(self, offsetY: float) -> None: ...

  @overload
  def setOutlineHighlight(self, isOutlineHighlight: bool) -> None: ...

  @overload
  def setOutlineHighlight(self, playerIndex: int, isOutlineHighlight: bool) -> None: ...

  @overload
  def setOutlineHighlightCol(self, outlineHighlightCol: ColorInfo) -> None: ...

  @overload
  def setOutlineHighlightCol(self, playerIndex: int, outlineHighlightCol: ColorInfo) -> None: ...

  @overload
  def setOutlineHighlightCol(self, r: float, g: float, b: float, a: float) -> None: ...

  @overload
  def setOutlineHighlightCol(self, playerIndex: int, r: float, g: float, b: float, a: float) -> None: ...

  @overload
  def setOutlineHlAttached(self, isOutlineHlAttached: bool) -> None: ...

  @overload
  def setOutlineHlAttached(self, playerIndex: int, isOutlineHlAttached: bool) -> None: ...

  @overload
  def setOutlineHlBlink(self, isOutlineHlBlink: bool) -> None: ...

  @overload
  def setOutlineHlBlink(self, playerIndex: int, isOutlineHlBlink: bool) -> None: ...

  def setOutlineOnMouseover(self, OutlineOnMouseover: bool) -> None: ...

  def setOutlineThickness(self, outlineThickness: float) -> None: ...

  @overload
  def setOverlaySprite(self, spriteName: str) -> None: ...

  @overload
  def setOverlaySprite(self, spriteName: str, bTransmit: bool) -> None: ...

  @overload
  def setOverlaySprite(self, spriteName: str, r: float, g: float, b: float, a: float) -> None: ...

  @overload
  def setOverlaySprite(self, spriteName: str, r: float, g: float, b: float, a: float, bTransmit: bool) -> bool: ...

  def setOverlaySpriteColor(self, r: float, g: float, b: float, a: float) -> None: ...

  def setPipedFuelAmount(self, units: int) -> None: ...

  @overload
  def setRenderEffect(self, type: RenderEffectType) -> None: ...

  @overload
  def setRenderEffect(self, type: RenderEffectType, reuseEqualType: bool) -> None: ...

  def setRenderYOffset(self, f: float) -> None: ...

  def setRerouteCollide(self, rerouteCollide: IsoObject) -> None: ...

  def setRerouteMask(self, rerouteMask: IsoObject) -> None: ...

  def setSpecialTooltip(self, specialTooltip: bool) -> None: ...

  @overload
  def setSprite(self, name: str) -> None: ...

  @overload
  def setSprite(self, sprite: IsoSprite) -> None: ...

  def setSpriteFromName(self, name: str) -> None: ...

  def setSquare(self, square: IsoGridSquare) -> None: ...

  def setTable(self, table: KahluaTable) -> None: ...

  def setTaintedWater(self, tainted: bool) -> None: ...

  @overload
  def setTargetAlpha(self, targetAlpha: float) -> None: ...

  @overload
  def setTargetAlpha(self, playerIndex: int, targetAlpha: float) -> None: ...

  def setType(self, type: IsoObjectType) -> None: ...

  def setUsesExternalWaterSource(self, b: bool) -> None: ...

  def setWaterAmount(self, units: int) -> None: ...

  def softReset(self) -> None: ...

  def syncIsoObject(self, bRemote: bool, val: int, source: UdpConnection, bb: ByteBuffer) -> None: ...

  def syncIsoObjectSend(self, bb: ByteBufferWriter) -> None: ...

  def transmitCompleteItemToClients(self) -> None: ...

  def transmitCompleteItemToServer(self) -> None: ...

  def transmitCustomColor(self) -> None: ...

  def transmitModData(self) -> None: ...

  def transmitUpdatedSprite(self) -> None: ...

  @overload
  def transmitUpdatedSpriteToClients(self) -> None: ...

  @overload
  def transmitUpdatedSpriteToClients(self, connection: UdpConnection) -> None: ...

  def transmitUpdatedSpriteToServer(self) -> None: ...

  def unsetOutlineHighlight(self) -> None: ...

  def update(self) -> None: ...

  def useItemOn(self, item: InventoryItem) -> None: ...

  def useWater(self, amount: int) -> int: ...

  def writeToRemoteBuffer(self, b: ByteBufferWriter) -> None: ...

  @staticmethod
  @overload
  def FindExternalWaterSource(square: IsoGridSquare) -> IsoObject: ...

  @staticmethod
  @overload
  def FindExternalWaterSource(x: int, y: int, z: int) -> IsoObject: ...

  @staticmethod
  def FindWaterSourceOnSquare(square: IsoGridSquare) -> IsoObject: ...

  @staticmethod
  def factoryClassFromFileInput(cell: IsoCell, classID: int) -> Class: ...

  @staticmethod
  @overload
  def factoryFromFileInput(cell: IsoCell, classID: int) -> IsoObject: ...

  @staticmethod
  @overload
  def factoryFromFileInput(cell: IsoCell, b: ByteBuffer) -> IsoObject: ...

  @staticmethod
  def factoryFromFileInput_OLD(cell: IsoCell, classID: int) -> IsoObject: ...

  @staticmethod
  def factoryGetClassID(name: str) -> int: ...

  @staticmethod
  def getFactoryVehicle() -> IsoObject.IsoObjectFactory: ...

  @staticmethod
  def getLastRendered() -> IsoObject: ...

  @staticmethod
  def getLastRenderedRendered() -> IsoObject: ...

  @staticmethod
  @overload
  def getNew() -> IsoObject: ...

  @staticmethod
  @overload
  def getNew(sq: IsoGridSquare, spriteName: str, name: str, bShareTilesWithMap: bool) -> IsoObject: ...

  @staticmethod
  def setDefaultCondition(i: int) -> None: ...

  @staticmethod
  def setLastRendered(aLastRendered: IsoObject) -> None: ...

  @staticmethod
  def setLastRenderedRendered(aLastRenderedRendered: IsoObject) -> None: ...

  @overload
  def __init__(self):
    self.attachedanimsprite: ArrayList[IsoSpriteInstance]

    self.balphaforced: bool

    self.bneverdonealpha: bool

    self.container: ItemContainer

    self.damage: int

    self.dir: IsoDirections

    self.donotsync: bool

    self.emitter: BaseSoundEmitter

    self.highlightflags: int

    self.keyid: int

    self.name: str

    self.nopicking: bool

    self.offsetx: float

    self.offsety: float

    self.outlineonmouseover: bool

    self.overlaysprite: IsoSprite

    self.overlayspritecolor: ColorInfo

    self.partialthumpdmg: float

    self.reroutecollide: IsoObject

    self.reroutemask: IsoObject

    self.sheetrope: bool

    self.sheetropehealth: float

    self.sprite: IsoSprite

    self.spritename: str

    self.square: IsoGridSquare

    self.sx: float

    self.sy: float

    self.table: KahluaTable

    self.tintb: float

    self.tintg: float

    self.tintr: float

    self.wallbloodsplats: ArrayList[IsoWallBloodSplat]

  @overload
  def __init__(self, cell: IsoCell): ...
  @overload
  def __init__(self, square: IsoGridSquare, tile: str): ...
  @overload
  def __init__(self, cell: IsoCell, square: IsoGridSquare, gid: str): ...
  @overload
  def __init__(self, cell: IsoCell, square: IsoGridSquare, spr: IsoSprite): ...
  @overload
  def __init__(self, square: IsoGridSquare, tile: str, bShareTilesWithMap: bool): ...
  @overload
  def __init__(self, square: IsoGridSquare, tile: str, name: str): ...
  @overload
  def __init__(self, square: IsoGridSquare, tile: str, name: str, bShareTilesWithMap: bool): ...

  class IsoObjectFactory:

    def getClassID(self) -> int: ...

    def getObjectName(self) -> str: ...

    def __init__(self, classID: int, objectName: str): ...

  class OutlineShader:

    instance: IsoObject.OutlineShader

    def StartShader(self) -> bool: ...

    def initShader(self) -> None: ...

    def setOutlineColor(self, r: float, g: float, b: float, a: float) -> None: ...

    def setStepSize(self, stepSize: float, texWidth: int, texHeight: int) -> None: ...

    def __init__(self): ...

  class VisionResult(Enum):

    Blocked: IsoObject.VisionResult

    NoEffect: IsoObject.VisionResult

    Unblocked: IsoObject.VisionResult

    @staticmethod
    def valueOf(arg0: str) -> IsoObject.VisionResult: ...

    @staticmethod
    def values() -> list[IsoObject.VisionResult]: ...


class IsoObjectPicker:

  Instance: IsoObjectPicker

  def Add(self, x: int, y: int, width: int, height: int, gridSquare: IsoGridSquare, tile: IsoObject, flip: bool, scaleX: float, scaleY: float) -> None: ...

  def ContextPick(self, screenX: int, screenY: int) -> IsoObjectPicker.ClickObject: ...

  def Init(self) -> None: ...

  def Pick(self, xx: int, yy: int) -> IsoObjectPicker.ClickObject: ...

  def PickCorpse(self, screenX: int, screenY: int) -> IsoObject: ...

  def PickDoor(self, screenX: int, screenY: int, bTransparent: bool) -> IsoObject: ...

  def PickHoppable(self, screenX: int, screenY: int) -> IsoObject: ...

  def PickTarget(self, xx: int, yy: int) -> IsoMovingObject: ...

  def PickThumpable(self, screenX: int, screenY: int) -> IsoObject: ...

  def PickTree(self, screenX: int, screenY: int) -> IsoObject: ...

  def PickVehicle(self, screenX: int, screenY: int) -> BaseVehicle: ...

  def PickWindow(self, screenX: int, screenY: int) -> IsoObject: ...

  def PickWindowFrame(self, screenX: int, screenY: int) -> IsoObject: ...

  def StartRender(self) -> None: ...

  def getInstance(self) -> IsoObjectPicker: ...

  def __init__(self):
    self.clickobjectstore: list[IsoObjectPicker.ClickObject]
    self.count: int
    self.counter: int
    self.dirty: bool
    self.maxcount: int
    self.thisframe: ArrayList[IsoObjectPicker.ClickObject]
    self.wasdirty: bool
    self.xoffsincedirty: float
    self.yoffsincedirty: float

  class ClickObject:

    def calculateScore(self) -> int: ...

    def getScore(self) -> int: ...

    def __init__(self):
      self.height: int
      self.lx: int
      self.ly: int
      self.scalex: float
      self.scaley: float
      self.square: IsoGridSquare
      self.tile: IsoObject
      self.width: int
      self.x: int
      self.y: int


class IsoObjectSyncRequests:

  @overload
  def putRequest(self, square: IsoGridSquare, obj: IsoObject) -> None: ...

  @overload
  def putRequest(self, x: int, y: int, z: int, objIndex: int) -> None: ...

  def putRequestLoad(self, square: IsoGridSquare) -> None: ...

  def receiveIsoSync(self, x: int, y: int, z: int, objIndex: int) -> None: ...

  def sendRequests(self, connection: UdpConnection) -> None: ...

  def __init__(self):
    self.requests: ArrayList[IsoObjectSyncRequests.SyncData]
    self.timeout: int

  class SyncData: ...


class IsoPhysicsObject(IsoMovingObject):

  def collideGround(self) -> None: ...

  def collideWall(self) -> None: ...

  def getGlobalMovementMod(self, bDoNoises: bool) -> float: ...

  def update(self) -> None: ...

  def __init__(self, cell: IsoCell):
    self.speedmod: float
    self.terminalvelocity: float
    self.velx: float
    self.vely: float
    self.velz: float


class IsoPuddles:

  BOOL_MAX: int

  FLOAT_MAX: int

  FLOAT_MUDDYPUDDLES: int

  FLOAT_PUDDLESSIZE: int

  FLOAT_RAIN: int

  FLOAT_RAININTENSITY: int

  FLOAT_WETGROUND: int

  leakingPuddlesInTheRoom: bool

  VBOs: SharedVertexBufferObjects

  def applyPuddlesQuality(self) -> None: ...

  def getBoolMax(self) -> int: ...

  def getFloatMax(self) -> int: ...

  def getHMTexture(self) -> ITexture: ...

  def getPuddlesFloat(self, id: int) -> IsoPuddles.PuddlesFloat: ...

  def getPuddlesParams(self, z: int) -> FloatBuffer: ...

  def getPuddlesSize(self) -> float: ...

  def getRainIntensity(self) -> float: ...

  def getShaderEnable(self) -> bool: ...

  def getShaderOffset(self) -> Vector4f: ...

  def getShaderOffsetMain(self) -> Vector4f: ...

  def getShaderTime(self) -> float: ...

  def puddlesGeometry(self, z: int) -> None: ...

  def puddlesProjection(self) -> None: ...

  def render(self, grid: ArrayList[IsoGridSquare], z: int) -> None: ...

  def update(self, cm: ClimateManager) -> None: ...

  @staticmethod
  def getInstance() -> IsoPuddles: ...

  def __init__(self):
    self.effect: Shader

  class RenderData: ...

  class PuddlesFloat:

    def addFinalValue(self, f: float) -> None: ...

    def addFinalValueForMax(self, f: float, maximum: float) -> None: ...

    def getAdminValue(self) -> float: ...

    def getFinalValue(self) -> float: ...

    def getID(self) -> int: ...

    def getMax(self) -> float: ...

    def getMin(self) -> float: ...

    def getName(self) -> str: ...

    def init(self, id: int, name: str) -> IsoPuddles.PuddlesFloat: ...

    def interpolateFinalValue(self, f: float) -> None: ...

    def isEnableAdmin(self) -> bool: ...

    def setAdminValue(self, f: float) -> None: ...

    def setEnableAdmin(self, b: bool) -> None: ...

    def setFinalValue(self, f: float) -> None: ...

    def __init__(self): ...


class IsoPuddlesCompute:

  @staticmethod
  def computePuddle(square: IsoGridSquare) -> float: ...

  def __init__(self): ...


class IsoPuddlesGeometry:

  pool: ObjectPool[IsoPuddlesGeometry]

  def init(self, square: IsoGridSquare) -> IsoPuddlesGeometry: ...

  def recalcIfNeeded(self) -> None: ...

  def shouldRender(self) -> bool: ...

  def updateLighting(self, playerIndex: int) -> None: ...

  def __init__(self): ...


class IsoPushableObject(IsoMovingObject):

  def DoCollideNorS(self) -> None: ...

  def DoCollideWorE(self) -> None: ...

  def Serialize(self) -> bool: ...

  def getObjectName(self) -> str: ...

  def getWeight(self, x: float, y: float) -> float: ...

  def load(self, input: ByteBuffer, WorldVersion: int, IS_DEBUG_SAVE: bool) -> None: ...

  def save(self, output: ByteBuffer, IS_DEBUG_SAVE: bool) -> None: ...

  def update(self) -> None: ...

  @overload
  def __init__(self, cell: IsoCell):
    self.carrycapacity: int

    self.connectlist: ArrayList[IsoPushableObject]

    self.emptyweight: float

    self.ox: float

    self.oy: float

  @overload
  def __init__(self, cell: IsoCell, square: IsoGridSquare, spr: IsoSprite): ...
  @overload
  def __init__(self, cell: IsoCell, x: int, y: int, z: int): ...


class IsoRoofFixer:

  @staticmethod
  def FixRoofsAt(current: IsoGridSquare) -> None: ...

  def __init__(self): ...

  class PlaceFloorInfo: ...


class IsoRoomLight:

  NextID: int

  def addInfluence(self) -> None: ...

  def clearInfluence(self) -> None: ...

  def isInBounds(self) -> bool: ...

  def __init__(self, room: IsoRoom, x: int, y: int, z: int, width: int, height: int):
    self.b: float
    self.bactive: bool
    self.bactivejni: bool
    self.bhydropowered: bool
    self.g: float
    self.height: int
    self.id: int
    self.r: float
    self.room: IsoRoom
    self.width: int
    self.x: int
    self.y: int
    self.z: int


class IsoUtils:

  @staticmethod
  @overload
  def DistanceManhatten(fromX: float, fromY: float, toX: float, toY: float) -> float: ...

  @staticmethod
  @overload
  def DistanceManhatten(fromX: float, fromY: float, toX: float, toY: float, fromZ: float, toZ: float) -> float: ...

  @staticmethod
  def DistanceManhattenSquare(fromX: float, fromY: float, toX: float, toY: float) -> float: ...

  @staticmethod
  @overload
  def DistanceTo(fromX: float, fromY: float, toX: float, toY: float) -> float: ...

  @staticmethod
  @overload
  def DistanceTo(fromX: float, fromY: float, fromZ: float, toX: float, toY: float, toZ: float) -> float: ...

  @staticmethod
  def DistanceTo2D(fromX: float, fromY: float, toX: float, toY: float) -> float: ...

  @staticmethod
  @overload
  def DistanceToSquared(fromX: float, fromY: float, toX: float, toY: float) -> float: ...

  @staticmethod
  @overload
  def DistanceToSquared(fromX: float, fromY: float, fromZ: float, toX: float, toY: float, toZ: float) -> float: ...

  @staticmethod
  def XToIso(screenX: float, screenY: float, floor: float) -> float: ...

  @staticmethod
  def XToIsoTrue(screenX: float, screenY: float, floor: int) -> float: ...

  @staticmethod
  def XToScreen(objectX: float, objectY: float, objectZ: float, screenZ: int) -> float: ...

  @staticmethod
  def XToScreenExact(objectX: float, objectY: float, objectZ: float, screenZ: int) -> float: ...

  @staticmethod
  def XToScreenInt(objectX: int, objectY: int, objectZ: int, screenZ: int) -> float: ...

  @staticmethod
  def YToIso(screenX: float, screenY: float, floor: float) -> float: ...

  @staticmethod
  def YToScreen(objectX: float, objectY: float, objectZ: float, screenZ: int) -> float: ...

  @staticmethod
  def YToScreenExact(objectX: float, objectY: float, objectZ: float, screenZ: int) -> float: ...

  @staticmethod
  def YToScreenInt(objectX: int, objectY: int, objectZ: int, screenZ: int) -> float: ...

  @staticmethod
  def clamp(x: float, minVal: float, maxVal: float) -> float: ...

  @staticmethod
  def isSimilarDirection(chr: IsoGameCharacter, xA: float, yA: float, xB: float, yB: float, similar: float) -> bool: ...

  @staticmethod
  def lerp(val: float, min: float, max: float) -> float: ...

  @staticmethod
  def smoothstep(edge0: float, edge1: float, x: float) -> float: ...

  def __init__(self): ...


class IsoWallBloodSplat:

  def load(self, input: ByteBuffer, WorldVersion: int) -> None: ...

  def render(self, x: float, y: float, z: float, objectColor: ColorInfo) -> None: ...

  def save(self, output: ByteBuffer) -> None: ...

  @overload
  def __init__(self):
    self.sprite: IsoSprite

    self.worldage: float

  @overload
  def __init__(self, worldAge: float, sprite: IsoSprite): ...


class IsoWater:

  def FBOEnd(self) -> None: ...

  def FBOStart(self) -> None: ...

  def applyWaterQuality(self) -> None: ...

  def getRainIntensity(self) -> float: ...

  def getShaderEnable(self) -> bool: ...

  def getShaderOffset(self) -> Vector4f: ...

  def getShaderTime(self) -> float: ...

  def getTextureBottom(self) -> ITexture: ...

  def getWaterWindSpeed(self) -> float: ...

  def getWaterWindX(self) -> float: ...

  def getWaterWindY(self) -> float: ...

  def render(self, Grid: ArrayList[IsoGridSquare], bShore: bool) -> None: ...

  def update(self, cm: ClimateManager) -> None: ...

  def waterGeometry(self, bShore: bool) -> None: ...

  def waterProjection(self) -> None: ...

  @staticmethod
  def getInstance() -> IsoWater: ...

  def __init__(self):
    self.effect: Shader

  class RenderData: ...


class IsoWaterFlow:

  @staticmethod
  def Reset() -> None: ...

  @staticmethod
  def addFlow(x: float, y: float, flow: float, speed: float) -> None: ...

  @staticmethod
  def addZone(x1: float, y1: float, x2: float, y2: float, shore: float, water_ground: float) -> None: ...

  @staticmethod
  def getFlow(square: IsoGridSquare, ax: int, ay: int, out: Vector2f) -> Vector2f: ...

  @staticmethod
  def getShore(x: int, y: int) -> int: ...

  def __init__(self): ...


class IsoWaterGeometry:

  pool: ObjectPool[IsoWaterGeometry]

  def getFlow(self) -> float: ...

  def init(self, square: IsoGridSquare) -> IsoWaterGeometry: ...

  def isShore(self) -> bool: ...

  def __init__(self): ...


class IsoWorld:

  instance: IsoWorld

  mapPath: str

  mapUseJar: bool

  NoZombies: bool

  PropertyValueMap: HashMap[str, ArrayList[str]]

  SavedWorldVersion: int

  saveoffsetx: int

  saveoffsety: int

  TotalWorldVersion: int

  WorldVersion: int

  WorldVersion_AlarmClockRingSince: int

  WorldVersion_AllPatches: int

  WorldVersion_AlreadyReadBooks1: int

  WorldVersion_AlreadyReadBooks2: int

  WorldVersion_AttachedSlotType: int

  WorldVersion_Barricade: int

  WorldVersion_BodyLocation: int

  WorldVersion_CanUpgradePerk: int

  WorldVersion_CharacterModelData: int

  WorldVersion_CharacterModelData2: int

  WorldVersion_CharacterModelData3: int

  WorldVersion_ChunkSpawnedRooms: int

  WorldVersion_ChunkVehicles: int

  WorldVersion_ClimateAdded: int

  WorldVersion_ClimateColors: int

  WorldVersion_ClothingPatchSaveLoad: int

  WorldVersion_CompostLastUpdated: int

  WorldVersion_ContainerMaxCapacity: int

  WorldVersion_CruiseSpeedSaving: int

  WorldVersion_DayLengthHours: int

  WorldVersion_DeadBodyAngle: int

  WorldVersion_DeadBodyAtlas: int

  WorldVersion_DeadBodyFakeDead: int

  WorldVersion_DeadBodyID: int

  WorldVersion_DeadBodyPersistentOutfitID: int

  WorldVersion_DeadBodyZombieRotStage: int

  WorldVersion_DeathDragDown: int

  WorldVersion_Fitness: int

  WorldVersion_Fitness2: int

  WorldVersion_FliesSound: int

  WorldVersion_GeneratorFuelFloat: int

  WorldVersion_HumanVisualBlood: int

  WorldVersion_IgnoreRemoveSandbox: int

  WorldVersion_InfectionTime: int

  WorldVersion_ItemContainerIdenticalItems: int

  WorldVersion_ItemContainerIdenticalItemsInt: int

  WorldVersion_ItemVisualFullType: int

  WorldVersion_KateBobStorm: int

  WorldVersion_KnownMediaLines: int

  WorldVersion_LampOnPillar: int

  WorldVersion_LampOnPillar2: int

  WorldVersion_LootRespawn: int

  WorldVersion_MapMetaBounds: int

  WorldVersion_MediaDisksAndTapes: int

  WorldVersion_NaturalHairBeardColor: int

  WorldVersion_NewFog: int

  WorldVersion_NewSandboxLootModifier: int

  WorldVersion_NoiseMakerDuration: int

  WorldVersion_OverlappingGenerators: int

  WorldVersion_PerkName: int

  WorldVersion_PlayerVehicleSeat: int

  WorldVersion_PolygonZone: int

  WorldVersion_PolylineZone: int

  WorldVersion_PreviouslyEntered: int

  WorldVersion_SandboxOptions: int

  WorldVersion_Scarecrow: int

  WorldVersion_Thermos: int

  WorldVersion_TimedActionInstantCheat: int

  WorldVersion_VehicleBlood: int

  WorldVersion_VehicleJNITransform: int

  WorldVersion_VehicleLightFocusing: int

  WorldVersion_VehicleSirenStartTime: int

  WorldVersion_VehicleTowAttachment: int

  WorldVersion_VehicleTowingID: int

  WorldVersion_ZombieRotStage: int

  def CreateRandomSurvivor(self, desc: SurvivorDesc, sq: IsoGridSquare, player: IsoPlayer) -> IsoSurvivor: ...

  def CreateSwarm(self, num: int, x1: int, y1: int, x2: int, y2: int) -> None: ...

  def ForceKillAllZombies(self) -> None: ...

  def KillCell(self) -> None: ...

  def LoadPlayerForInfo(self) -> bool: ...

  def LoadTileDefinitions(self, sprMan: IsoSpriteManager, filename: str, fileNumber: int) -> None: ...

  def LoadTileDefinitionsPropertyStrings(self, sprMan: IsoSpriteManager, filename: str, fileNumber: int) -> None: ...

  def addLuaTrait(self, trait: str) -> None: ...

  def checkVehiclesZones(self) -> None: ...

  @overload
  def getAllTiles(self) -> HashMap[str, ArrayList[str]]: ...

  @overload
  def getAllTiles(self, filename: str) -> ArrayList[str]: ...

  def getAllTilesName(self) -> ArrayList[str]: ...

  def getCell(self) -> IsoCell: ...

  def getClimateManager(self) -> ClimateManager: ...

  def getDifficulty(self) -> str: ...

  def getFrameNo(self) -> int: ...

  @overload
  def getFreeEmitter(self) -> BaseSoundEmitter: ...

  @overload
  def getFreeEmitter(self, x: float, y: float, z: float) -> BaseSoundEmitter: ...

  def getGameMode(self) -> str: ...

  def getGlobalTemperature(self) -> float: ...

  def getItemFromXYZIndexBuffer(self, bb: ByteBuffer) -> IsoObject: ...

  def getLuaPlayerDesc(self) -> SurvivorDesc: ...

  def getLuaPosX(self) -> int: ...

  def getLuaPosY(self) -> int: ...

  def getLuaPosZ(self) -> int: ...

  def getLuaSpawnCellX(self) -> int: ...

  def getLuaSpawnCellY(self) -> int: ...

  def getLuaTraits(self) -> ArrayList[str]: ...

  def getMap(self) -> str: ...

  def getMetaChunk(self, wx: int, wy: int) -> IsoMetaChunk: ...

  def getMetaChunkFromTile(self, wx: int, wy: int) -> IsoMetaChunk: ...

  def getMetaGrid(self) -> IsoMetaGrid: ...

  def getPuddlesManager(self) -> IsoPuddles: ...

  def getRBBasic(self) -> RandomizedBuildingBase: ...

  def getRandomizedBuildingList(self) -> ArrayList[RandomizedBuildingBase]: ...

  def getRandomizedVehicleStoryByName(self, name: str) -> RandomizedVehicleStoryBase: ...

  def getRandomizedVehicleStoryList(self) -> ArrayList[RandomizedVehicleStoryBase]: ...

  def getRandomizedZoneList(self) -> ArrayList[RandomizedZoneStoryBase]: ...

  def getSpawnedZombieZone(self) -> HashMap[str, ArrayList[Double]]: ...

  def getTileImageNames(self) -> ArrayList[str]: ...

  def getTimeSinceLastSurvivorInHorde(self) -> int: ...

  def getWeather(self) -> str: ...

  def getWorld(self) -> str: ...

  def getWorldAgeDays(self) -> float: ...

  def getWorldSquareX(self) -> int: ...

  def getWorldSquareY(self) -> int: ...

  def init(self) -> None: ...

  def isHydroPowerOn(self) -> bool: ...

  def isValidSquare(self, x: int, y: int, z: int) -> bool: ...

  def registerMannequinZone(self, name: str, type: str, x: int, y: int, z: int, width: int, height: int, properties: KahluaTable) -> IsoMetaGrid.Zone: ...

  def registerRoomTone(self, name: str, type: str, x: int, y: int, z: int, width: int, height: int, properties: KahluaTable) -> None: ...

  def registerSpawnOrigin(self, x: int, y: int, width: int, height: int, properties: KahluaTable) -> None: ...

  def registerVehiclesZone(self, name: str, type: str, x: int, y: int, z: int, width: int, height: int, properties: KahluaTable) -> IsoMetaGrid.Zone: ...

  def registerWaterFlow(self, x: float, y: float, flow: float, speed: float) -> None: ...

  def registerWaterZone(self, x1: float, y1: float, x2: float, y2: float, shore: float, water_ground: float) -> None: ...

  def registerZone(self, name: str, type: str, x: int, y: int, z: int, width: int, height: int) -> IsoMetaGrid.Zone: ...

  def registerZoneNoOverlap(self, name: str, type: str, x: int, y: int, z: int, width: int, height: int) -> IsoMetaGrid.Zone: ...

  def removeZonesForLotDirectory(self, lotDir: str) -> None: ...

  def render(self) -> None: ...

  def renderTerrain(self) -> None: ...

  def returnOwnershipOfEmitter(self, emitter: BaseSoundEmitter) -> None: ...

  def sceneCullZombies(self) -> None: ...

  def setDifficulty(self, difficulty: str) -> None: ...

  def setDrawWorld(self, b: bool) -> None: ...

  def setEmitterOwner(self, emitter: BaseSoundEmitter, object: IsoObject) -> None: ...

  def setGameMode(self, mode: str) -> None: ...

  def setGlobalTemperature(self, globalTemperature: float) -> None: ...

  def setHydroPowerOn(self, __on__: bool) -> None: ...

  def setLuaPlayerDesc(self, desc: SurvivorDesc) -> None: ...

  def setLuaPosX(self, luaPosX: int) -> None: ...

  def setLuaPosY(self, luaPosY: int) -> None: ...

  def setLuaPosZ(self, luaPosZ: int) -> None: ...

  def setLuaSpawnCellX(self, luaSpawnCellX: int) -> None: ...

  def setLuaSpawnCellY(self, luaSpawnCellY: int) -> None: ...

  def setMap(self, world: str) -> None: ...

  def setTimeSinceLastSurvivorInHorde(self, timeSinceLastSurvivorInHorde: int) -> None: ...

  def setWeather(self, weather: str) -> None: ...

  def setWorld(self, world: str) -> None: ...

  def takeOwnershipOfEmitter(self, emitter: BaseSoundEmitter) -> None: ...

  def transmitWeather(self) -> None: ...

  def update(self) -> None: ...

  @staticmethod
  def getWorldVersion() -> int: ...

  @staticmethod
  def getZombiesDisabled() -> bool: ...

  @staticmethod
  def getZombiesEnabled() -> bool: ...

  @staticmethod
  def isAnimRecorderActive() -> bool: ...

  @staticmethod
  def isAnimRecorderDiscardTriggered() -> bool: ...

  @staticmethod
  @overload
  def readInt(__in__: InputStream) -> int: ...

  @staticmethod
  @overload
  def readInt(__in__: RandomAccessFile) -> int: ...

  @staticmethod
  @overload
  def readString(__in__: InputStream) -> str: ...

  @staticmethod
  @overload
  def readString(__in__: RandomAccessFile) -> str: ...

  def __init__(self):
    self.addcoopplayers: ArrayList[AddCoopPlayer]
    self.bdochunkmapupdate: bool
    self.characters: ArrayList[IsoGameCharacter]
    self.currentcell: IsoCell
    self.emitterupdate: bool
    self.helicopter: Helicopter
    self.metagrid: IsoMetaGrid
    self.sky: SkyBox
    self.survivordescriptors: HashMap[Integer, SurvivorDesc]
    self.survivorsurvivalrecord: int
    self.totalsurvivornights: int
    self.totalsurvivorsdead: int
    self.x: int
    self.y: int

  class CompScoreToPlayer:

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: IsoZombie, arg1: IsoZombie) -> int: ...

    def equals(self, arg0: object) -> bool: ...

    def getScore(self, arg0: IsoZombie) -> float: ...

    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

  class s_performance: ...

  class CompDistToPlayer:

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: IsoZombie, arg1: IsoZombie) -> int: ...

    def equals(self, arg0: object) -> bool: ...

    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

  class Frame:

    def __init__(self, arg0: IsoWorld):
      self.type: ArrayList[Integer]
      self.xpos: ArrayList[Integer]
      self.ypos: ArrayList[Integer]

  class MetaCell:

    def __init__(self):
      # self.from: list[list[int]]
      self.x: int
      self.y: int
      self.zombiecount: int
      self.zombiemigratedirection: IsoDirections


class LightingJNI:

  ForcedVis: list[list[int]]

  ROOM_SPAWN_DIST: int

  @staticmethod
  def DoLightingUpdateNew(time: int) -> None: ...

  @staticmethod
  def WaitingForMain() -> bool: ...

  @staticmethod
  def addLight(id: int, x: int, y: int, z: int, radius: int, r: float, g: float, b: float, buildingID: int, active: bool) -> None: ...

  @staticmethod
  def addRoomLight(id: int, buildingID: int, roomID: int, x: int, y: int, z: int, width: int, height: int, active: bool) -> None: ...

  @staticmethod
  def addTempLight(id: int, x: int, y: int, z: int, radius: int, r: float, g: float, b: float, life: int) -> None: ...

  @staticmethod
  def calculateVisionCone(player: IsoGameCharacter) -> float: ...

  @staticmethod
  def chunkBeginUpdate(wx: int, wy: int) -> None: ...

  @staticmethod
  def chunkEndUpdate() -> None: ...

  @staticmethod
  def chunkLightingDone(wx: int, wy: int) -> bool: ...

  @staticmethod
  def configure(darkStep: float) -> None: ...

  @staticmethod
  def destroy() -> None: ...

  @staticmethod
  def getCanSee(playerIndex: int, x: int, y: int, z: int) -> bool: ...

  @staticmethod
  def getCouldSee(playerIndex: int, x: int, y: int, z: int) -> bool: ...

  @staticmethod
  def getDarkMulti(playerIndex: int, x: int, y: int, z: int) -> float: ...

  @staticmethod
  def getLightInfo(playerIndex: int, x: int, y: int, z: int, rgb: int) -> float: ...

  @staticmethod
  def getSeen(playerIndex: int, x: int, y: int, z: int) -> bool: ...

  @staticmethod
  def getSquareLighting(playerIndex: int, x: int, y: int, z: int, data: list[int]) -> bool: ...

  @staticmethod
  def getTargetDarkMulti(playerIndex: int, x: int, y: int, z: int) -> float: ...

  @staticmethod
  def getTorches(out: ArrayList[IsoGameCharacter.TorchInfo]) -> None: ...

  @staticmethod
  def getVertLight(playerIndex: int, x: int, y: int, z: int, i: int) -> int: ...

  @staticmethod
  def init() -> None: ...

  @staticmethod
  def playerSet(x: float, y: float, z: float, angleX: float, angleY: float, isDead: bool, ReanimatedCorpse: bool, GhostMode: bool, ShortSighted: bool, tireddel: float, ndist: float, cone: float) -> None: ...

  @staticmethod
  def removeLight(id: int) -> None: ...

  @staticmethod
  def removeRoomLight(id: int) -> None: ...

  @staticmethod
  def removeTorch(id: int) -> None: ...

  @staticmethod
  def scrollDown(playerIndex: int) -> None: ...

  @staticmethod
  def scrollLeft(playerIndex: int) -> None: ...

  @staticmethod
  def scrollRight(playerIndex: int) -> None: ...

  @staticmethod
  def scrollUp(playerIndex: int) -> None: ...

  @staticmethod
  def setLightActive(id: int, active: bool) -> None: ...

  @staticmethod
  def setLightColor(id: int, r: float, g: float, b: float) -> None: ...

  @staticmethod
  def setRoomLightActive(id: int, active: bool) -> None: ...

  @staticmethod
  def squareAddCurtain(wnes: int, open: bool) -> None: ...

  @staticmethod
  def squareAddDoor(north: bool, open: bool, trans: bool) -> None: ...

  @staticmethod
  def squareAddThumpable(north: bool, open: bool, isDoor: bool, canPassThrough: bool) -> None: ...

  @staticmethod
  def squareAddWindow(north: bool, open: bool, opaque: bool) -> None: ...

  @staticmethod
  def squareBeginUpdate(x: int, y: int, z: int) -> None: ...

  @staticmethod
  def squareEndUpdate() -> None: ...

  @staticmethod
  def squareSet(hasW: bool, hasN: bool, hasE: bool, hasS: bool, hasElevatedFloor: bool, visionMatrix: int, buildingID: int, roomID: int) -> None: ...

  @staticmethod
  def squareSetNull(x: int, y: int, z: int) -> None: ...

  @staticmethod
  def stateBeginUpdate(playerIndex: int, minX: int, minY: int, width: int, height: int) -> None: ...

  @staticmethod
  def stateEndFrame(rmod: float, gmod: float, bmod: float, ambient: float, night: float, viewDist: float, viewDistMax: float, cacheCleared: bool, lightSourceUpdate: float) -> None: ...

  @staticmethod
  def stateEndUpdate() -> None: ...

  @staticmethod
  def stateUpdateCounter(playerIndex: int) -> int: ...

  @staticmethod
  def stop() -> None: ...

  @staticmethod
  def teleport(playerIndex: int, wx: int, wy: int) -> None: ...

  @staticmethod
  def update() -> None: ...

  @staticmethod
  def updateChunk(mchunk: IsoChunk) -> None: ...

  @staticmethod
  def updatePlayer(playerIndex: int) -> None: ...

  @staticmethod
  def updateTorch(id: int, x: float, y: float, z: float, angleX: float, angleY: float, dist: float, strength: float, bCone: bool, dot: float, focusing: int) -> None: ...

  def __init__(self): ...

  class JNILighting:

    @overload
    def bCanSee(self) -> bool: ...

    @overload
    def bCanSee(self) -> bool: ...

    @overload
    def bCanSee(self, canSee: bool) -> None: ...

    @overload
    def bCanSee(self, canSee: bool) -> None: ...

    @overload
    def bCouldSee(self) -> bool: ...

    @overload
    def bCouldSee(self) -> bool: ...

    @overload
    def bCouldSee(self, couldSee: bool) -> None: ...

    @overload
    def bCouldSee(self, couldSee: bool) -> None: ...

    @overload
    def bSeen(self) -> bool: ...

    @overload
    def bSeen(self) -> bool: ...

    @overload
    def bSeen(self, seen: bool) -> None: ...

    @overload
    def bSeen(self, seen: bool) -> None: ...

    @overload
    def darkMulti(self) -> float: ...

    @overload
    def darkMulti(self) -> float: ...

    @overload
    def darkMulti(self, f: float) -> None: ...

    @overload
    def darkMulti(self, f: float) -> None: ...

    @overload
    def getResultLight(self, index: int) -> IsoGridSquare.ResultLight: ...

    @overload
    def getResultLight(self, index: int) -> IsoGridSquare.ResultLight: ...

    @overload
    def lampostTotalB(self) -> float: ...

    @overload
    def lampostTotalB(self) -> float: ...

    @overload
    def lampostTotalB(self, b: float) -> None: ...

    @overload
    def lampostTotalB(self, b: float) -> None: ...

    @overload
    def lampostTotalG(self) -> float: ...

    @overload
    def lampostTotalG(self) -> float: ...

    @overload
    def lampostTotalG(self, g: float) -> None: ...

    @overload
    def lampostTotalG(self, g: float) -> None: ...

    @overload
    def lampostTotalR(self) -> float: ...

    @overload
    def lampostTotalR(self) -> float: ...

    @overload
    def lampostTotalR(self, r: float) -> None: ...

    @overload
    def lampostTotalR(self, r: float) -> None: ...

    @overload
    def lightInfo(self) -> ColorInfo: ...

    @overload
    def lightInfo(self) -> ColorInfo: ...

    @overload
    def lightverts(self, i: int) -> int: ...

    @overload
    def lightverts(self, i: int) -> int: ...

    @overload
    def lightverts(self, i: int, value: int) -> None: ...

    @overload
    def lightverts(self, i: int, value: int) -> None: ...

    @overload
    def reset(self) -> None: ...

    @overload
    def reset(self) -> None: ...

    @overload
    def resultLightCount(self) -> int: ...

    @overload
    def resultLightCount(self) -> int: ...

    @overload
    def targetDarkMulti(self) -> float: ...

    @overload
    def targetDarkMulti(self) -> float: ...

    @overload
    def targetDarkMulti(self, f: float) -> None: ...

    @overload
    def targetDarkMulti(self, f: float) -> None: ...

    def __init__(self, playerIndex: int, square: IsoGridSquare): ...


class LightingThread:

  DebugLockTime: bool

  instance: LightingThread

  def GameLoadingUpdate(self) -> None: ...

  def create(self) -> None: ...

  def scrollDown(self, playerIndex: int) -> None: ...

  def scrollLeft(self, playerIndex: int) -> None: ...

  def scrollRight(self, playerIndex: int) -> None: ...

  def scrollUp(self, playerIndex: int) -> None: ...

  def stop(self) -> None: ...

  def update(self) -> None: ...

  def __init__(self):
    self.bfinished: bool
    self.interrupted: bool
    self.lightingthread: Thread


class LosUtil:

  cachecleared: list[bool]

  cachedresults: list[list[list[list[int]]]]

  XSIZE: int

  YSIZE: int

  ZSIZE: int

  @staticmethod
  def init(width: int, height: int) -> None: ...

  @staticmethod
  @overload
  def lineClear(cell: IsoCell, x0: int, y0: int, z0: int, x1: int, y1: int, z1: int, bIgnoreDoors: bool) -> LosUtil.TestResults: ...

  @staticmethod
  @overload
  def lineClear(cell: IsoCell, x0: int, y0: int, z0: int, x1: int, y1: int, z1: int, bIgnoreDoors: bool, RangeTillWindows: int) -> LosUtil.TestResults: ...

  @staticmethod
  def lineClearCached(cell: IsoCell, x1: int, y1: int, z1: int, x0: int, y0: int, z0: int, bIgnoreDoors: bool, playerIndex: int) -> LosUtil.TestResults: ...

  @staticmethod
  def lineClearCollide(x1: int, y1: int, z1: int, x0: int, y0: int, z0: int, bIgnoreDoors: bool) -> bool: ...

  @staticmethod
  def lineClearCollideCount(chr: IsoGameCharacter, cell: IsoCell, x1: int, y1: int, z1: int, x0: int, y0: int, z0: int) -> int: ...

  def __init__(self): ...

  class TestResults(Enum):

    Blocked: LosUtil.TestResults

    Clear: LosUtil.TestResults

    ClearThroughClosedDoor: LosUtil.TestResults

    ClearThroughOpenDoor: LosUtil.TestResults

    ClearThroughWindow: LosUtil.TestResults

    @staticmethod
    def valueOf(arg0: str) -> LosUtil.TestResults: ...

    @staticmethod
    def values() -> list[LosUtil.TestResults]: ...


class LotHeader:

  def Dispose(self) -> None: ...

  def getHeight(self) -> int: ...

  def getLevels(self) -> int: ...

  def getRoom(self, roomID: int) -> IsoRoom: ...

  def getRoomAt(self, x: int, y: int, z: int) -> int: ...

  def getWidth(self) -> int: ...

  def __init__(self):
    self.bfixed2x: bool
    self.buildingbymetaid: TLongObjectHashMap[BuildingDef]
    self.buildings: ArrayList[BuildingDef]
    self.cellx: int
    self.celly: int
    self.height: int
    self.isobuildings: HashMap[Integer, IsoBuilding]
    self.isorooms: HashMap[Integer, IsoRoom]
    self.levels: int
    self.roombymetaid: TLongObjectHashMap[RoomDef]
    self.roomlist: ArrayList[RoomDef]
    self.rooms: HashMap[Integer, RoomDef]
    self.version: int
    self.width: int


class MetaObject:

  def getRoom(self) -> RoomDef: ...

  def getType(self) -> int: ...

  def getUsed(self) -> bool: ...

  def getX(self) -> int: ...

  def getY(self) -> int: ...

  def setUsed(self, bUsed: bool) -> None: ...

  def __init__(self, type: int, x: int, y: int, arg3: RoomDef): ...


class MultiStageBuilding:

  stages: ArrayList[MultiStageBuilding.Stage]

  @staticmethod
  def addStage(stage: MultiStageBuilding.Stage) -> None: ...

  @staticmethod
  def getStages(chr: IsoGameCharacter, itemClicked: IsoObject, cheat: bool) -> ArrayList[MultiStageBuilding.Stage]: ...

  def __init__(self): ...

  class Stage:

    def Load(self, arg0: str, arg1: list[str]) -> None: ...

    def canBeDone(self, arg0: IsoGameCharacter, arg1: IsoObject, arg2: bool) -> bool: ...

    def doStage(self, arg0: IsoGameCharacter, arg1: IsoThumpable, arg2: bool) -> None: ...

    def getCraftingSound(self) -> str: ...

    def getDisplayName(self) -> str: ...

    def getItemsLua(self) -> KahluaTable: ...

    def getItemsToKeep(self) -> ArrayList[str]: ...

    def getKnownRecipe(self) -> str: ...

    def getName(self) -> str: ...

    def getNorthSprite(self) -> str: ...

    def getPerksLua(self) -> KahluaTable: ...

    def getPreviousStages(self) -> ArrayList[str]: ...

    def getRecipeName(self) -> str: ...

    def getSprite(self) -> str: ...

    def getThumpSound(self) -> str: ...

    def getTimeNeeded(self, arg0: IsoGameCharacter) -> int: ...

    def __init__(self, arg0: MultiStageBuilding):
      self.bonushealth: int
      self.bonushealthskill: bool
      self.canbarricade: bool
      self.canbeplastered: bool
      self.completionsound: str
      self.craftingsound: str
      self.id: str
      self.items: HashMap[str, Integer]
      self.itemstokeep: ArrayList[str]
      self.knownrecipe: str
      self.name: str
      self.northsprite: str
      self.perks: HashMap[str, Integer]
      self.previousstage: ArrayList[str]
      self.recipename: str
      self.sprite: str
      self.thumpsound: str
      self.timeneeded: int
      self.walltype: str
      self.xp: HashMap[str, Integer]


class NearestWalls:

  @staticmethod
  @overload
  def ClosestWallDistance(square: IsoGridSquare) -> int: ...

  @staticmethod
  @overload
  def ClosestWallDistance(chunk: IsoChunk, x: int, y: int, z: int) -> int: ...

  @staticmethod
  def chunkLoaded(chunk: IsoChunk) -> None: ...

  @staticmethod
  def render(x: int, y: int, z: int) -> None: ...

  def __init__(self): ...

  class ChunkData:

    def __init__(self): ...


class ObjectsSyncRequests:

  ClientSendChunkHashes: int

  ClientSendGridSquareRequest: int

  ClientSendObjectRequests: int

  ServerSendGridSquareHashes: int

  ServerSendGridSquareObjectsHashes: int

  ServerSendObject: int

  def putRequestSyncIsoChunk(self, ch: IsoChunk) -> None: ...

  def putRequestSyncIsoGridSquare(self, sq: IsoGridSquare) -> None: ...

  def putRequestSyncItemContainer(self, container: ItemContainer) -> None: ...

  def receiveGridSquareHashes(self, bb: ByteBuffer) -> None: ...

  def receiveGridSquareObjectHashes(self, bb: ByteBuffer) -> None: ...

  def receiveObject(self, bb: ByteBuffer) -> None: ...

  def receiveSyncIsoChunk(self, x: int, y: int) -> None: ...

  def receiveSyncIsoGridSquare(self, x: int, y: int, z: int) -> None: ...

  def receiveSyncIsoObject(self, x: int, y: int, z: int, hash: int) -> None: ...

  def sendRequests(self, connection: UdpConnection) -> None: ...

  @overload
  def serverSendRequests(self, connection: UdpConnection) -> None: ...

  @overload
  def serverSendRequests(self, udpEngine: UdpEngine) -> None: ...

  def __init__(self, isClient: bool):
    self.requestssyncisochunk: ArrayList[ObjectsSyncRequests.SyncIsoChunk]
    self.requestssyncisogridsquare: ArrayList[ObjectsSyncRequests.SyncIsoGridSquare]
    self.requestssyncisoobject: ArrayList[ObjectsSyncRequests.SyncIsoObject]
    self.timeout: int

  class SyncIsoChunk: ...

  class SyncIsoGridSquare:

    def hashCode(self) -> int: ...

  class SyncIsoObject:

    def hashCode(self) -> int: ...


class Particles:

  funcs: IGLBufferObject

  ParticleSystems: ArrayList[Particles]

  ParticleSystemsCount: int

  ParticleSystemsLast: int

  def destroy(self) -> None: ...

  def getGeometry(self, val1: int) -> None: ...

  def getGeometryFire(self, val1: int) -> None: ...

  def getMVPMatrix(self) -> FloatBuffer: ...

  def getShaderTime(self) -> float: ...

  def initBuffers(self) -> None: ...

  def reloadShader(self) -> None: ...

  def render(self) -> None: ...

  @staticmethod
  def addParticle(p: Particles) -> int: ...

  @staticmethod
  def deleteParticle(i: int) -> None: ...

  @staticmethod
  def init() -> None: ...

  def __init__(self): ...


class ParticlesArray[E](ArrayList):

  def addParticle(self, arg0: object) -> int: ...

  def defragmentParticle(self) -> None: ...

  def deleteParticle(self, k: int) -> bool: ...

  def getCount(self) -> int: ...

  def getNeedToUpdate(self) -> bool: ...

  def __init__(self): ...


class ParticlesFire(Particles):

  def getFireFlameTexture(self) -> ITexture: ...

  def getFireShaderID(self) -> int: ...

  def getFireSmokeTexture(self) -> ITexture: ...

  def getParametersFire(self) -> FloatBuffer: ...

  def getSmokeShaderID(self) -> int: ...

  def getVapeShaderID(self) -> int: ...

  def reloadShader(self) -> None: ...

  @staticmethod
  def getInstance() -> ParticlesFire: ...

  def __init__(self):
    self.effectfire: FireShader
    self.effectsmoke: SmokeShader
    self.effectvape: Shader

  class Zone: ...

  class ZoneType(Enum):

    Circle: ParticlesFire.ZoneType

    Line: ParticlesFire.ZoneType

    Rectangle: ParticlesFire.ZoneType

    @staticmethod
    def valueOf(arg0: str) -> ParticlesFire.ZoneType: ...

    @staticmethod
    def values() -> list[ParticlesFire.ZoneType]: ...

  class Particle:

    def __init__(self, arg0: ParticlesFire): ...

  class Vortice:

    def __init__(self, arg0: ParticlesFire): ...


class PlayerCamera:

  def XToIso(self, screenX: float, screenY: float, floor: float) -> float: ...

  def XToScreenExact(self, objectX: float, objectY: float, objectZ: float, screenZ: int) -> float: ...

  def YToIso(self, screenX: float, screenY: float, floor: float) -> float: ...

  def YToScreenExact(self, objectX: float, objectY: float, objectZ: float, screenZ: int) -> float: ...

  def center(self) -> None: ...

  def copyFrom(self, other: PlayerCamera) -> None: ...

  def getLastOffX(self) -> float: ...

  def getLastOffY(self) -> float: ...

  def getOffX(self) -> float: ...

  def getOffY(self) -> float: ...

  def getTOffX(self) -> float: ...

  def getTOffY(self) -> float: ...

  def initFromIsoCamera(self, playerIndex: int) -> None: ...

  def update(self) -> None: ...

  def __init__(self, playerIndex: int):
    self.deferedx: float
    self.deferedy: float
    self.lastoffx: float
    self.lastoffy: float
    self.offscreenheight: int
    self.offscreenwidth: int
    self.offx: float
    self.offy: float
    self.playerindex: int
    self.rightclicktargetx: float
    self.rightclicktargety: float
    self.rightclickx: float
    self.rightclicky: float
    self.toffx: float
    self.toffy: float
    self.zoom: float


class PuddlesShader(Shader):

  def updatePuddlesParams(self, userId: int, z: int) -> None: ...

  def __init__(self, name: str): ...


class RoomDef:

  def CalculateBounds(self) -> None: ...

  def Dispose(self) -> None: ...

  def calculateMetaID(self, cellX: int, cellY: int) -> int: ...

  def forEachChunk(self, consumer: BiConsumer[RoomDef, IsoChunk]) -> None: ...

  def getArea(self) -> int: ...

  @overload
  def getAreaOverlapping(self, chunk: IsoChunk) -> float: ...

  @overload
  def getAreaOverlapping(self, x: int, y: int, w: int, h: int) -> float: ...

  def getBuilding(self) -> BuildingDef: ...

  def getClosestPoint(self, x: float, y: float, closestXY: Vector2f) -> float: ...

  def getFreeSquare(self) -> IsoGridSquare: ...

  def getH(self) -> int: ...

  def getID(self) -> int: ...

  def getIsoRoom(self) -> IsoRoom: ...

  def getMetaObjects(self) -> ArrayList[MetaObject]: ...

  def getName(self) -> str: ...

  def getObjects(self) -> ArrayList[MetaObject]: ...

  def getProceduralSpawnedContainer(self) -> HashMap[str, Integer]: ...

  def getRandomSquare(self, predicate: Predicate[IsoGridSquare]) -> IsoGridSquare: ...

  def getRects(self) -> ArrayList[RoomDef.RoomRect]: ...

  def getW(self) -> int: ...

  def getX(self) -> int: ...

  def getX2(self) -> int: ...

  def getY(self) -> int: ...

  def getY2(self) -> int: ...

  def getZ(self) -> int: ...

  def intersects(self, x: int, y: int, w: int, h: int) -> bool: ...

  def isEmptyOutside(self) -> bool: ...

  def isExplored(self) -> bool: ...

  def isInside(self, x: int, y: int, z: int) -> bool: ...

  def isRoofFixed(self) -> bool: ...

  def refreshSquares(self) -> None: ...

  def setBuilding(self, arg0: BuildingDef) -> None: ...

  def setExplored(self, explored: bool) -> None: ...

  def setRoofFixed(self, b: bool) -> None: ...

  def __init__(self, ID: int, name: str):
    self.area: int
    self.bdonespawn: bool
    self.bexplored: bool
    self.blightsactive: bool
    self.building: BuildingDef
    self.id: int
    self.indoorzombies: int
    self.level: int
    self.metaid: int
    self.name: str
    self.objects: ArrayList[MetaObject]
    self.rects: ArrayList[RoomDef.RoomRect]
    self.spawncount: int
    self.x: int
    self.x2: int
    self.y: int
    self.y2: int

  class RoomRect:

    def getClosestPoint(self, x: float, y: float, closestXY: Vector2f) -> float: ...

    def getH(self) -> int: ...

    def getW(self) -> int: ...

    def getX(self) -> int: ...

    def getX2(self) -> int: ...

    def getY(self) -> int: ...

    def getY2(self) -> int: ...

    def __init__(self, x: int, y: int, w: int, h: int):
      self.h: int
      self.w: int
      self.x: int
      self.y: int


class SearchMode:

  def getBlur(self, plrIdx: int) -> SearchMode.SearchModeFloat: ...

  def getDarkness(self, plrIdx: int) -> SearchMode.SearchModeFloat: ...

  def getDesat(self, plrIdx: int) -> SearchMode.SearchModeFloat: ...

  def getFadeTime(self) -> float: ...

  def getGradientWidth(self, plrIdx: int) -> SearchMode.SearchModeFloat: ...

  def getRadius(self, plrIdx: int) -> SearchMode.SearchModeFloat: ...

  def getSearchModeForPlayer(self, index: int) -> SearchMode.PlayerSearchMode: ...

  def isEnabled(self, plrIdx: int) -> bool: ...

  def isOverride(self, plrIdx: int) -> bool: ...

  def setEnabled(self, plrIdx: int, b: bool) -> None: ...

  def setFadeTime(self, fadeTime: float) -> None: ...

  def setOverride(self, plrIdx: int, enabled: bool) -> None: ...

  def update(self) -> None: ...

  @staticmethod
  def getInstance() -> SearchMode: ...

  @staticmethod
  def reset() -> None: ...

  class PlayerSearchMode:

    def getBlur(self) -> SearchMode.SearchModeFloat: ...

    def getDarkness(self) -> SearchMode.SearchModeFloat: ...

    def getDesat(self) -> SearchMode.SearchModeFloat: ...

    def getGradientWidth(self) -> SearchMode.SearchModeFloat: ...

    def getRadius(self) -> SearchMode.SearchModeFloat: ...

    def getShaderBlur(self) -> float: ...

    def getShaderDarkness(self) -> float: ...

    def getShaderDesat(self) -> float: ...

    def getShaderGradientWidth(self) -> float: ...

    def getShaderRadius(self) -> float: ...

    def isShaderEnabled(self) -> bool: ...

    def __init__(self, index: int, sm: SearchMode): ...

  class SearchModeFloat:

    def equalise(self) -> None: ...

    def getExterior(self) -> float: ...

    def getInterior(self) -> float: ...

    def getMax(self) -> float: ...

    def getMin(self) -> float: ...

    def getStepsize(self) -> float: ...

    def getTargetExterior(self) -> float: ...

    def getTargetInterior(self) -> float: ...

    def reset(self) -> None: ...

    def set(self, exterior: float, targetExterior: float, interior: float, targetInterior: float) -> None: ...

    def setExterior(self, exterior: float) -> None: ...

    def setInterior(self, interior: float) -> None: ...

    def setTargetExterior(self, targetExterior: float) -> None: ...

    def setTargetInterior(self, targetInterior: float) -> None: ...

    def setTargets(self, targetExterior: float, targetInterior: float) -> None: ...

    def update(self, delta: float) -> None: ...


class SliceY:

  SliceBuffer: ByteBuffer

  SliceBufferLock: object

  def __init__(self): ...


class SmokeShader(Shader):

  def updateSmokeParams(self, texd: TextureDraw, userId: int, in_firetime: float) -> None: ...

  def __init__(self, name: str): ...


class SpawnPoints:

  instance: SpawnPoints

  def getSpawnRegions(self) -> KahluaTable: ...

  def init(self) -> None: ...

  def initServer1(self) -> None: ...

  def initServer2(self) -> None: ...

  def initSinglePlayer(self) -> None: ...

  def isSpawnBuilding(self, arg0: BuildingDef) -> bool: ...

  def __init__(self): ...


class TallFenceShader:

  instance: TallFenceShader

  def StartShader(self) -> bool: ...

  def initShader(self) -> None: ...

  def setAlpha(self, alpha: float) -> None: ...

  def setOutlineColor(self, r: float, g: float, b: float, a: float) -> None: ...

  def setStepSize(self, stepSize: float, texWidth: int, texHeight: int) -> None: ...

  def __init__(self): ...


class TileOverlays:

  instance: TileOverlays

  def Reset(self) -> None: ...

  def addOverlays(self, overlayMap: KahluaTableImpl) -> None: ...

  def fixTableTopOverlays(self, square: IsoGridSquare) -> None: ...

  def hasOverlays(self, obj: IsoObject) -> bool: ...

  def updateTileOverlaySprite(self, obj: IsoObject) -> None: ...

  def __init__(self): ...

  class TileOverlay:

    def getEntries(self, arg0: str, arg1: IsoGridSquare, arg2: ArrayList[TileOverlays.TileOverlayEntry]) -> None: ...

    def pickRandom(self, arg0: str, arg1: IsoGridSquare) -> TileOverlays.TileOverlayEntry: ...

  class TileOverlayEntry:

    def matchUsage(self, arg0: IsoGridSquare) -> bool: ...

    def pickRandom(self, arg0: int, arg1: int, arg2: int) -> str: ...

  class TileOverlayUsage: ...


class Vector2:

  def add(self, other: Vector2) -> Vector2: ...

  def aimAt(self, other: Vector2) -> Vector2: ...

  def angleBetween(self, other: Vector2) -> float: ...

  def angleTo(self, other: Vector2) -> float: ...

  @overload
  def clone(self) -> object: ...

  @overload
  def clone(self) -> Vector2: ...

  def distanceTo(self, other: Vector2) -> float: ...

  def dot(self, other: Vector2) -> float: ...

  def equals(self, other: object) -> bool: ...

  def getDirection(self) -> float: ...

  def getDirectionNeg(self) -> float: ...

  def getLength(self) -> float: ...

  def getLengthSquared(self) -> float: ...

  def getX(self) -> float: ...

  def getY(self) -> float: ...

  def normalize(self) -> float: ...

  def rotate(self, rad: float) -> None: ...

  def scale(self, scale: float) -> None: ...

  @overload
  def set(self, other: Vector2) -> Vector2: ...

  @overload
  def set(self, x: float, y: float) -> Vector2: ...

  def setDirection(self, direction: float) -> Vector2: ...

  def setLength(self, length: float) -> Vector2: ...

  def setLengthAndDirection(self, direction: float, length: float) -> Vector2: ...

  def setX(self, x: float) -> None: ...

  def setY(self, y: float) -> None: ...

  def tangent(self) -> None: ...

  def toAwtDimension(self) -> Dimension: ...

  def toAwtPoint(self) -> Point: ...

  def toString(self) -> str: ...

  @staticmethod
  def addScaled(a: Vector2, b: Vector2, scale: float, result: Vector2) -> Vector2: ...

  @staticmethod
  def fromAwtPoint(p: Point) -> Vector2: ...

  @staticmethod
  def fromLengthDirection(length: float, direction: float) -> Vector2: ...

  @overload
  def __init__(self):
    self.x: float

    self.y: float

  @overload
  def __init__(self, other: Vector2): ...
  @overload
  def __init__(self, x: float, y: float): ...


class Vector3:

  def add(self, other: Vector2) -> Vector2: ...

  @overload
  def addToThis(self, other: Vector2) -> Vector3: ...

  @overload
  def addToThis(self, other: Vector3) -> Vector3: ...

  def aimAt(self, other: Vector2) -> Vector3: ...

  def angleTo(self, other: Vector2) -> float: ...

  @overload
  def clone(self) -> object: ...

  @overload
  def clone(self) -> Vector3: ...

  def distanceTo(self, other: Vector2) -> float: ...

  def div(self, scalar: float) -> Vector3: ...

  def dot(self, other: Vector2) -> float: ...

  def dot3d(self, other: Vector3) -> float: ...

  def equals(self, other: object) -> bool: ...

  def getDirection(self) -> float: ...

  def getLength(self) -> float: ...

  def getLengthSq(self) -> float: ...

  def normalize(self) -> None: ...

  def rotate(self, rad: float) -> None: ...

  def rotatey(self, rad: float) -> None: ...

  @overload
  def set(self, other: Vector3) -> Vector3: ...

  @overload
  def set(self, x: float, y: float, z: float) -> Vector3: ...

  def setDirection(self, direction: float) -> Vector3: ...

  def setLength(self, length: float) -> Vector3: ...

  def setLengthAndDirection(self, direction: float, length: float) -> Vector3: ...

  def sub(self, val: Vector3, out: Vector3) -> Vector3: ...

  def toAwtDimension(self) -> Dimension: ...

  def toAwtPoint(self) -> Point: ...

  def toString(self) -> str: ...

  @staticmethod
  def fromAwtPoint(p: Point) -> Vector2: ...

  @staticmethod
  def fromLengthDirection(length: float, direction: float) -> Vector2: ...

  @overload
  def __init__(self):
    self.x: float

    self.y: float

    self.z: float

  @overload
  def __init__(self, other: Vector3): ...
  @overload
  def __init__(self, x: float, y: float, z: float): ...


class WaterShader(Shader):

  def startMainThread(self, texd: TextureDraw, playerIndex: int) -> None: ...

  def updateWaterParams(self, texd: TextureDraw, userId: int) -> None: ...

  def __init__(self, name: str): ...


class WorldConverter:

  converting: bool

  instance: WorldConverter

  def convert(self, worldName: str, manager: IsoSpriteManager) -> None: ...

  def softreset(self) -> None: ...

  def __init__(self):
    self.tilesetconversions: HashMap[Integer, Integer]


class WorldMarkers:

  instance: WorldMarkers

  def addDirectionArrow(self, player: IsoPlayer, x: int, y: int, z: int, texname: str, r: float, g: float, b: float, a: float) -> WorldMarkers.DirectionArrow: ...

  @overload
  def addGridSquareMarker(self, gs: IsoGridSquare, r: float, g: float, b: float, doAlpha: bool, size: float) -> WorldMarkers.GridSquareMarker: ...

  @overload
  def addGridSquareMarker(self, texid: str, overlay: str, gs: IsoGridSquare, r: float, g: float, b: float, doAlpha: bool, size: float) -> WorldMarkers.GridSquareMarker: ...

  @overload
  def addGridSquareMarker(self, texid: str, overlay: str, gs: IsoGridSquare, r: float, g: float, b: float, doAlpha: bool, size: float, fadeSpeed: float, fadeMin: float, fadeMax: float) -> WorldMarkers.GridSquareMarker: ...

  @overload
  def addPlayerHomingPoint(self, player: IsoPlayer, x: int, y: int) -> WorldMarkers.PlayerHomingPoint: ...

  @overload
  def addPlayerHomingPoint(self, player: IsoPlayer, x: int, y: int, r: float, g: float, b: float, a: float) -> WorldMarkers.PlayerHomingPoint: ...

  @overload
  def addPlayerHomingPoint(self, player: IsoPlayer, x: int, y: int, texname: str, r: float, g: float, b: float, a: float, homeOnTarget: bool, homeOnDist: int) -> WorldMarkers.PlayerHomingPoint: ...

  def debugRender(self) -> None: ...

  def getDirectionArrow(self, id: int) -> WorldMarkers.DirectionArrow: ...

  def getGridSquareMarker(self, id: int) -> WorldMarkers.GridSquareMarker: ...

  def getHomingPoint(self, id: int) -> WorldMarkers.PlayerHomingPoint: ...

  def init(self) -> None: ...

  def removeAllDirectionArrows(self, player: IsoPlayer) -> None: ...

  def removeAllHomingPoints(self, player: IsoPlayer) -> None: ...

  @overload
  def removeDirectionArrow(self, id: int) -> bool: ...

  @overload
  def removeDirectionArrow(self, arrow: WorldMarkers.DirectionArrow) -> bool: ...

  @overload
  def removeGridSquareMarker(self, id: int) -> bool: ...

  @overload
  def removeGridSquareMarker(self, marker: WorldMarkers.GridSquareMarker) -> bool: ...

  @overload
  def removeHomingPoint(self, id: int) -> bool: ...

  @overload
  def removeHomingPoint(self, point: WorldMarkers.PlayerHomingPoint) -> bool: ...

  @overload
  def removePlayerDirectionArrow(self, player: IsoPlayer, id: int) -> bool: ...

  @overload
  def removePlayerDirectionArrow(self, player: IsoPlayer, arrow: WorldMarkers.DirectionArrow) -> bool: ...

  @overload
  def removePlayerHomingPoint(self, player: IsoPlayer, id: int) -> bool: ...

  @overload
  def removePlayerHomingPoint(self, player: IsoPlayer, point: WorldMarkers.PlayerHomingPoint) -> bool: ...

  def render(self) -> None: ...

  def renderDirectionArrow(self, worldDraw: bool) -> None: ...

  def renderGridSquareMarkers(self, perPlayerRender: IsoCell.PerPlayerRender, zLayer: int, playerIndex: int) -> None: ...

  def renderHomingPoint(self) -> None: ...

  def reset(self) -> None: ...

  def update(self) -> None: ...

  @staticmethod
  def intersectLineSegments(l1: WorldMarkers.Line, l2: WorldMarkers.Line, intersection: WorldMarkers.Point) -> bool: ...

  class DirectionArrow:

    doDebug: bool

    def getA(self) -> float: ...

    def getB(self) -> float: ...

    def getG(self) -> float: ...

    def getID(self) -> int: ...

    def getR(self) -> float: ...

    def getRenderHeight(self) -> float: ...

    def getRenderWidth(self) -> float: ...

    def getX(self) -> int: ...

    def getY(self) -> int: ...

    def getZ(self) -> int: ...

    def isActive(self) -> bool: ...

    def isRemoved(self) -> bool: ...

    def remove(self) -> None: ...

    def setA(self, arg0: float) -> None: ...

    def setActive(self, arg0: bool) -> None: ...

    def setB(self, arg0: float) -> None: ...

    def setG(self, arg0: float) -> None: ...

    def setR(self, arg0: float) -> None: ...

    def setRGBA(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None: ...

    def setRenderHeight(self, arg0: float) -> None: ...

    def setRenderWidth(self, arg0: float) -> None: ...

    def setTexDown(self, arg0: str) -> None: ...

    def setTexStairsDown(self, arg0: str) -> None: ...

    def setTexStairsUp(self, arg0: str) -> None: ...

    def setTexture(self, arg0: str) -> None: ...

    def setX(self, arg0: int) -> None: ...

    def setY(self, arg0: int) -> None: ...

    def setZ(self, arg0: int) -> None: ...

    def __init__(self, arg0: WorldMarkers, arg1: int): ...

    class DebugStuff: ...

  class PlayerHomingPointList(ArrayList): ...

  class DirectionArrowList(ArrayList): ...

  class PlayerScreen: ...

  class Point:

    def notInfinite(self) -> bool: ...

    def set(self, arg0: float, arg1: float) -> WorldMarkers.Point: ...

    def toString(self) -> str: ...

  class Line:

    def toString(self) -> str: ...

  class PlayerHomingPoint:

    def getA(self) -> float: ...

    def getAngleLerpVal(self) -> float: ...

    def getB(self) -> float: ...

    def getG(self) -> float: ...

    def getHomeOnOffsetX(self) -> float: ...

    def getHomeOnOffsetY(self) -> float: ...

    def getHomeOnTargetDist(self) -> int: ...

    def getID(self) -> int: ...

    def getMovementLerpVal(self) -> float: ...

    def getR(self) -> float: ...

    def getRenderHeight(self) -> float: ...

    def getRenderOffsetX(self) -> float: ...

    def getRenderOffsetY(self) -> float: ...

    def getRenderWidth(self) -> float: ...

    def getStickToCharDist(self) -> float: ...

    def getTargetAngle(self) -> float: ...

    def getX(self) -> int: ...

    def getY(self) -> int: ...

    def isActive(self) -> bool: ...

    def isCustomTargetAngle(self) -> bool: ...

    def isHomeOnTargetInView(self) -> bool: ...

    def isRemoved(self) -> bool: ...

    def remove(self) -> None: ...

    def setA(self, a: float) -> None: ...

    def setActive(self, active: bool) -> None: ...

    def setAngleLerpVal(self, angleLerpVal: float) -> None: ...

    def setB(self, b: float) -> None: ...

    def setCustomTargetAngle(self, customTargetAngle: bool) -> None: ...

    def setG(self, g: float) -> None: ...

    def setHighCounter(self) -> None: ...

    def setHomeOnOffsetX(self, homeOnOffsetX: float) -> None: ...

    def setHomeOnOffsetY(self, homeOnOffsetY: float) -> None: ...

    def setHomeOnTargetDist(self, homeOnTargetDist: int) -> None: ...

    def setHomeOnTargetInView(self, homeOnTargetInView: bool) -> None: ...

    def setMovementLerpVal(self, movementLerpVal: float) -> None: ...

    def setR(self, r: float) -> None: ...

    def setRenderHeight(self, renderHeight: float) -> None: ...

    def setRenderOffsetX(self, renderOffsetX: float) -> None: ...

    def setRenderOffsetY(self, renderOffsetY: float) -> None: ...

    def setRenderWidth(self, renderWidth: float) -> None: ...

    def setStickToCharDist(self, stickToCharDist: float) -> None: ...

    def setTableSurface(self) -> None: ...

    def setTargetAngle(self, targetAngle: float) -> None: ...

    def setTexture(self, texname: str) -> None: ...

    def setX(self, x: int) -> None: ...

    def setXOffsetScaled(self, offset: float) -> None: ...

    def setY(self, y: int) -> None: ...

    def setYOffsetScaled(self, offset: float) -> None: ...

    def __init__(self, plrIndex: int): ...

  class GridSquareMarker:

    def getA(self) -> float: ...

    def getAlpha(self) -> float: ...

    def getAlphaMax(self) -> float: ...

    def getAlphaMin(self) -> float: ...

    def getB(self) -> float: ...

    def getFadeSpeed(self) -> float: ...

    def getG(self) -> float: ...

    def getID(self) -> int: ...

    def getR(self) -> float: ...

    def getSize(self) -> float: ...

    def getX(self) -> float: ...

    def getY(self) -> float: ...

    def getZ(self) -> float: ...

    def init(self, texid: str, overlay: str, x: int, y: int, z: int, size: float) -> None: ...

    def isActive(self) -> bool: ...

    def isDoAlpha(self) -> bool: ...

    def isDoBlink(self) -> bool: ...

    def isRemoved(self) -> bool: ...

    def isScaleCircleTexture(self) -> bool: ...

    def remove(self) -> None: ...

    def setA(self, a: float) -> None: ...

    def setActive(self, active: bool) -> None: ...

    def setAlpha(self, alpha: float) -> None: ...

    def setAlphaMax(self, alphaMax: float) -> None: ...

    def setAlphaMin(self, alphaMin: float) -> None: ...

    def setB(self, b: float) -> None: ...

    def setDoAlpha(self, doAlpha: bool) -> None: ...

    def setDoBlink(self, doBlink: bool) -> None: ...

    def setFadeSpeed(self, fadeSpeed: float) -> None: ...

    def setG(self, g: float) -> None: ...

    def setPos(self, x: int, y: int, z: int) -> None: ...

    def setPosAndSize(self, x: int, y: int, z: int, size: float) -> None: ...

    def setR(self, r: float) -> None: ...

    def setScaleCircleTexture(self, bScale: bool) -> None: ...

    def setSize(self, size: float) -> None: ...

    def __init__(self): ...


class WorldObjectsSyncRequests:

  def putRequest(self, ch: IsoChunk) -> None: ...

  def receiveIsoSync(self, x: int, y: int) -> None: ...

  def sendRequests(self, connection: UdpConnection) -> None: ...

  def __init__(self):
    self.requests: ArrayList[WorldObjectsSyncRequests.SyncData]
    self.timeout: int

  class SyncData: ...


class WorldReuserThread:

  instance: WorldReuserThread

  def addReuseChunk(self, chunk: IsoChunk) -> None: ...

  def reconcileReuseObjects(self) -> None: ...

  def reuseGridSquares(self, chunk: IsoChunk) -> None: ...

  def run(self) -> None: ...

  def testReuseChunk(self) -> None: ...

  def __init__(self):
    self.finished: bool


class WorldStreamer:

  instance: WorldStreamer

  def DoChunk(self, chunk: IsoChunk, fromServer: ByteBuffer) -> None: ...

  def DoChunkAlways(self, chunk: IsoChunk, fromServer: ByteBuffer) -> None: ...

  def addJob(self, chunk: IsoChunk, wx: int, wy: int, bDoServerRequest: bool) -> None: ...

  def addJobConvert(self, chunk: IsoChunk, x: int, y: int, wx: int, wy: int) -> None: ...

  def addJobInstant(self, chunk: IsoChunk, x: int, y: int, wx: int, wy: int) -> None: ...

  def addJobWipe(self, chunk: IsoChunk, x: int, y: int, wx: int, wy: int) -> None: ...

  def create(self) -> None: ...

  def getStatistics(self) -> None: ...

  def isBusy(self) -> bool: ...

  def quit(self) -> None: ...

  def receiveChunkPart(self, bb: ByteBuffer) -> None: ...

  def receiveNotRequired(self, bb: ByteBuffer) -> None: ...

  def requestLargeAreaZip(self, wx: int, wy: int, range: int) -> None: ...

  def stop(self) -> None: ...

  def updateMain(self) -> None: ...

  def __init__(self):
    self.bfinished: bool
    self.worldstreamer: Thread

  class ChunkRequest: ...

  class ChunkComparator:

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: IsoChunk, arg1: IsoChunk) -> int: ...

    def equals(self, arg0: object) -> bool: ...

    def init(self) -> None: ...

    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

    def __init__(self): ...


class test_DiamondMatrixIterator(Assert):

  def test10(self) -> None: ...

  def test3(self) -> None: ...

  def test3a(self) -> None: ...

  def test3i(self) -> None: ...

  def test4(self) -> None: ...

  def test4i(self) -> None: ...

  def __init__(self): ...


class test_ObjectsSyncRequests_getObjectInsertIndex(Assert):

  def test_getInsertIndex(self) -> None: ...

  def test_getInsertIndex2(self) -> None: ...

  def test_getInsertIndex3(self) -> None: ...

  def __init__(self): ...


class test_ParticlesArray(Assert):

  def test_ParticlesArray_Failure(self) -> None: ...

  def test_ParticlesArray_functional(self) -> None: ...

  def test_ParticlesArray_time(self) -> None: ...

  def __init__(self): ...

