from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.lang import Long, Enum
from java.time import Clock, ZoneId, ZoneOffset, Instant, LocalTime, LocalDate, LocalDateTime, Period, ZonedDateTime
from java.time.format import TextStyle, ResolverStyle, DateTimeFormatter
from java.time.temporal import TemporalAccessor, ChronoField, ValueRange, TemporalField, Temporal, TemporalUnit, TemporalAmount, TemporalQuery
from java.util import List, Locale, Map, Set, Comparator

R = TypeVar('R', default=Any)
D = TypeVar('D', default=Any)

class AbstractChronology:

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: Chronology) -> int: ...

  @overload
  def compareTo(self, arg0: Chronology) -> int: ...

  @overload
  def date(self, arg0: TemporalAccessor) -> ChronoLocalDate: ...

  @overload
  def date(self, arg0: int, arg1: int, arg2: int) -> ChronoLocalDate: ...

  @overload
  def date(self, arg0: Era, arg1: int, arg2: int, arg3: int) -> ChronoLocalDate: ...

  def dateEpochDay(self, arg0: int) -> ChronoLocalDate: ...

  @overload
  def dateNow(self) -> ChronoLocalDate: ...

  @overload
  def dateNow(self, arg0: Clock) -> ChronoLocalDate: ...

  @overload
  def dateNow(self, arg0: ZoneId) -> ChronoLocalDate: ...

  @overload
  def dateYearDay(self, arg0: int, arg1: int) -> ChronoLocalDate: ...

  @overload
  def dateYearDay(self, arg0: Era, arg1: int, arg2: int) -> ChronoLocalDate: ...

  @overload
  def epochSecond(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: ZoneOffset) -> int: ...

  @overload
  def epochSecond(self, arg0: Era, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: ZoneOffset) -> int: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  def eraOf(self, arg0: int) -> Era: ...

  def eras(self) -> List[Era]: ...

  def getCalendarType(self) -> str: ...

  def getDisplayName(self, arg0: TextStyle, arg1: Locale) -> str: ...

  def getId(self) -> str: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  def isLeapYear(self, arg0: int) -> bool: ...

  def localDateTime(self, arg0: TemporalAccessor) -> ChronoLocalDateTime[ChronoLocalDate]: ...

  def period(self, arg0: int, arg1: int, arg2: int) -> ChronoPeriod: ...

  def prolepticYear(self, arg0: Era, arg1: int) -> int: ...

  def range(self, arg0: ChronoField) -> ValueRange: ...

  @overload
  def resolveDate(self, arg0: Map[TemporalField, Long], arg1: ResolverStyle) -> ChronoLocalDate: ...

  @overload
  def resolveDate(self, arg0: Map[TemporalField, Long], arg1: ResolverStyle) -> ChronoLocalDate: ...

  @overload
  def toString(self) -> str: ...

  @overload
  def toString(self) -> str: ...

  @overload
  def zonedDateTime(self, arg0: TemporalAccessor) -> ChronoZonedDateTime[ChronoLocalDate]: ...

  @overload
  def zonedDateTime(self, arg0: Instant, arg1: ZoneId) -> ChronoZonedDateTime[ChronoLocalDate]: ...

  @staticmethod
  def getAvailableChronologies() -> Set[Chronology]: ...

  @staticmethod
  def of(arg0: str) -> Chronology: ...

  @staticmethod
  def ofLocale(arg0: Locale) -> Chronology: ...


class ChronoLocalDate:

  @overload
  def adjustInto(self, arg0: Temporal) -> Temporal: ...

  @overload
  def adjustInto(self, arg0: Temporal) -> Temporal: ...

  def atTime(self, arg0: LocalTime) -> ChronoLocalDateTime[Any]: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: ChronoLocalDate) -> int: ...

  def equals(self, arg0: object) -> bool: ...

  def format(self, arg0: DateTimeFormatter) -> str: ...

  def getChronology(self) -> Chronology: ...

  def getEra(self) -> Era: ...

  def hashCode(self) -> int: ...

  def isAfter(self, arg0: ChronoLocalDate) -> bool: ...

  def isBefore(self, arg0: ChronoLocalDate) -> bool: ...

  def isEqual(self, arg0: ChronoLocalDate) -> bool: ...

  def isLeapYear(self) -> bool: ...

  @overload
  def isSupported(self, arg0: TemporalField) -> bool: ...

  @overload
  def isSupported(self, arg0: TemporalUnit) -> bool: ...

  @overload
  def isSupported(self, arg0: TemporalUnit) -> bool: ...

  def lengthOfMonth(self) -> int: ...

  def lengthOfYear(self) -> int: ...

  @overload
  def minus(self, arg0: TemporalAmount) -> ChronoLocalDate: ...

  @overload
  def minus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def minus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def minus(self, arg0: int, arg1: TemporalUnit) -> ChronoLocalDate: ...

  @overload
  def minus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  @overload
  def minus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  @overload
  def plus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def plus(self, arg0: TemporalAmount) -> ChronoLocalDate: ...

  @overload
  def plus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def plus(self, arg0: int, arg1: TemporalUnit) -> ChronoLocalDate: ...

  @overload
  def plus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  @overload
  def plus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  def query(self, arg0: TemporalQuery[R]) -> object: ...

  def toEpochDay(self) -> int: ...

  def toString(self) -> str: ...

  @overload
  def until(self, arg0: ChronoLocalDate) -> ChronoPeriod: ...

  @overload
  def until(self, arg0: Temporal, arg1: TemporalUnit) -> int: ...

  @overload
  def until(self, arg0: Temporal, arg1: TemporalUnit) -> int: ...

  @staticmethod
  def timeLineOrder() -> Comparator[ChronoLocalDate]: ...


class ChronoLocalDateTime[D]:

  @overload
  def adjustInto(self, arg0: Temporal) -> Temporal: ...

  @overload
  def adjustInto(self, arg0: Temporal) -> Temporal: ...

  def atZone(self, arg0: ZoneId) -> ChronoZonedDateTime[D]: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: ChronoLocalDateTime[Any]) -> int: ...

  def equals(self, arg0: object) -> bool: ...

  def format(self, arg0: DateTimeFormatter) -> str: ...

  def getChronology(self) -> Chronology: ...

  def hashCode(self) -> int: ...

  def isAfter(self, arg0: ChronoLocalDateTime[Any]) -> bool: ...

  def isBefore(self, arg0: ChronoLocalDateTime[Any]) -> bool: ...

  def isEqual(self, arg0: ChronoLocalDateTime[Any]) -> bool: ...

  @overload
  def isSupported(self, arg0: TemporalField) -> bool: ...

  @overload
  def isSupported(self, arg0: TemporalUnit) -> bool: ...

  @overload
  def isSupported(self, arg0: TemporalUnit) -> bool: ...

  @overload
  def minus(self, arg0: TemporalAmount) -> ChronoLocalDateTime[D]: ...

  @overload
  def minus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def minus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def minus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  @overload
  def minus(self, arg0: int, arg1: TemporalUnit) -> ChronoLocalDateTime[D]: ...

  @overload
  def minus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  @overload
  def plus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def plus(self, arg0: TemporalAmount) -> ChronoLocalDateTime[D]: ...

  @overload
  def plus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def plus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  @overload
  def plus(self, arg0: int, arg1: TemporalUnit) -> ChronoLocalDateTime[D]: ...

  @overload
  def plus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  def query(self, arg0: TemporalQuery[R]) -> object: ...

  def toEpochSecond(self, arg0: ZoneOffset) -> int: ...

  def toInstant(self, arg0: ZoneOffset) -> Instant: ...

  def toLocalDate(self) -> D: ...

  def toLocalTime(self) -> LocalTime: ...

  def toString(self) -> str: ...

  def until(self, arg0: Temporal, arg1: TemporalUnit) -> int: ...

  @staticmethod
  def timeLineOrder() -> Comparator[ChronoLocalDateTime[Any]]: ...


class ChronoPeriod:

  @overload
  def addTo(self, arg0: Temporal) -> Temporal: ...

  @overload
  def addTo(self, arg0: Temporal) -> Temporal: ...

  def equals(self, arg0: object) -> bool: ...

  @overload
  def get(self, arg0: TemporalUnit) -> int: ...

  @overload
  def get(self, arg0: TemporalUnit) -> int: ...

  def getChronology(self) -> Chronology: ...

  @overload
  def getUnits(self) -> List[TemporalUnit]: ...

  @overload
  def getUnits(self) -> List[TemporalUnit]: ...

  def hashCode(self) -> int: ...

  def isNegative(self) -> bool: ...

  def isZero(self) -> bool: ...

  def minus(self, arg0: TemporalAmount) -> ChronoPeriod: ...

  def multipliedBy(self, arg0: int) -> ChronoPeriod: ...

  def negated(self) -> ChronoPeriod: ...

  def normalized(self) -> ChronoPeriod: ...

  def plus(self, arg0: TemporalAmount) -> ChronoPeriod: ...

  @overload
  def subtractFrom(self, arg0: Temporal) -> Temporal: ...

  @overload
  def subtractFrom(self, arg0: Temporal) -> Temporal: ...

  def toString(self) -> str: ...

  @staticmethod
  def between(arg0: ChronoLocalDate, arg1: ChronoLocalDate) -> ChronoPeriod: ...


class ChronoZonedDateTime[D]:

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: ChronoZonedDateTime[Any]) -> int: ...

  def equals(self, arg0: object) -> bool: ...

  def format(self, arg0: DateTimeFormatter) -> str: ...

  def get(self, arg0: TemporalField) -> int: ...

  def getChronology(self) -> Chronology: ...

  def getLong(self, arg0: TemporalField) -> int: ...

  def getOffset(self) -> ZoneOffset: ...

  def getZone(self) -> ZoneId: ...

  def hashCode(self) -> int: ...

  def isAfter(self, arg0: ChronoZonedDateTime[Any]) -> bool: ...

  def isBefore(self, arg0: ChronoZonedDateTime[Any]) -> bool: ...

  def isEqual(self, arg0: ChronoZonedDateTime[Any]) -> bool: ...

  @overload
  def isSupported(self, arg0: TemporalField) -> bool: ...

  @overload
  def isSupported(self, arg0: TemporalUnit) -> bool: ...

  @overload
  def isSupported(self, arg0: TemporalUnit) -> bool: ...

  @overload
  def minus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def minus(self, arg0: TemporalAmount) -> ChronoZonedDateTime[D]: ...

  @overload
  def minus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def minus(self, arg0: int, arg1: TemporalUnit) -> ChronoZonedDateTime[D]: ...

  @overload
  def minus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  @overload
  def minus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  @overload
  def plus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def plus(self, arg0: TemporalAmount) -> ChronoZonedDateTime[D]: ...

  @overload
  def plus(self, arg0: TemporalAmount) -> Temporal: ...

  @overload
  def plus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  @overload
  def plus(self, arg0: int, arg1: TemporalUnit) -> ChronoZonedDateTime[D]: ...

  @overload
  def plus(self, arg0: int, arg1: TemporalUnit) -> Temporal: ...

  def query(self, arg0: TemporalQuery[R]) -> object: ...

  def range(self, arg0: TemporalField) -> ValueRange: ...

  def toEpochSecond(self) -> int: ...

  def toInstant(self) -> Instant: ...

  def toLocalDate(self) -> D: ...

  def toLocalDateTime(self) -> ChronoLocalDateTime[D]: ...

  def toLocalTime(self) -> LocalTime: ...

  def toString(self) -> str: ...

  def until(self, arg0: Temporal, arg1: TemporalUnit) -> int: ...

  def withEarlierOffsetAtOverlap(self) -> ChronoZonedDateTime[D]: ...

  def withLaterOffsetAtOverlap(self) -> ChronoZonedDateTime[D]: ...

  def withZoneSameInstant(self, arg0: ZoneId) -> ChronoZonedDateTime[D]: ...

  def withZoneSameLocal(self, arg0: ZoneId) -> ChronoZonedDateTime[D]: ...

  @staticmethod
  def timeLineOrder() -> Comparator[ChronoZonedDateTime[Any]]: ...


class Chronology:

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: Chronology) -> int: ...

  @overload
  def date(self, arg0: TemporalAccessor) -> ChronoLocalDate: ...

  @overload
  def date(self, arg0: int, arg1: int, arg2: int) -> ChronoLocalDate: ...

  @overload
  def date(self, arg0: Era, arg1: int, arg2: int, arg3: int) -> ChronoLocalDate: ...

  def dateEpochDay(self, arg0: int) -> ChronoLocalDate: ...

  @overload
  def dateNow(self) -> ChronoLocalDate: ...

  @overload
  def dateNow(self, arg0: Clock) -> ChronoLocalDate: ...

  @overload
  def dateNow(self, arg0: ZoneId) -> ChronoLocalDate: ...

  @overload
  def dateYearDay(self, arg0: int, arg1: int) -> ChronoLocalDate: ...

  @overload
  def dateYearDay(self, arg0: Era, arg1: int, arg2: int) -> ChronoLocalDate: ...

  @overload
  def epochSecond(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: ZoneOffset) -> int: ...

  @overload
  def epochSecond(self, arg0: Era, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: ZoneOffset) -> int: ...

  def equals(self, arg0: object) -> bool: ...

  def eraOf(self, arg0: int) -> Era: ...

  def eras(self) -> List[Era]: ...

  def getCalendarType(self) -> str: ...

  def getDisplayName(self, arg0: TextStyle, arg1: Locale) -> str: ...

  def getId(self) -> str: ...

  def hashCode(self) -> int: ...

  def isLeapYear(self, arg0: int) -> bool: ...

  def localDateTime(self, arg0: TemporalAccessor) -> ChronoLocalDateTime[ChronoLocalDate]: ...

  def period(self, arg0: int, arg1: int, arg2: int) -> ChronoPeriod: ...

  def prolepticYear(self, arg0: Era, arg1: int) -> int: ...

  def range(self, arg0: ChronoField) -> ValueRange: ...

  def resolveDate(self, arg0: Map[TemporalField, Long], arg1: ResolverStyle) -> ChronoLocalDate: ...

  def toString(self) -> str: ...

  @overload
  def zonedDateTime(self, arg0: TemporalAccessor) -> ChronoZonedDateTime[ChronoLocalDate]: ...

  @overload
  def zonedDateTime(self, arg0: Instant, arg1: ZoneId) -> ChronoZonedDateTime[ChronoLocalDate]: ...

  @staticmethod
  def getAvailableChronologies() -> Set[Chronology]: ...

  @staticmethod
  def of(arg0: str) -> Chronology: ...

  @staticmethod
  def ofLocale(arg0: Locale) -> Chronology: ...


class Era:

  @overload
  def adjustInto(self, arg0: Temporal) -> Temporal: ...

  @overload
  def adjustInto(self, arg0: Temporal) -> Temporal: ...

  @overload
  def get(self, arg0: TemporalField) -> int: ...

  @overload
  def get(self, arg0: TemporalField) -> int: ...

  def getDisplayName(self, arg0: TextStyle, arg1: Locale) -> str: ...

  @overload
  def getLong(self, arg0: TemporalField) -> int: ...

  @overload
  def getLong(self, arg0: TemporalField) -> int: ...

  def getValue(self) -> int: ...

  @overload
  def isSupported(self, arg0: TemporalField) -> bool: ...

  @overload
  def isSupported(self, arg0: TemporalField) -> bool: ...

  @overload
  def query(self, arg0: TemporalQuery[R]) -> object: ...

  @overload
  def query(self, arg0: TemporalQuery[R]) -> object: ...

  @overload
  def range(self, arg0: TemporalField) -> ValueRange: ...

  @overload
  def range(self, arg0: TemporalField) -> ValueRange: ...


class IsoChronology(AbstractChronology):

  INSTANCE: IsoChronology

  @overload
  def date(self, arg0: TemporalAccessor) -> ChronoLocalDate: ...

  @overload
  def date(self, arg0: TemporalAccessor) -> LocalDate: ...

  @overload
  def date(self, arg0: int, arg1: int, arg2: int) -> LocalDate: ...

  @overload
  def date(self, arg0: int, arg1: int, arg2: int) -> ChronoLocalDate: ...

  @overload
  def date(self, arg0: Era, arg1: int, arg2: int, arg3: int) -> LocalDate: ...

  @overload
  def date(self, arg0: Era, arg1: int, arg2: int, arg3: int) -> ChronoLocalDate: ...

  @overload
  def dateEpochDay(self, arg0: int) -> LocalDate: ...

  @overload
  def dateEpochDay(self, arg0: int) -> ChronoLocalDate: ...

  @overload
  def dateNow(self) -> LocalDate: ...

  @overload
  def dateNow(self) -> ChronoLocalDate: ...

  @overload
  def dateNow(self, arg0: Clock) -> ChronoLocalDate: ...

  @overload
  def dateNow(self, arg0: Clock) -> LocalDate: ...

  @overload
  def dateNow(self, arg0: ZoneId) -> ChronoLocalDate: ...

  @overload
  def dateNow(self, arg0: ZoneId) -> LocalDate: ...

  @overload
  def dateYearDay(self, arg0: int, arg1: int) -> LocalDate: ...

  @overload
  def dateYearDay(self, arg0: int, arg1: int) -> ChronoLocalDate: ...

  @overload
  def dateYearDay(self, arg0: Era, arg1: int, arg2: int) -> LocalDate: ...

  @overload
  def dateYearDay(self, arg0: Era, arg1: int, arg2: int) -> ChronoLocalDate: ...

  def epochSecond(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: ZoneOffset) -> int: ...

  @overload
  def eraOf(self, arg0: int) -> IsoEra: ...

  @overload
  def eraOf(self, arg0: int) -> Era: ...

  def eras(self) -> List[Era]: ...

  def getCalendarType(self) -> str: ...

  def getId(self) -> str: ...

  def isLeapYear(self, arg0: int) -> bool: ...

  @overload
  def localDateTime(self, arg0: TemporalAccessor) -> LocalDateTime: ...

  @overload
  def localDateTime(self, arg0: TemporalAccessor) -> ChronoLocalDateTime: ...

  @overload
  def period(self, arg0: int, arg1: int, arg2: int) -> Period: ...

  @overload
  def period(self, arg0: int, arg1: int, arg2: int) -> ChronoPeriod: ...

  def prolepticYear(self, arg0: Era, arg1: int) -> int: ...

  def range(self, arg0: ChronoField) -> ValueRange: ...

  @overload
  def resolveDate(self, arg0: Map, arg1: ResolverStyle) -> ChronoLocalDate: ...

  @overload
  def resolveDate(self, arg0: Map[TemporalField, Long], arg1: ResolverStyle) -> LocalDate: ...

  @overload
  def zonedDateTime(self, arg0: TemporalAccessor) -> ZonedDateTime: ...

  @overload
  def zonedDateTime(self, arg0: TemporalAccessor) -> ChronoZonedDateTime: ...

  @overload
  def zonedDateTime(self, arg0: Instant, arg1: ZoneId) -> ChronoZonedDateTime: ...

  @overload
  def zonedDateTime(self, arg0: Instant, arg1: ZoneId) -> ZonedDateTime: ...


class IsoEra(Enum):

  BCE: IsoEra

  CE: IsoEra

  def adjustInto(self, arg0: Temporal) -> Temporal: ...

  def get(self, arg0: TemporalField) -> int: ...

  def getDisplayName(self, arg0: TextStyle, arg1: Locale) -> str: ...

  def getLong(self, arg0: TemporalField) -> int: ...

  @overload
  def getValue(self) -> int: ...

  @overload
  def getValue(self) -> int: ...

  def isSupported(self, arg0: TemporalField) -> bool: ...

  def query(self, arg0: TemporalQuery[R]) -> object: ...

  def range(self, arg0: TemporalField) -> ValueRange: ...

  @staticmethod
  def of(arg0: int) -> IsoEra: ...

  @staticmethod
  def valueOf(arg0: str) -> IsoEra: ...

  @staticmethod
  def values() -> list[IsoEra]: ...

