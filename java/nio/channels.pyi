from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.io import IOException
from java.lang import Integer, Throwable
from java.net import SocketAddress, InetAddress, NetworkInterface, SocketOption, DatagramSocket, ProtocolFamily, ServerSocket, Socket
from java.nio import ByteBuffer, MappedByteBuffer
from java.nio.channels.spi import AbstractSelectableChannel, AbstractInterruptibleChannel, SelectorProvider
from java.nio.file import Path, OpenOption
from java.nio.file.attribute import FileAttribute
from java.util import Set
from java.util.concurrent import Future, ExecutorService
from java.util.function import Consumer

A = TypeVar('A', default=Any)
V = TypeVar('V', default=Any)
T = TypeVar('T', default=Any)

class AsynchronousChannel:

  @overload
  def close(self) -> None: ...

  @overload
  def close(self) -> None: ...

  def isOpen(self) -> bool: ...


class AsynchronousCloseException(ClosedChannelException):

  def __init__(self): ...


class AsynchronousFileChannel:

  def close(self) -> None: ...

  def force(self, arg0: bool) -> None: ...

  @overload
  def lock(self) -> Future[FileLock]: ...

  @overload
  def lock(self, arg0: object, arg1: CompletionHandler[FileLock, A]) -> None: ...

  @overload
  def lock(self, arg0: int, arg1: int, arg2: bool) -> Future[FileLock]: ...

  @overload
  def lock(self, arg0: int, arg1: int, arg2: bool, arg3: object, arg4: CompletionHandler[FileLock, A]) -> None: ...

  @overload
  def read(self, arg0: ByteBuffer, arg1: int) -> Future[Integer]: ...

  @overload
  def read(self, arg0: ByteBuffer, arg1: int, arg2: object, arg3: CompletionHandler[Integer, A]) -> None: ...

  def size(self) -> int: ...

  def truncate(self, arg0: int) -> AsynchronousFileChannel: ...

  @overload
  def tryLock(self) -> FileLock: ...

  @overload
  def tryLock(self, arg0: int, arg1: int, arg2: bool) -> FileLock: ...

  @overload
  def write(self, arg0: ByteBuffer, arg1: int) -> Future[Integer]: ...

  @overload
  def write(self, arg0: ByteBuffer, arg1: int, arg2: object, arg3: CompletionHandler[Integer, A]) -> None: ...

  @staticmethod
  @overload
  def open(arg0: Path, arg1: list[OpenOption]) -> AsynchronousFileChannel: ...

  @staticmethod
  @overload
  def open(arg0: Path, arg1: Set[OpenOption], arg2: ExecutorService, arg3: list[FileAttribute]) -> AsynchronousFileChannel: ...


class ByteChannel:

  def read(self, arg0: ByteBuffer) -> int: ...

  def write(self, arg0: ByteBuffer) -> int: ...


class Channel:

  @overload
  def close(self) -> None: ...

  @overload
  def close(self) -> None: ...

  def isOpen(self) -> bool: ...


class ClosedChannelException(IOException):

  def __init__(self): ...


class CompletionHandler[V, A]:

  def completed(self, arg0: object, arg1: object) -> None: ...

  def failed(self, arg0: Throwable, arg1: object) -> None: ...


class DatagramChannel(AbstractSelectableChannel):

  @overload
  def bind(self, arg0: SocketAddress) -> NetworkChannel: ...

  @overload
  def bind(self, arg0: SocketAddress) -> DatagramChannel: ...

  def close(self) -> None: ...

  def connect(self, arg0: SocketAddress) -> DatagramChannel: ...

  def disconnect(self) -> DatagramChannel: ...

  def getLocalAddress(self) -> SocketAddress: ...

  def getRemoteAddress(self) -> SocketAddress: ...

  def isConnected(self) -> bool: ...

  @overload
  def join(self, arg0: InetAddress, arg1: NetworkInterface) -> MembershipKey: ...

  @overload
  def join(self, arg0: InetAddress, arg1: NetworkInterface, arg2: InetAddress) -> MembershipKey: ...

  @overload
  def read(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def read(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def read(self, arg0: ByteBuffer) -> int: ...

  @overload
  def read(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  @overload
  def read(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  def receive(self, arg0: ByteBuffer) -> SocketAddress: ...

  def send(self, arg0: ByteBuffer, arg1: SocketAddress) -> int: ...

  @overload
  def setOption(self, arg0: SocketOption, arg1: object) -> NetworkChannel: ...

  @overload
  def setOption(self, arg0: SocketOption[T], arg1: object) -> DatagramChannel: ...

  def socket(self) -> DatagramSocket: ...

  def validOps(self) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def write(self, arg0: ByteBuffer) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  @staticmethod
  @overload
  def open() -> DatagramChannel: ...

  @staticmethod
  @overload
  def open(arg0: ProtocolFamily) -> DatagramChannel: ...


class FileChannel(AbstractInterruptibleChannel):

  def force(self, arg0: bool) -> None: ...

  @overload
  def lock(self) -> FileLock: ...

  @overload
  def lock(self, arg0: int, arg1: int, arg2: bool) -> FileLock: ...

  def map(self, arg0: FileChannel.MapMode, arg1: int, arg2: int) -> MappedByteBuffer: ...

  @overload
  def position(self) -> int: ...

  @overload
  def position(self) -> int: ...

  @overload
  def position(self, arg0: int) -> SeekableByteChannel: ...

  @overload
  def position(self, arg0: int) -> FileChannel: ...

  @overload
  def position(self, arg0: int) -> SeekableByteChannel: ...

  @overload
  def read(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def read(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def read(self, arg0: ByteBuffer) -> int: ...

  @overload
  def read(self, arg0: ByteBuffer) -> int: ...

  @overload
  def read(self, arg0: ByteBuffer, arg1: int) -> int: ...

  @overload
  def read(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  @overload
  def read(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  def transferFrom(self, arg0: ReadableByteChannel, arg1: int, arg2: int) -> int: ...

  def transferTo(self, arg0: int, arg1: int, arg2: WritableByteChannel) -> int: ...

  @overload
  def truncate(self, arg0: int) -> SeekableByteChannel: ...

  @overload
  def truncate(self, arg0: int) -> FileChannel: ...

  @overload
  def truncate(self, arg0: int) -> SeekableByteChannel: ...

  @overload
  def tryLock(self) -> FileLock: ...

  @overload
  def tryLock(self, arg0: int, arg1: int, arg2: bool) -> FileLock: ...

  @overload
  def write(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def write(self, arg0: ByteBuffer) -> int: ...

  @overload
  def write(self, arg0: ByteBuffer) -> int: ...

  @overload
  def write(self, arg0: ByteBuffer, arg1: int) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  @staticmethod
  @overload
  def open(arg0: Path, arg1: list[OpenOption]) -> FileChannel: ...

  @staticmethod
  @overload
  def open(arg0: Path, arg1: Set[OpenOption], arg2: list[FileAttribute]) -> FileChannel: ...

  class MapMode:

    PRIVATE: FileChannel.MapMode

    READ_ONLY: FileChannel.MapMode

    READ_WRITE: FileChannel.MapMode

    def toString(self) -> str: ...


class FileLock:

  def acquiredBy(self) -> Channel: ...

  def channel(self) -> FileChannel: ...

  @overload
  def close(self) -> None: ...

  @overload
  def close(self) -> None: ...

  def isShared(self) -> bool: ...

  def isValid(self) -> bool: ...

  def overlaps(self, arg0: int, arg1: int) -> bool: ...

  def position(self) -> int: ...

  def release(self) -> None: ...

  def size(self) -> int: ...

  def toString(self) -> str: ...


class GatheringByteChannel:

  @overload
  def write(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def write(self, arg0: ByteBuffer) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...


class InterruptibleChannel:

  @overload
  def close(self) -> None: ...

  @overload
  def close(self) -> None: ...

  def isOpen(self) -> bool: ...


class MembershipKey:

  def block(self, arg0: InetAddress) -> MembershipKey: ...

  def channel(self) -> MulticastChannel: ...

  def drop(self) -> None: ...

  def group(self) -> InetAddress: ...

  def isValid(self) -> bool: ...

  def networkInterface(self) -> NetworkInterface: ...

  def sourceAddress(self) -> InetAddress: ...

  def unblock(self, arg0: InetAddress) -> MembershipKey: ...


class MulticastChannel:

  def bind(self, arg0: SocketAddress) -> NetworkChannel: ...

  def close(self) -> None: ...

  def getLocalAddress(self) -> SocketAddress: ...

  def getOption(self, arg0: SocketOption[T]) -> object: ...

  @overload
  def join(self, arg0: InetAddress, arg1: NetworkInterface) -> MembershipKey: ...

  @overload
  def join(self, arg0: InetAddress, arg1: NetworkInterface, arg2: InetAddress) -> MembershipKey: ...

  def setOption(self, arg0: SocketOption[T], arg1: object) -> NetworkChannel: ...

  def supportedOptions(self) -> Set[SocketOption[Any]]: ...


class NetworkChannel:

  def bind(self, arg0: SocketAddress) -> NetworkChannel: ...

  def close(self) -> None: ...

  def getLocalAddress(self) -> SocketAddress: ...

  def getOption(self, arg0: SocketOption[T]) -> object: ...

  def isOpen(self) -> bool: ...

  def setOption(self, arg0: SocketOption[T], arg1: object) -> NetworkChannel: ...

  def supportedOptions(self) -> Set[SocketOption[Any]]: ...


class Pipe:

  def sink(self) -> Pipe.SinkChannel: ...

  def source(self) -> Pipe.SourceChannel: ...

  @staticmethod
  def open() -> Pipe: ...

  class SinkChannel(AbstractSelectableChannel):

    def validOps(self) -> int: ...

    @overload
    def write(self, arg0: list[ByteBuffer]) -> int: ...

    @overload
    def write(self, arg0: ByteBuffer) -> int: ...

    @overload
    def write(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  class SourceChannel(AbstractSelectableChannel):

    @overload
    def read(self, arg0: list[ByteBuffer]) -> int: ...

    @overload
    def read(self, arg0: ByteBuffer) -> int: ...

    @overload
    def read(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

    def validOps(self) -> int: ...


class ReadableByteChannel:

  def close(self) -> None: ...

  def isOpen(self) -> bool: ...

  def read(self, arg0: ByteBuffer) -> int: ...


class ScatteringByteChannel:

  @overload
  def read(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def read(self, arg0: ByteBuffer) -> int: ...

  @overload
  def read(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...


class SeekableByteChannel:

  @overload
  def position(self) -> int: ...

  @overload
  def position(self, arg0: int) -> SeekableByteChannel: ...

  def read(self, arg0: ByteBuffer) -> int: ...

  def size(self) -> int: ...

  def truncate(self, arg0: int) -> SeekableByteChannel: ...

  def write(self, arg0: ByteBuffer) -> int: ...


class SelectableChannel(AbstractInterruptibleChannel):

  def blockingLock(self) -> object: ...

  def close(self) -> None: ...

  def configureBlocking(self, arg0: bool) -> SelectableChannel: ...

  def isBlocking(self) -> bool: ...

  def isOpen(self) -> bool: ...

  def isRegistered(self) -> bool: ...

  def keyFor(self, arg0: Selector) -> SelectionKey: ...

  def provider(self) -> SelectorProvider: ...

  @overload
  def register(self, arg0: Selector, arg1: int) -> SelectionKey: ...

  @overload
  def register(self, arg0: Selector, arg1: int, arg2: object) -> SelectionKey: ...

  def validOps(self) -> int: ...


class SelectionKey:

  OP_ACCEPT: int

  OP_CONNECT: int

  OP_READ: int

  OP_WRITE: int

  def attach(self, arg0: object) -> object: ...

  def attachment(self) -> object: ...

  def cancel(self) -> None: ...

  def channel(self) -> SelectableChannel: ...

  @overload
  def interestOps(self) -> int: ...

  @overload
  def interestOps(self, arg0: int) -> SelectionKey: ...

  def interestOpsAnd(self, arg0: int) -> int: ...

  def interestOpsOr(self, arg0: int) -> int: ...

  def isAcceptable(self) -> bool: ...

  def isConnectable(self) -> bool: ...

  def isReadable(self) -> bool: ...

  def isValid(self) -> bool: ...

  def isWritable(self) -> bool: ...

  def readyOps(self) -> int: ...

  def selector(self) -> Selector: ...


class Selector:

  @overload
  def close(self) -> None: ...

  @overload
  def close(self) -> None: ...

  def isOpen(self) -> bool: ...

  def keys(self) -> Set[SelectionKey]: ...

  def provider(self) -> SelectorProvider: ...

  @overload
  def select(self) -> int: ...

  @overload
  def select(self, arg0: Consumer[SelectionKey]) -> int: ...

  @overload
  def select(self, arg0: int) -> int: ...

  @overload
  def select(self, arg0: Consumer[SelectionKey], arg1: int) -> int: ...

  @overload
  def selectNow(self) -> int: ...

  @overload
  def selectNow(self, arg0: Consumer[SelectionKey]) -> int: ...

  def selectedKeys(self) -> Set[SelectionKey]: ...

  def wakeup(self) -> Selector: ...

  @staticmethod
  def open() -> Selector: ...


class ServerSocketChannel(AbstractSelectableChannel):

  def accept(self) -> SocketChannel: ...

  @overload
  def bind(self, arg0: SocketAddress) -> NetworkChannel: ...

  @overload
  def bind(self, arg0: SocketAddress) -> ServerSocketChannel: ...

  @overload
  def bind(self, arg0: SocketAddress) -> NetworkChannel: ...

  @overload
  def bind(self, arg0: SocketAddress, arg1: int) -> ServerSocketChannel: ...

  @overload
  def getLocalAddress(self) -> SocketAddress: ...

  @overload
  def getLocalAddress(self) -> SocketAddress: ...

  def getOption(self, arg0: SocketOption[T]) -> object: ...

  @overload
  def setOption(self, arg0: SocketOption, arg1: object) -> NetworkChannel: ...

  @overload
  def setOption(self, arg0: SocketOption[T], arg1: object) -> ServerSocketChannel: ...

  @overload
  def setOption(self, arg0: SocketOption[T], arg1: object) -> NetworkChannel: ...

  def socket(self) -> ServerSocket: ...

  def supportedOptions(self) -> Set[SocketOption[Any]]: ...

  def validOps(self) -> int: ...

  @staticmethod
  @overload
  def open() -> ServerSocketChannel: ...

  @staticmethod
  @overload
  def open(arg0: ProtocolFamily) -> ServerSocketChannel: ...


class SocketChannel(AbstractSelectableChannel):

  @overload
  def bind(self, arg0: SocketAddress) -> NetworkChannel: ...

  @overload
  def bind(self, arg0: SocketAddress) -> SocketChannel: ...

  @overload
  def bind(self, arg0: SocketAddress) -> NetworkChannel: ...

  def connect(self, arg0: SocketAddress) -> bool: ...

  def finishConnect(self) -> bool: ...

  @overload
  def getLocalAddress(self) -> SocketAddress: ...

  @overload
  def getLocalAddress(self) -> SocketAddress: ...

  def getOption(self, arg0: SocketOption[T]) -> object: ...

  def getRemoteAddress(self) -> SocketAddress: ...

  def isConnected(self) -> bool: ...

  def isConnectionPending(self) -> bool: ...

  @overload
  def read(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def read(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def read(self, arg0: ByteBuffer) -> int: ...

  @overload
  def read(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  @overload
  def read(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  @overload
  def setOption(self, arg0: SocketOption[T], arg1: object) -> SocketChannel: ...

  @overload
  def setOption(self, arg0: SocketOption, arg1: object) -> NetworkChannel: ...

  @overload
  def setOption(self, arg0: SocketOption[T], arg1: object) -> NetworkChannel: ...

  def shutdownInput(self) -> SocketChannel: ...

  def shutdownOutput(self) -> SocketChannel: ...

  def socket(self) -> Socket: ...

  def supportedOptions(self) -> Set[SocketOption[Any]]: ...

  def validOps(self) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer]) -> int: ...

  @overload
  def write(self, arg0: ByteBuffer) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  @overload
  def write(self, arg0: list[ByteBuffer], arg1: int, arg2: int) -> int: ...

  @staticmethod
  @overload
  def open() -> SocketChannel: ...

  @staticmethod
  @overload
  def open(arg0: ProtocolFamily) -> SocketChannel: ...

  @staticmethod
  @overload
  def open(arg0: SocketAddress) -> SocketChannel: ...


class WritableByteChannel:

  def close(self) -> None: ...

  def isOpen(self) -> bool: ...

  def write(self, arg0: ByteBuffer) -> int: ...

