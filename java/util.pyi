from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.io import IOException, File, OutputStream, PrintStream, PrintWriter, InputStream, Reader, Writer
from java.lang import Comparable, Class, Integer, Boolean, Enum, RuntimeException, Throwable, Appendable, StringBuilder, CharSequence, Character, Runnable, Double, Long, ClassLoader, Module, Error, ModuleLayer, Thread, Exception
from java.lang.ref import SoftReference, WeakReference
from java.math import BigInteger
from java.nio import ByteBuffer, LongBuffer
from java.nio.charset import Charset
from java.time import Instant, ZonedDateTime, ZoneId
from java.util.function import Predicate, IntFunction, UnaryOperator, Consumer, BiFunction, Function, BiConsumer, DoubleBinaryOperator, IntBinaryOperator, LongBinaryOperator, BinaryOperator, IntToDoubleFunction, IntUnaryOperator, IntToLongFunction, ToDoubleFunction, ToIntFunction, ToLongFunction, DoubleConsumer, IntConsumer, LongConsumer, Supplier, DoubleSupplier, IntSupplier, LongSupplier
from java.util.random import RandomGenerator
from java.util.spi import CurrencyNameProvider, LocaleServiceProvider, LocaleNameProvider
from java.util.stream import Stream, DoubleStream, IntStream, LongStream
from sun.util.locale import LocaleObjectCache

E = TypeVar('E', default=Any)
T = TypeVar('T', default=Any)
RandomAccessSubList_E = TypeVar('RandomAccessSubList_E', default=Any)
SubList_E = TypeVar('SubList_E', default=Any)
RandomAccessSpliterator_E = TypeVar('RandomAccessSpliterator_E', default=Any)
K = TypeVar('K', default=Any)
V = TypeVar('V', default=Any)
SimpleImmutableEntry_K = TypeVar('SimpleImmutableEntry_K', default=Any)
SimpleImmutableEntry_V = TypeVar('SimpleImmutableEntry_V', default=Any)
SimpleEntry_K = TypeVar('SimpleEntry_K', default=Any)
SimpleEntry_V = TypeVar('SimpleEntry_V', default=Any)
U = TypeVar('U', default=Any)
EmptyNavigableSet_E = TypeVar('EmptyNavigableSet_E', default=Any)
UnmodifiableEntrySet_K = TypeVar('UnmodifiableEntrySet_K', default=Any)
UnmodifiableEntrySet_V = TypeVar('UnmodifiableEntrySet_V', default=Any)
UnmodifiableEntrySetSpliterator_K = TypeVar('UnmodifiableEntrySetSpliterator_K', default=Any)
UnmodifiableEntrySetSpliterator_V = TypeVar('UnmodifiableEntrySetSpliterator_V', default=Any)
UnmodifiableEntry_K = TypeVar('UnmodifiableEntry_K', default=Any)
UnmodifiableEntry_V = TypeVar('UnmodifiableEntry_V', default=Any)
EmptyNavigableMap_K = TypeVar('EmptyNavigableMap_K', default=Any)
EmptyNavigableMap_V = TypeVar('EmptyNavigableMap_V', default=Any)
CheckedEntrySet_K = TypeVar('CheckedEntrySet_K', default=Any)
CheckedEntrySet_V = TypeVar('CheckedEntrySet_V', default=Any)
CheckedEntry_K = TypeVar('CheckedEntry_K', default=Any)
CheckedEntry_V = TypeVar('CheckedEntry_V', default=Any)
SerializationProxy_E = TypeVar('SerializationProxy_E', default=Any)
Node_K = TypeVar('Node_K', default=Any)
Node_V = TypeVar('Node_V', default=Any)
TreeNode_K = TypeVar('TreeNode_K', default=Any)
TreeNode_V = TypeVar('TreeNode_V', default=Any)
EntrySpliterator_K = TypeVar('EntrySpliterator_K', default=Any)
EntrySpliterator_V = TypeVar('EntrySpliterator_V', default=Any)
ValueSpliterator_K = TypeVar('ValueSpliterator_K', default=Any)
ValueSpliterator_V = TypeVar('ValueSpliterator_V', default=Any)
KeySpliterator_K = TypeVar('KeySpliterator_K', default=Any)
KeySpliterator_V = TypeVar('KeySpliterator_V', default=Any)
HashMapSpliterator_K = TypeVar('HashMapSpliterator_K', default=Any)
HashMapSpliterator_V = TypeVar('HashMapSpliterator_V', default=Any)
Entry_K = TypeVar('Entry_K', default=Any)
Entry_V = TypeVar('Entry_V', default=Any)
A = TypeVar('A', default=Any)
IdentityHashMapSpliterator_K = TypeVar('IdentityHashMapSpliterator_K', default=Any)
IdentityHashMapSpliterator_V = TypeVar('IdentityHashMapSpliterator_V', default=Any)
Node_E = TypeVar('Node_E', default=Any)
LLSpliterator_E = TypeVar('LLSpliterator_E', default=Any)
X = TypeVar('X', default=Any)
T_CONS = TypeVar('T_CONS', default=Any)
EnumSetIterator_E = TypeVar('EnumSetIterator_E', default=Any)
S = TypeVar('S', default=Any)
ProviderImpl_S = TypeVar('ProviderImpl_S', default=Any)
Provider_S = TypeVar('Provider_S', default=Any)
OfPrimitive_T = TypeVar('OfPrimitive_T', default=Any)
T_SPLITR = TypeVar('T_SPLITR', default=Any)
C = TypeVar('C', default=Any)
OfRef_T = TypeVar('OfRef_T', default=Any)
HoldingConsumer_T = TypeVar('HoldingConsumer_T', default=Any)
DescendingSubMap_K = TypeVar('DescendingSubMap_K', default=Any)
DescendingSubMap_V = TypeVar('DescendingSubMap_V', default=Any)
AscendingSubMap_K = TypeVar('AscendingSubMap_K', default=Any)
AscendingSubMap_V = TypeVar('AscendingSubMap_V', default=Any)
NavigableSubMap_K = TypeVar('NavigableSubMap_K', default=Any)
NavigableSubMap_V = TypeVar('NavigableSubMap_V', default=Any)
DescendingKeySpliterator_K = TypeVar('DescendingKeySpliterator_K', default=Any)
DescendingKeySpliterator_V = TypeVar('DescendingKeySpliterator_V', default=Any)
TreeMapSpliterator_K = TypeVar('TreeMapSpliterator_K', default=Any)
TreeMapSpliterator_V = TypeVar('TreeMapSpliterator_V', default=Any)
WeakHashMapSpliterator_K = TypeVar('WeakHashMapSpliterator_K', default=Any)
WeakHashMapSpliterator_V = TypeVar('WeakHashMapSpliterator_V', default=Any)

class AbstractCollection[E]:

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def hashCode(self) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  def parallelStream(self) -> Stream[E]: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  def spliterator(self) -> Spliterator[E]: ...

  def stream(self) -> Stream[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

  def toString(self) -> str: ...


class AbstractList[E](AbstractCollection):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def contains(self, arg0: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def get(self, arg0: int) -> object: ...

  @overload
  def get(self, arg0: int) -> object: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def indexOf(self, arg0: object) -> int: ...

  @overload
  def indexOf(self, arg0: object) -> int: ...

  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  @overload
  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  @overload
  def remove(self, arg0: int) -> object: ...

  @overload
  def remove(self, arg0: int) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  def size(self) -> int: ...

  def sort(self, arg0: Comparator[E]) -> None: ...

  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def subList(self, arg0: int, arg1: int) -> List[E]: ...

  @overload
  def subList(self, arg0: int, arg1: int) -> List[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> List[E]: ...

  @staticmethod
  @overload
  def of() -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...

  class Itr:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

  class ListItr(AbstractList.Itr):

    @overload
    def add(self, arg0: object) -> None: ...

    @overload
    def add(self, arg0: object) -> None: ...

    def hasNext(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    def next(self) -> object: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def previousIndex(self) -> int: ...

    def remove(self) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

  class RandomAccessSubList[RandomAccessSubList_E](AbstractList.SubList):

    def subList(self, arg0: int, arg1: int) -> List[E]: ...

  class SubList[SubList_E](AbstractList):

    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    def get(self, arg0: int) -> object: ...

    def iterator(self) -> Iterator[E]: ...

    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    def remove(self, arg0: int) -> object: ...

    def set(self, arg0: int, arg1: object) -> object: ...

    def size(self) -> int: ...

    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    def __init__(self, arg0: AbstractList[E], arg1: int, arg2: int): ...

  class RandomAccessSpliterator[RandomAccessSpliterator_E]:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[E]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator[E]: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...


class AbstractMap[K, V]:

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def containsKey(self, arg0: object) -> bool: ...

  @overload
  def containsKey(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def get(self, arg0: object) -> object: ...

  @overload
  def get(self, arg0: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def keySet(self) -> Set[K]: ...

  @overload
  def keySet(self) -> Set[K]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putAll(self, arg0: Map[K, V]) -> None: ...

  @overload
  def putAll(self, arg0: Map[K, V]) -> None: ...

  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  def toString(self) -> str: ...

  @overload
  def values(self) -> Collection[V]: ...

  @overload
  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

  class SimpleImmutableEntry[SimpleImmutableEntry_K, SimpleImmutableEntry_V]:

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    def toString(self) -> str: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...

    @overload
    def __init__(self, arg0: Map.Entry): ...
    @overload
    def __init__(self, arg0: object, arg1: object): ...

  class SimpleEntry[SimpleEntry_K, SimpleEntry_V]:

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    def toString(self) -> str: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...

    @overload
    def __init__(self, arg0: Map.Entry): ...
    @overload
    def __init__(self, arg0: object, arg1: object): ...


class AbstractQueue[E](AbstractCollection):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  def clear(self) -> None: ...

  @overload
  def element(self) -> object: ...

  @overload
  def element(self) -> object: ...

  def offer(self, arg0: object) -> bool: ...

  def peek(self) -> object: ...

  def poll(self) -> object: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self) -> object: ...


class AbstractSequentialList[E](AbstractList):

  def add(self, arg0: int, arg1: object) -> None: ...

  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  def get(self, arg0: int) -> object: ...

  def iterator(self) -> Iterator[E]: ...

  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  def remove(self, arg0: int) -> object: ...

  def set(self, arg0: int, arg1: object) -> object: ...


class AbstractSet[E](AbstractCollection):

  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  def clear(self) -> None: ...

  def contains(self, arg0: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> Iterator[E]: ...

  def remove(self, arg0: object) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  def size(self) -> int: ...

  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> Set[E]: ...

  @staticmethod
  @overload
  def of() -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...


class ArrayDeque[E](AbstractCollection):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addFirst(self, arg0: object) -> None: ...

  @overload
  def addFirst(self, arg0: object) -> None: ...

  @overload
  def addLast(self, arg0: object) -> None: ...

  @overload
  def addLast(self, arg0: object) -> None: ...

  def clear(self) -> None: ...

  @overload
  def clone(self) -> ArrayDeque[E]: ...

  @overload
  def clone(self) -> object: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def descendingIterator(self) -> Iterator[E]: ...

  @overload
  def descendingIterator(self) -> Iterator[E]: ...

  @overload
  def element(self) -> object: ...

  @overload
  def element(self) -> object: ...

  def forEach(self, arg0: Consumer[E]) -> None: ...

  @overload
  def getFirst(self) -> object: ...

  @overload
  def getFirst(self) -> object: ...

  @overload
  def getLast(self) -> object: ...

  @overload
  def getLast(self) -> object: ...

  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offerFirst(self, arg0: object) -> bool: ...

  @overload
  def offerFirst(self, arg0: object) -> bool: ...

  @overload
  def offerLast(self, arg0: object) -> bool: ...

  @overload
  def offerLast(self, arg0: object) -> bool: ...

  @overload
  def peek(self) -> object: ...

  @overload
  def peek(self) -> object: ...

  @overload
  def peekFirst(self) -> object: ...

  @overload
  def peekFirst(self) -> object: ...

  @overload
  def peekLast(self) -> object: ...

  @overload
  def peekLast(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def pollFirst(self) -> object: ...

  @overload
  def pollFirst(self) -> object: ...

  @overload
  def pollLast(self) -> object: ...

  @overload
  def pollLast(self) -> object: ...

  @overload
  def pop(self) -> object: ...

  @overload
  def pop(self) -> object: ...

  @overload
  def push(self, arg0: object) -> None: ...

  @overload
  def push(self, arg0: object) -> None: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def removeFirst(self) -> object: ...

  @overload
  def removeFirst(self) -> object: ...

  @overload
  def removeFirstOccurrence(self, arg0: object) -> bool: ...

  @overload
  def removeFirstOccurrence(self, arg0: object) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  @overload
  def removeLast(self) -> object: ...

  @overload
  def removeLast(self) -> object: ...

  @overload
  def removeLastOccurrence(self, arg0: object) -> bool: ...

  @overload
  def removeLastOccurrence(self, arg0: object) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...

  class DeqIterator:

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

  class DescendingIterator(ArrayDeque.DeqIterator):

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    def next(self) -> object: ...

  class DeqSpliterator:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[E]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> ArrayDeque.DeqSpliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...


class ArrayList[E](AbstractList):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def clone(self) -> object: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  def ensureCapacity(self, arg0: int) -> None: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  def forEach(self, arg0: Consumer[E]) -> None: ...

  @overload
  def get(self, arg0: int) -> object: ...

  @overload
  def get(self, arg0: int) -> object: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def indexOf(self, arg0: object) -> int: ...

  @overload
  def indexOf(self, arg0: object) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  @overload
  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  @overload
  def remove(self, arg0: int) -> object: ...

  @overload
  def remove(self, arg0: int) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  @overload
  def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

  @overload
  def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  @overload
  def sort(self, arg0: Comparator[E]) -> None: ...

  @overload
  def sort(self, arg0: Comparator[E]) -> None: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def subList(self, arg0: int, arg1: int) -> List[E]: ...

  @overload
  def subList(self, arg0: int, arg1: int) -> List[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  def trimToSize(self) -> None: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> List[E]: ...

  @staticmethod
  @overload
  def of() -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...

  class ListItr(ArrayList.Itr):

    @overload
    def add(self, arg0: object) -> None: ...

    @overload
    def add(self, arg0: object) -> None: ...

    def hasNext(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    def next(self) -> object: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def previousIndex(self) -> int: ...

    def remove(self) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

  class Itr:

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

  class SubList[SubList_E](AbstractList):

    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    def contains(self, arg0: object) -> bool: ...

    def equals(self, arg0: object) -> bool: ...

    def get(self, arg0: int) -> object: ...

    def hashCode(self) -> int: ...

    def indexOf(self, arg0: object) -> int: ...

    def iterator(self) -> Iterator[E]: ...

    def lastIndexOf(self, arg0: object) -> int: ...

    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    def remove(self, arg0: int) -> object: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    def set(self, arg0: int, arg1: object) -> object: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    def __init__(self, arg0: ArrayList[E], arg1: int, arg2: int): ...

  class ArrayListSpliterator:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[E]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> ArrayList.ArrayListSpliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...


class Arrays:

  @staticmethod
  def asList(arg0: list[object]) -> List[T]: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[int], arg1: int) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[str], arg1: str) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[float], arg1: float) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[float], arg1: float) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[int], arg1: int) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[int], arg1: int) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[object], arg1: object) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[int], arg1: int) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[object], arg1: object, arg2: Comparator[T]) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[int], arg1: int, arg2: int, arg3: int) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[str], arg1: int, arg2: int, arg3: str) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[float], arg1: int, arg2: int, arg3: float) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[float], arg1: int, arg2: int, arg3: float) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[int], arg1: int, arg2: int, arg3: int) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[int], arg1: int, arg2: int, arg3: int) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[object], arg1: int, arg2: int, arg3: object) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[int], arg1: int, arg2: int, arg3: int) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: list[object], arg1: int, arg2: int, arg3: object, arg4: Comparator[T]) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[str], arg1: list[str]) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[float], arg1: list[float]) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[float], arg1: list[float]) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[Comparable], arg1: list[Comparable]) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[bool], arg1: list[bool]) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[object], arg1: list[object], arg2: Comparator[T]) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[str], arg1: int, arg2: int, arg3: list[str], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[float], arg1: int, arg2: int, arg3: list[float], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[float], arg1: int, arg2: int, arg3: list[float], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[Comparable], arg1: int, arg2: int, arg3: list[Comparable], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[bool], arg1: int, arg2: int, arg3: list[bool], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compare(arg0: list[object], arg1: int, arg2: int, arg3: list[object], arg4: int, arg5: int, arg6: Comparator[T]) -> int: ...

  @staticmethod
  @overload
  def compareUnsigned(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def compareUnsigned(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def compareUnsigned(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def compareUnsigned(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def compareUnsigned(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compareUnsigned(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compareUnsigned(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def compareUnsigned(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def copyOf(arg0: list[int], arg1: int) -> list[int]: ...

  @staticmethod
  @overload
  def copyOf(arg0: list[str], arg1: int) -> list[str]: ...

  @staticmethod
  @overload
  def copyOf(arg0: list[float], arg1: int) -> list[float]: ...

  @staticmethod
  @overload
  def copyOf(arg0: list[float], arg1: int) -> list[float]: ...

  @staticmethod
  @overload
  def copyOf(arg0: list[int], arg1: int) -> list[int]: ...

  @staticmethod
  @overload
  def copyOf(arg0: list[int], arg1: int) -> list[int]: ...

  @staticmethod
  @overload
  def copyOf(arg0: list[object], arg1: int) -> list[object]: ...

  @staticmethod
  @overload
  def copyOf(arg0: list[int], arg1: int) -> list[int]: ...

  @staticmethod
  @overload
  def copyOf(arg0: list[bool], arg1: int) -> list[bool]: ...

  @staticmethod
  @overload
  def copyOf(arg0: list[object], arg1: int, arg2: Class[T]) -> list[object]: ...

  @staticmethod
  @overload
  def copyOfRange(arg0: list[int], arg1: int, arg2: int) -> list[int]: ...

  @staticmethod
  @overload
  def copyOfRange(arg0: list[str], arg1: int, arg2: int) -> list[str]: ...

  @staticmethod
  @overload
  def copyOfRange(arg0: list[float], arg1: int, arg2: int) -> list[float]: ...

  @staticmethod
  @overload
  def copyOfRange(arg0: list[float], arg1: int, arg2: int) -> list[float]: ...

  @staticmethod
  @overload
  def copyOfRange(arg0: list[int], arg1: int, arg2: int) -> list[int]: ...

  @staticmethod
  @overload
  def copyOfRange(arg0: list[int], arg1: int, arg2: int) -> list[int]: ...

  @staticmethod
  @overload
  def copyOfRange(arg0: list[object], arg1: int, arg2: int) -> list[object]: ...

  @staticmethod
  @overload
  def copyOfRange(arg0: list[int], arg1: int, arg2: int) -> list[int]: ...

  @staticmethod
  @overload
  def copyOfRange(arg0: list[bool], arg1: int, arg2: int) -> list[bool]: ...

  @staticmethod
  @overload
  def copyOfRange(arg0: list[object], arg1: int, arg2: int, arg3: Class[T]) -> list[object]: ...

  @staticmethod
  def deepEquals(arg0: list[object], arg1: list[object]) -> bool: ...

  @staticmethod
  def deepHashCode(arg0: list[object]) -> int: ...

  @staticmethod
  def deepToString(arg0: list[object]) -> str: ...

  @staticmethod
  @overload
  def equals(arg0: list[int], arg1: list[int]) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[str], arg1: list[str]) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[float], arg1: list[float]) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[float], arg1: list[float]) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[int], arg1: list[int]) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[int], arg1: list[int]) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[object], arg1: list[object]) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[int], arg1: list[int]) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[bool], arg1: list[bool]) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[object], arg1: list[object], arg2: Comparator[T]) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[str], arg1: int, arg2: int, arg3: list[str], arg4: int, arg5: int) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[float], arg1: int, arg2: int, arg3: list[float], arg4: int, arg5: int) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[float], arg1: int, arg2: int, arg3: list[float], arg4: int, arg5: int) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[object], arg1: int, arg2: int, arg3: list[object], arg4: int, arg5: int) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[bool], arg1: int, arg2: int, arg3: list[bool], arg4: int, arg5: int) -> bool: ...

  @staticmethod
  @overload
  def equals(arg0: list[object], arg1: int, arg2: int, arg3: list[object], arg4: int, arg5: int, arg6: Comparator[T]) -> bool: ...

  @staticmethod
  @overload
  def fill(arg0: list[int], arg1: int) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[str], arg1: str) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[float], arg1: float) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[float], arg1: float) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[int], arg1: int) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[int], arg1: int) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[object], arg1: object) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[int], arg1: int) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[bool], arg1: bool) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[int], arg1: int, arg2: int, arg3: int) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[str], arg1: int, arg2: int, arg3: str) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[float], arg1: int, arg2: int, arg3: float) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[float], arg1: int, arg2: int, arg3: float) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[int], arg1: int, arg2: int, arg3: int) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[int], arg1: int, arg2: int, arg3: int) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[object], arg1: int, arg2: int, arg3: object) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[int], arg1: int, arg2: int, arg3: int) -> None: ...

  @staticmethod
  @overload
  def fill(arg0: list[bool], arg1: int, arg2: int, arg3: bool) -> None: ...

  @staticmethod
  @overload
  def hashCode(arg0: list[int]) -> int: ...

  @staticmethod
  @overload
  def hashCode(arg0: list[str]) -> int: ...

  @staticmethod
  @overload
  def hashCode(arg0: list[float]) -> int: ...

  @staticmethod
  @overload
  def hashCode(arg0: list[float]) -> int: ...

  @staticmethod
  @overload
  def hashCode(arg0: list[int]) -> int: ...

  @staticmethod
  @overload
  def hashCode(arg0: list[int]) -> int: ...

  @staticmethod
  @overload
  def hashCode(arg0: list[object]) -> int: ...

  @staticmethod
  @overload
  def hashCode(arg0: list[int]) -> int: ...

  @staticmethod
  @overload
  def hashCode(arg0: list[bool]) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[str], arg1: list[str]) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[float], arg1: list[float]) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[float], arg1: list[float]) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[object], arg1: list[object]) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[int], arg1: list[int]) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[bool], arg1: list[bool]) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[object], arg1: list[object], arg2: Comparator[T]) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[str], arg1: int, arg2: int, arg3: list[str], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[float], arg1: int, arg2: int, arg3: list[float], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[float], arg1: int, arg2: int, arg3: list[float], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[object], arg1: int, arg2: int, arg3: list[object], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[int], arg1: int, arg2: int, arg3: list[int], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[bool], arg1: int, arg2: int, arg3: list[bool], arg4: int, arg5: int) -> int: ...

  @staticmethod
  @overload
  def mismatch(arg0: list[object], arg1: int, arg2: int, arg3: list[object], arg4: int, arg5: int, arg6: Comparator[T]) -> int: ...

  @staticmethod
  @overload
  def parallelPrefix(arg0: list[float], arg1: DoubleBinaryOperator) -> None: ...

  @staticmethod
  @overload
  def parallelPrefix(arg0: list[int], arg1: IntBinaryOperator) -> None: ...

  @staticmethod
  @overload
  def parallelPrefix(arg0: list[int], arg1: LongBinaryOperator) -> None: ...

  @staticmethod
  @overload
  def parallelPrefix(arg0: list[object], arg1: BinaryOperator[T]) -> None: ...

  @staticmethod
  @overload
  def parallelPrefix(arg0: list[float], arg1: int, arg2: int, arg3: DoubleBinaryOperator) -> None: ...

  @staticmethod
  @overload
  def parallelPrefix(arg0: list[int], arg1: int, arg2: int, arg3: IntBinaryOperator) -> None: ...

  @staticmethod
  @overload
  def parallelPrefix(arg0: list[int], arg1: int, arg2: int, arg3: LongBinaryOperator) -> None: ...

  @staticmethod
  @overload
  def parallelPrefix(arg0: list[object], arg1: int, arg2: int, arg3: BinaryOperator[T]) -> None: ...

  @staticmethod
  @overload
  def parallelSetAll(arg0: list[float], arg1: IntToDoubleFunction) -> None: ...

  @staticmethod
  @overload
  def parallelSetAll(arg0: list[int], arg1: IntUnaryOperator) -> None: ...

  @staticmethod
  @overload
  def parallelSetAll(arg0: list[int], arg1: IntToLongFunction) -> None: ...

  @staticmethod
  @overload
  def parallelSetAll(arg0: list[object], arg1: IntFunction[T]) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[int]) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[str]) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[float]) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[float]) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[int]) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[int]) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[Comparable]) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[int]) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[object], arg1: Comparator[T]) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[int], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[str], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[float], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[float], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[int], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[int], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[Comparable], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[int], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def parallelSort(arg0: list[object], arg1: int, arg2: int, arg3: Comparator[T]) -> None: ...

  @staticmethod
  @overload
  def setAll(arg0: list[float], arg1: IntToDoubleFunction) -> None: ...

  @staticmethod
  @overload
  def setAll(arg0: list[int], arg1: IntUnaryOperator) -> None: ...

  @staticmethod
  @overload
  def setAll(arg0: list[int], arg1: IntToLongFunction) -> None: ...

  @staticmethod
  @overload
  def setAll(arg0: list[object], arg1: IntFunction[T]) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[int]) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[str]) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[float]) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[float]) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[int]) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[int]) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[object]) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[int]) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[object], arg1: Comparator[T]) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[int], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[str], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[float], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[float], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[int], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[int], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[object], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[int], arg1: int, arg2: int) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: list[object], arg1: int, arg2: int, arg3: Comparator[T]) -> None: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[float]) -> Spliterator.OfDouble: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[int]) -> Spliterator.OfInt: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[int]) -> Spliterator.OfLong: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[object]) -> Spliterator[T]: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[float], arg1: int, arg2: int) -> Spliterator.OfDouble: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[int], arg1: int, arg2: int) -> Spliterator.OfInt: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[int], arg1: int, arg2: int) -> Spliterator.OfLong: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[object], arg1: int, arg2: int) -> Spliterator[T]: ...

  @staticmethod
  @overload
  def stream(arg0: list[float]) -> DoubleStream: ...

  @staticmethod
  @overload
  def stream(arg0: list[int]) -> IntStream: ...

  @staticmethod
  @overload
  def stream(arg0: list[int]) -> LongStream: ...

  @staticmethod
  @overload
  def stream(arg0: list[object]) -> Stream[T]: ...

  @staticmethod
  @overload
  def stream(arg0: list[float], arg1: int, arg2: int) -> DoubleStream: ...

  @staticmethod
  @overload
  def stream(arg0: list[int], arg1: int, arg2: int) -> IntStream: ...

  @staticmethod
  @overload
  def stream(arg0: list[int], arg1: int, arg2: int) -> LongStream: ...

  @staticmethod
  @overload
  def stream(arg0: list[object], arg1: int, arg2: int) -> Stream[T]: ...

  @staticmethod
  @overload
  def toString(arg0: list[int]) -> str: ...

  @staticmethod
  @overload
  def toString(arg0: list[str]) -> str: ...

  @staticmethod
  @overload
  def toString(arg0: list[float]) -> str: ...

  @staticmethod
  @overload
  def toString(arg0: list[float]) -> str: ...

  @staticmethod
  @overload
  def toString(arg0: list[int]) -> str: ...

  @staticmethod
  @overload
  def toString(arg0: list[int]) -> str: ...

  @staticmethod
  @overload
  def toString(arg0: list[object]) -> str: ...

  @staticmethod
  @overload
  def toString(arg0: list[int]) -> str: ...

  @staticmethod
  @overload
  def toString(arg0: list[bool]) -> str: ...

  class NaturalOrder:

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    def equals(self, arg0: object) -> bool: ...

    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

  class LegacyMergeSort: ...

  class ArrayList[E](AbstractList):

    def contains(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    def get(self, arg0: int) -> object: ...

    def indexOf(self, arg0: object) -> int: ...

    def iterator(self) -> Iterator[E]: ...

    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    def set(self, arg0: int, arg1: object) -> object: ...

    def size(self) -> int: ...

    def sort(self, arg0: Comparator[E]) -> None: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class ArrayItr[E]:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...


class BitSet:

  def andNot(self, arg0: BitSet) -> None: ...

  def cardinality(self) -> int: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self, arg0: int) -> None: ...

  @overload
  def clear(self, arg0: int, arg1: int) -> None: ...

  def clone(self) -> object: ...

  def equals(self, arg0: object) -> bool: ...

  @overload
  def flip(self, arg0: int) -> None: ...

  @overload
  def flip(self, arg0: int, arg1: int) -> None: ...

  @overload
  def get(self, arg0: int) -> bool: ...

  @overload
  def get(self, arg0: int, arg1: int) -> BitSet: ...

  def hashCode(self) -> int: ...

  def intersects(self, arg0: BitSet) -> bool: ...

  def isEmpty(self) -> bool: ...

  def length(self) -> int: ...

  def nextClearBit(self, arg0: int) -> int: ...

  def nextSetBit(self, arg0: int) -> int: ...

  def previousClearBit(self, arg0: int) -> int: ...

  def previousSetBit(self, arg0: int) -> int: ...

  @overload
  def set(self, arg0: int) -> None: ...

  @overload
  def set(self, arg0: int, arg1: bool) -> None: ...

  @overload
  def set(self, arg0: int, arg1: int) -> None: ...

  @overload
  def set(self, arg0: int, arg1: int, arg2: bool) -> None: ...

  def size(self) -> int: ...

  def stream(self) -> IntStream: ...

  def toByteArray(self) -> list[int]: ...

  def toLongArray(self) -> list[int]: ...

  def toString(self) -> str: ...

  def xor(self, arg0: BitSet) -> None: ...

  @staticmethod
  @overload
  def valueOf(arg0: list[int]) -> BitSet: ...

  @staticmethod
  @overload
  def valueOf(arg0: list[int]) -> BitSet: ...

  @staticmethod
  @overload
  def valueOf(arg0: ByteBuffer) -> BitSet: ...

  @staticmethod
  @overload
  def valueOf(arg0: LongBuffer) -> BitSet: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...


class Calendar:

  ALL_STYLES: int

  AM: int

  AM_PM: int

  APRIL: int

  AUGUST: int

  DATE: int

  DAY_OF_MONTH: int

  DAY_OF_WEEK: int

  DAY_OF_WEEK_IN_MONTH: int

  DAY_OF_YEAR: int

  DECEMBER: int

  DST_OFFSET: int

  ERA: int

  FEBRUARY: int

  FIELD_COUNT: int

  FRIDAY: int

  HOUR: int

  HOUR_OF_DAY: int

  JANUARY: int

  JULY: int

  JUNE: int

  LONG: int

  LONG_FORMAT: int

  LONG_STANDALONE: int

  MARCH: int

  MAY: int

  MILLISECOND: int

  MINUTE: int

  MONDAY: int

  MONTH: int

  NARROW_FORMAT: int

  NARROW_STANDALONE: int

  NOVEMBER: int

  OCTOBER: int

  PM: int

  SATURDAY: int

  SECOND: int

  SEPTEMBER: int

  SHORT: int

  SHORT_FORMAT: int

  SHORT_STANDALONE: int

  SUNDAY: int

  THURSDAY: int

  TUESDAY: int

  UNDECIMBER: int

  WEDNESDAY: int

  WEEK_OF_MONTH: int

  WEEK_OF_YEAR: int

  YEAR: int

  ZONE_OFFSET: int

  def add(self, arg0: int, arg1: int) -> None: ...

  def after(self, arg0: object) -> bool: ...

  def before(self, arg0: object) -> bool: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self, arg0: int) -> None: ...

  def clone(self) -> object: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: Calendar) -> int: ...

  def equals(self, arg0: object) -> bool: ...

  def get(self, arg0: int) -> int: ...

  def getActualMaximum(self, arg0: int) -> int: ...

  def getActualMinimum(self, arg0: int) -> int: ...

  def getCalendarType(self) -> str: ...

  def getDisplayName(self, arg0: int, arg1: int, arg2: Locale) -> str: ...

  def getDisplayNames(self, arg0: int, arg1: int, arg2: Locale) -> Map[str, Integer]: ...

  def getFirstDayOfWeek(self) -> int: ...

  def getGreatestMinimum(self, arg0: int) -> int: ...

  def getLeastMaximum(self, arg0: int) -> int: ...

  def getMaximum(self, arg0: int) -> int: ...

  def getMinimalDaysInFirstWeek(self) -> int: ...

  def getMinimum(self, arg0: int) -> int: ...

  def getTime(self) -> Date: ...

  def getTimeInMillis(self) -> int: ...

  def getTimeZone(self) -> TimeZone: ...

  def getWeekYear(self) -> int: ...

  def getWeeksInWeekYear(self) -> int: ...

  def hashCode(self) -> int: ...

  def isLenient(self) -> bool: ...

  def isSet(self, arg0: int) -> bool: ...

  def isWeekDateSupported(self) -> bool: ...

  @overload
  def roll(self, arg0: int, arg1: bool) -> None: ...

  @overload
  def roll(self, arg0: int, arg1: int) -> None: ...

  @overload
  def set(self, arg0: int, arg1: int) -> None: ...

  @overload
  def set(self, arg0: int, arg1: int, arg2: int) -> None: ...

  @overload
  def set(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int) -> None: ...

  @overload
  def set(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int) -> None: ...

  def setFirstDayOfWeek(self, arg0: int) -> None: ...

  def setLenient(self, arg0: bool) -> None: ...

  def setMinimalDaysInFirstWeek(self, arg0: int) -> None: ...

  def setTime(self, arg0: Date) -> None: ...

  def setTimeInMillis(self, arg0: int) -> None: ...

  def setTimeZone(self, arg0: TimeZone) -> None: ...

  def setWeekDate(self, arg0: int, arg1: int, arg2: int) -> None: ...

  def toInstant(self) -> Instant: ...

  def toString(self) -> str: ...

  @staticmethod
  def getAvailableCalendarTypes() -> Set[str]: ...

  @staticmethod
  def getAvailableLocales() -> list[Locale]: ...

  @staticmethod
  @overload
  def getInstance() -> Calendar: ...

  @staticmethod
  @overload
  def getInstance(arg0: Locale) -> Calendar: ...

  @staticmethod
  @overload
  def getInstance(arg0: TimeZone) -> Calendar: ...

  @staticmethod
  @overload
  def getInstance(arg0: TimeZone, arg1: Locale) -> Calendar: ...

  class AvailableCalendarTypes: ...

  class CalendarAccessControlContext: ...

  class Builder:

    def build(self) -> Calendar: ...

    def set(self, arg0: int, arg1: int) -> Calendar.Builder: ...

    def setCalendarType(self, arg0: str) -> Calendar.Builder: ...

    def setDate(self, arg0: int, arg1: int, arg2: int) -> Calendar.Builder: ...

    def setFields(self, arg0: list[int]) -> Calendar.Builder: ...

    @overload
    def setInstant(self, arg0: Date) -> Calendar.Builder: ...

    @overload
    def setInstant(self, arg0: int) -> Calendar.Builder: ...

    def setLenient(self, arg0: bool) -> Calendar.Builder: ...

    def setLocale(self, arg0: Locale) -> Calendar.Builder: ...

    @overload
    def setTimeOfDay(self, arg0: int, arg1: int, arg2: int) -> Calendar.Builder: ...

    @overload
    def setTimeOfDay(self, arg0: int, arg1: int, arg2: int, arg3: int) -> Calendar.Builder: ...

    def setTimeZone(self, arg0: TimeZone) -> Calendar.Builder: ...

    def setWeekDate(self, arg0: int, arg1: int, arg2: int) -> Calendar.Builder: ...

    def setWeekDefinition(self, arg0: int, arg1: int) -> Calendar.Builder: ...

    def __init__(self): ...


class Collection[E]:

  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  def clear(self) -> None: ...

  def contains(self, arg0: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def forEach(self, arg0: Consumer[T]) -> None: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[T]: ...

  def parallelStream(self) -> Stream[E]: ...

  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  def size(self) -> int: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def spliterator(self) -> Spliterator[T]: ...

  def stream(self) -> Stream[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: IntFunction[T]) -> list[object]: ...


class Collections:

  EMPTY_LIST: List

  EMPTY_MAP: Map

  EMPTY_SET: Set

  @staticmethod
  def addAll(arg0: Collection[T], arg1: list[object]) -> bool: ...

  @staticmethod
  def asLifoQueue(arg0: Deque[T]) -> Queue[T]: ...

  @staticmethod
  @overload
  def binarySearch(arg0: List[Comparable[T]], arg1: object) -> int: ...

  @staticmethod
  @overload
  def binarySearch(arg0: List[T], arg1: object, arg2: Comparator[T]) -> int: ...

  @staticmethod
  def checkedCollection(arg0: Collection[E], arg1: Class[E]) -> Collection[E]: ...

  @staticmethod
  def checkedList(arg0: List[E], arg1: Class[E]) -> List[E]: ...

  @staticmethod
  def checkedMap(arg0: Map[K, V], arg1: Class[K], arg2: Class[V]) -> Map[K, V]: ...

  @staticmethod
  def checkedNavigableMap(arg0: NavigableMap[K, V], arg1: Class[K], arg2: Class[V]) -> NavigableMap[K, V]: ...

  @staticmethod
  def checkedNavigableSet(arg0: NavigableSet[E], arg1: Class[E]) -> NavigableSet[E]: ...

  @staticmethod
  def checkedQueue(arg0: Queue[E], arg1: Class[E]) -> Queue[E]: ...

  @staticmethod
  def checkedSet(arg0: Set[E], arg1: Class[E]) -> Set[E]: ...

  @staticmethod
  def checkedSortedMap(arg0: SortedMap[K, V], arg1: Class[K], arg2: Class[V]) -> SortedMap[K, V]: ...

  @staticmethod
  def checkedSortedSet(arg0: SortedSet[E], arg1: Class[E]) -> SortedSet[E]: ...

  @staticmethod
  def copy(arg0: List[T], arg1: List[T]) -> None: ...

  @staticmethod
  def disjoint(arg0: Collection[Any], arg1: Collection[Any]) -> bool: ...

  @staticmethod
  def emptyEnumeration() -> Enumeration[T]: ...

  @staticmethod
  def emptyIterator() -> Iterator[T]: ...

  @staticmethod
  def emptyList() -> List[T]: ...

  @staticmethod
  def emptyListIterator() -> ListIterator[T]: ...

  @staticmethod
  def emptyMap() -> Map[K, V]: ...

  @staticmethod
  def emptyNavigableMap() -> NavigableMap[K, V]: ...

  @staticmethod
  def emptyNavigableSet() -> NavigableSet[E]: ...

  @staticmethod
  def emptySet() -> Set[T]: ...

  @staticmethod
  def emptySortedMap() -> SortedMap[K, V]: ...

  @staticmethod
  def emptySortedSet() -> SortedSet[E]: ...

  @staticmethod
  def enumeration(arg0: Collection[T]) -> Enumeration[T]: ...

  @staticmethod
  def fill(arg0: List[T], arg1: object) -> None: ...

  @staticmethod
  def frequency(arg0: Collection[Any], arg1: object) -> int: ...

  @staticmethod
  def indexOfSubList(arg0: List[Any], arg1: List[Any]) -> int: ...

  @staticmethod
  def lastIndexOfSubList(arg0: List[Any], arg1: List[Any]) -> int: ...

  @staticmethod
  def list(arg0: Enumeration[T]) -> ArrayList[T]: ...

  @staticmethod
  @overload
  def max(arg0: Collection[T]) -> object: ...

  @staticmethod
  @overload
  def max(arg0: Collection[T], arg1: Comparator[T]) -> object: ...

  @staticmethod
  @overload
  def min(arg0: Collection[T]) -> object: ...

  @staticmethod
  @overload
  def min(arg0: Collection[T], arg1: Comparator[T]) -> object: ...

  @staticmethod
  def nCopies(arg0: int, arg1: object) -> List[T]: ...

  @staticmethod
  def newSetFromMap(arg0: Map[E, Boolean]) -> Set[E]: ...

  @staticmethod
  def replaceAll(arg0: List[T], arg1: object, arg2: object) -> bool: ...

  @staticmethod
  def reverse(arg0: List[Any]) -> None: ...

  @staticmethod
  @overload
  def reverseOrder() -> Comparator[T]: ...

  @staticmethod
  @overload
  def reverseOrder(arg0: Comparator[T]) -> Comparator[T]: ...

  @staticmethod
  def rotate(arg0: List[Any], arg1: int) -> None: ...

  @staticmethod
  @overload
  def shuffle(arg0: List[Any]) -> None: ...

  @staticmethod
  @overload
  def shuffle(arg0: List[Any], arg1: Random) -> None: ...

  @staticmethod
  def singleton(arg0: object) -> Set[T]: ...

  @staticmethod
  def singletonList(arg0: object) -> List[T]: ...

  @staticmethod
  def singletonMap(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def sort(arg0: List[T]) -> None: ...

  @staticmethod
  @overload
  def sort(arg0: List[T], arg1: Comparator[T]) -> None: ...

  @staticmethod
  def swap(arg0: List[Any], arg1: int, arg2: int) -> None: ...

  @staticmethod
  def synchronizedCollection(arg0: Collection[T]) -> Collection[T]: ...

  @staticmethod
  def synchronizedList(arg0: List[T]) -> List[T]: ...

  @staticmethod
  def synchronizedMap(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def synchronizedNavigableMap(arg0: NavigableMap[K, V]) -> NavigableMap[K, V]: ...

  @staticmethod
  def synchronizedNavigableSet(arg0: NavigableSet[T]) -> NavigableSet[T]: ...

  @staticmethod
  def synchronizedSet(arg0: Set[T]) -> Set[T]: ...

  @staticmethod
  def synchronizedSortedMap(arg0: SortedMap[K, V]) -> SortedMap[K, V]: ...

  @staticmethod
  def synchronizedSortedSet(arg0: SortedSet[T]) -> SortedSet[T]: ...

  @staticmethod
  def unmodifiableCollection(arg0: Collection[T]) -> Collection[T]: ...

  @staticmethod
  def unmodifiableList(arg0: List[T]) -> List[T]: ...

  @staticmethod
  def unmodifiableMap(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def unmodifiableNavigableMap(arg0: NavigableMap[K, V]) -> NavigableMap[K, V]: ...

  @staticmethod
  def unmodifiableNavigableSet(arg0: NavigableSet[T]) -> NavigableSet[T]: ...

  @staticmethod
  def unmodifiableSet(arg0: Set[T]) -> Set[T]: ...

  @staticmethod
  def unmodifiableSortedMap(arg0: SortedMap[K, V]) -> SortedMap[K, V]: ...

  @staticmethod
  def unmodifiableSortedSet(arg0: SortedSet[T]) -> SortedSet[T]: ...

  class UnmodifiableCollection[E]:

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    def hashCode(self) -> int: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def parallelStream(self) -> Stream[E]: ...

    @overload
    def parallelStream(self) -> Stream[E]: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    @overload
    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def size(self) -> int: ...

    @overload
    def size(self) -> int: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def stream(self) -> Stream[E]: ...

    @overload
    def stream(self) -> Stream[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

    def toString(self) -> str: ...

  class UnmodifiableSet[E](Collections.UnmodifiableCollection):

    def add(self, arg0: object) -> bool: ...

    def addAll(self, arg0: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> Set[E]: ...

    @staticmethod
    @overload
    def of() -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...

  class UnmodifiableSortedSet[E](Collections.UnmodifiableSet):

    @overload
    def comparator(self) -> Comparator[E]: ...

    @overload
    def comparator(self) -> Comparator[E]: ...

    @overload
    def first(self) -> object: ...

    @overload
    def first(self) -> object: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def last(self) -> object: ...

    @overload
    def last(self) -> object: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet[E]: ...

  class UnmodifiableNavigableSet[E](Collections.UnmodifiableSortedSet):

    @overload
    def ceiling(self, arg0: object) -> object: ...

    @overload
    def ceiling(self, arg0: object) -> object: ...

    @overload
    def descendingIterator(self) -> Iterator[E]: ...

    @overload
    def descendingIterator(self) -> Iterator[E]: ...

    @overload
    def descendingSet(self) -> NavigableSet[E]: ...

    @overload
    def descendingSet(self) -> NavigableSet[E]: ...

    @overload
    def floor(self, arg0: object) -> object: ...

    @overload
    def floor(self, arg0: object) -> object: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def headSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def headSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def higher(self, arg0: object) -> object: ...

    @overload
    def higher(self, arg0: object) -> object: ...

    def iterator(self) -> Iterator[E]: ...

    @overload
    def lower(self, arg0: object) -> object: ...

    @overload
    def lower(self, arg0: object) -> object: ...

    @overload
    def pollFirst(self) -> object: ...

    @overload
    def pollFirst(self) -> object: ...

    @overload
    def pollLast(self) -> object: ...

    @overload
    def pollLast(self) -> object: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def tailSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def tailSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    class EmptyNavigableSet[EmptyNavigableSet_E](Collections.UnmodifiableNavigableSet):

      def __init__(self): ...

  class UnmodifiableList[E](Collections.UnmodifiableCollection):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def get(self, arg0: int) -> object: ...

    @overload
    def get(self, arg0: int) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def indexOf(self, arg0: object) -> int: ...

    @overload
    def indexOf(self, arg0: object) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    @overload
    def lastIndexOf(self, arg0: object) -> int: ...

    @overload
    def lastIndexOf(self, arg0: object) -> int: ...

    @overload
    def listIterator(self) -> ListIterator[E]: ...

    @overload
    def listIterator(self) -> ListIterator[E]: ...

    @overload
    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    @overload
    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    @overload
    def remove(self, arg0: int) -> object: ...

    @overload
    def remove(self, arg0: int) -> object: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    @overload
    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def set(self, arg0: int, arg1: object) -> object: ...

    @overload
    def set(self, arg0: int, arg1: object) -> object: ...

    def size(self) -> int: ...

    @overload
    def sort(self, arg0: Comparator[E]) -> None: ...

    @overload
    def sort(self, arg0: Comparator[E]) -> None: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> List[E]: ...

    @staticmethod
    @overload
    def of() -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...

  class UnmodifiableRandomAccessList[E](Collections.UnmodifiableList):

    def subList(self, arg0: int, arg1: int) -> List[E]: ...

  class UnmodifiableMap[K, V]:

    @overload
    def clear(self) -> None: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

    @overload
    def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

    @overload
    def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def containsKey(self, arg0: object) -> bool: ...

    @overload
    def containsKey(self, arg0: object) -> bool: ...

    @overload
    def containsValue(self, arg0: object) -> bool: ...

    @overload
    def containsValue(self, arg0: object) -> bool: ...

    @overload
    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    @overload
    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

    @overload
    def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

    @overload
    def get(self, arg0: object) -> object: ...

    @overload
    def get(self, arg0: object) -> object: ...

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object: ...

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def keySet(self) -> Set[K]: ...

    @overload
    def keySet(self) -> Set[K]: ...

    @overload
    def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

    @overload
    def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

    @overload
    def put(self, arg0: object, arg1: object) -> object: ...

    @overload
    def put(self, arg0: object, arg1: object) -> object: ...

    @overload
    def putAll(self, arg0: Map[K, V]) -> None: ...

    @overload
    def putAll(self, arg0: Map[K, V]) -> None: ...

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

    @overload
    def remove(self, arg0: object) -> object: ...

    @overload
    def remove(self, arg0: object) -> object: ...

    @overload
    def remove(self, arg0: object, arg1: object) -> bool: ...

    @overload
    def remove(self, arg0: object, arg1: object) -> bool: ...

    @overload
    def replace(self, arg0: object, arg1: object) -> object: ...

    @overload
    def replace(self, arg0: object, arg1: object) -> object: ...

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

    @overload
    def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

    @overload
    def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

    @overload
    def size(self) -> int: ...

    @overload
    def size(self) -> int: ...

    def toString(self) -> str: ...

    @overload
    def values(self) -> Collection[V]: ...

    @overload
    def values(self) -> Collection[V]: ...

    @staticmethod
    def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

    @staticmethod
    def entry(arg0: object, arg1: object) -> Map.Entry: ...

    @staticmethod
    @overload
    def of() -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

    @staticmethod
    def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

    class UnmodifiableEntrySet[UnmodifiableEntrySet_K, UnmodifiableEntrySet_V](Collections.UnmodifiableSet):

      def contains(self, arg0: object) -> bool: ...

      def containsAll(self, arg0: Collection[Any]) -> bool: ...

      def equals(self, arg0: object) -> bool: ...

      def forEach(self, arg0: Consumer[Map.Entry[K, V]]) -> None: ...

      def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

      def parallelStream(self) -> Stream[Map.Entry[K, V]]: ...

      def spliterator(self) -> Spliterator[Map.Entry[K, V]]: ...

      def stream(self) -> Stream[Map.Entry[K, V]]: ...

      @overload
      def toArray(self) -> list[object]: ...

      @overload
      def toArray(self, arg0: list[object]) -> list[object]: ...

      class UnmodifiableEntrySetSpliterator[UnmodifiableEntrySetSpliterator_K, UnmodifiableEntrySetSpliterator_V]:

        CONCURRENT: int

        DISTINCT: int

        IMMUTABLE: int

        NONNULL: int

        ORDERED: int

        SIZED: int

        SORTED: int

        SUBSIZED: int

        @overload
        def characteristics(self) -> int: ...

        @overload
        def characteristics(self) -> int: ...

        @overload
        def estimateSize(self) -> int: ...

        @overload
        def estimateSize(self) -> int: ...

        @overload
        def forEachRemaining(self, arg0: Consumer[Map.Entry[K, V]]) -> None: ...

        @overload
        def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

        @overload
        def getComparator(self) -> Comparator[Map.Entry[K, V]]: ...

        @overload
        def getComparator(self) -> Comparator[T]: ...

        @overload
        def getExactSizeIfKnown(self) -> int: ...

        @overload
        def getExactSizeIfKnown(self) -> int: ...

        @overload
        def hasCharacteristics(self, arg0: int) -> bool: ...

        @overload
        def hasCharacteristics(self, arg0: int) -> bool: ...

        @overload
        def tryAdvance(self, arg0: Consumer[Map.Entry[K, V]]) -> bool: ...

        @overload
        def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

        @overload
        def trySplit(self) -> Spliterator[Map.Entry[K, V]]: ...

        @overload
        def trySplit(self) -> Spliterator[T]: ...

      class UnmodifiableEntry[UnmodifiableEntry_K, UnmodifiableEntry_V]:

        @overload
        def equals(self, arg0: object) -> bool: ...

        @overload
        def equals(self, arg0: object) -> bool: ...

        @overload
        def getKey(self) -> object: ...

        @overload
        def getKey(self) -> object: ...

        @overload
        def getValue(self) -> object: ...

        @overload
        def getValue(self) -> object: ...

        @overload
        def hashCode(self) -> int: ...

        @overload
        def hashCode(self) -> int: ...

        @overload
        def setValue(self, arg0: object) -> object: ...

        @overload
        def setValue(self, arg0: object) -> object: ...

        def toString(self) -> str: ...

        @staticmethod
        @overload
        def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

        @staticmethod
        @overload
        def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

        @staticmethod
        @overload
        def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

        @staticmethod
        @overload
        def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

        @staticmethod
        def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  class UnmodifiableSortedMap[K, V](Collections.UnmodifiableMap):

    @overload
    def comparator(self) -> Comparator[K]: ...

    @overload
    def comparator(self) -> Comparator[K]: ...

    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    @overload
    def firstKey(self) -> object: ...

    @overload
    def firstKey(self) -> object: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    def keySet(self) -> Set[K]: ...

    @overload
    def lastKey(self) -> object: ...

    @overload
    def lastKey(self) -> object: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    def values(self) -> Collection[V]: ...

  class UnmodifiableNavigableMap[K, V](Collections.UnmodifiableSortedMap):

    @overload
    def ceilingEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def ceilingEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def ceilingKey(self, arg0: object) -> object: ...

    @overload
    def ceilingKey(self, arg0: object) -> object: ...

    @overload
    def descendingKeySet(self) -> NavigableSet[K]: ...

    @overload
    def descendingKeySet(self) -> NavigableSet[K]: ...

    @overload
    def descendingMap(self) -> NavigableMap[K, V]: ...

    @overload
    def descendingMap(self) -> NavigableMap[K, V]: ...

    @overload
    def firstEntry(self) -> Map.Entry: ...

    @overload
    def firstEntry(self) -> Map.Entry: ...

    @overload
    def floorEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def floorEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def floorKey(self, arg0: object) -> object: ...

    @overload
    def floorKey(self, arg0: object) -> object: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    @overload
    def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    @overload
    def higherEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def higherEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def higherKey(self, arg0: object) -> object: ...

    @overload
    def higherKey(self, arg0: object) -> object: ...

    @overload
    def lastEntry(self) -> Map.Entry: ...

    @overload
    def lastEntry(self) -> Map.Entry: ...

    @overload
    def lowerEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def lowerEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def lowerKey(self, arg0: object) -> object: ...

    @overload
    def lowerKey(self, arg0: object) -> object: ...

    @overload
    def navigableKeySet(self) -> NavigableSet[K]: ...

    @overload
    def navigableKeySet(self) -> NavigableSet[K]: ...

    @overload
    def pollFirstEntry(self) -> Map.Entry: ...

    @overload
    def pollFirstEntry(self) -> Map.Entry: ...

    @overload
    def pollLastEntry(self) -> Map.Entry: ...

    @overload
    def pollLastEntry(self) -> Map.Entry: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    class EmptyNavigableMap[EmptyNavigableMap_K, EmptyNavigableMap_V](Collections.UnmodifiableNavigableMap):

      def navigableKeySet(self) -> NavigableSet[K]: ...

  class SynchronizedCollection[E]:

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    def hashCode(self) -> int: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def parallelStream(self) -> Stream[E]: ...

    @overload
    def parallelStream(self) -> Stream[E]: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    @overload
    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def size(self) -> int: ...

    @overload
    def size(self) -> int: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def stream(self) -> Stream[E]: ...

    @overload
    def stream(self) -> Stream[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

    def toString(self) -> str: ...

  class SynchronizedSet[E](Collections.SynchronizedCollection):

    def add(self, arg0: object) -> bool: ...

    def addAll(self, arg0: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> Set[E]: ...

    @staticmethod
    @overload
    def of() -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...

  class SynchronizedSortedSet[E](Collections.SynchronizedSet):

    @overload
    def comparator(self) -> Comparator[E]: ...

    @overload
    def comparator(self) -> Comparator[E]: ...

    @overload
    def first(self) -> object: ...

    @overload
    def first(self) -> object: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def last(self) -> object: ...

    @overload
    def last(self) -> object: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet[E]: ...

  class SynchronizedNavigableSet[E](Collections.SynchronizedSortedSet):

    @overload
    def ceiling(self, arg0: object) -> object: ...

    @overload
    def ceiling(self, arg0: object) -> object: ...

    @overload
    def descendingIterator(self) -> Iterator[E]: ...

    @overload
    def descendingIterator(self) -> Iterator[E]: ...

    @overload
    def descendingSet(self) -> NavigableSet[E]: ...

    @overload
    def descendingSet(self) -> NavigableSet[E]: ...

    @overload
    def floor(self, arg0: object) -> object: ...

    @overload
    def floor(self, arg0: object) -> object: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet: ...

    @overload
    def headSet(self, arg0: object) -> NavigableSet[E]: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def headSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def headSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def higher(self, arg0: object) -> object: ...

    @overload
    def higher(self, arg0: object) -> object: ...

    def iterator(self) -> Iterator[E]: ...

    @overload
    def lower(self, arg0: object) -> object: ...

    @overload
    def lower(self, arg0: object) -> object: ...

    @overload
    def pollFirst(self) -> object: ...

    @overload
    def pollFirst(self) -> object: ...

    @overload
    def pollLast(self) -> object: ...

    @overload
    def pollLast(self) -> object: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> NavigableSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> NavigableSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def tailSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def tailSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

  class SynchronizedRandomAccessList[E](Collections.SynchronizedList):

    def subList(self, arg0: int, arg1: int) -> List[E]: ...

  class SynchronizedList[E](Collections.SynchronizedCollection):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def get(self, arg0: int) -> object: ...

    @overload
    def get(self, arg0: int) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def indexOf(self, arg0: object) -> int: ...

    @overload
    def indexOf(self, arg0: object) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    @overload
    def lastIndexOf(self, arg0: object) -> int: ...

    @overload
    def lastIndexOf(self, arg0: object) -> int: ...

    @overload
    def listIterator(self) -> ListIterator[E]: ...

    @overload
    def listIterator(self) -> ListIterator[E]: ...

    @overload
    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    @overload
    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    @overload
    def remove(self, arg0: int) -> object: ...

    @overload
    def remove(self, arg0: int) -> object: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    @overload
    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def set(self, arg0: int, arg1: object) -> object: ...

    @overload
    def set(self, arg0: int, arg1: object) -> object: ...

    def size(self) -> int: ...

    @overload
    def sort(self, arg0: Comparator[E]) -> None: ...

    @overload
    def sort(self, arg0: Comparator[E]) -> None: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> List[E]: ...

    @staticmethod
    @overload
    def of() -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...

  class SynchronizedMap[K, V]:

    @overload
    def clear(self) -> None: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

    @overload
    def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

    @overload
    def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def containsKey(self, arg0: object) -> bool: ...

    @overload
    def containsKey(self, arg0: object) -> bool: ...

    @overload
    def containsValue(self, arg0: object) -> bool: ...

    @overload
    def containsValue(self, arg0: object) -> bool: ...

    @overload
    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    @overload
    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

    @overload
    def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

    @overload
    def get(self, arg0: object) -> object: ...

    @overload
    def get(self, arg0: object) -> object: ...

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object: ...

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def keySet(self) -> Set[K]: ...

    @overload
    def keySet(self) -> Set[K]: ...

    @overload
    def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

    @overload
    def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

    @overload
    def put(self, arg0: object, arg1: object) -> object: ...

    @overload
    def put(self, arg0: object, arg1: object) -> object: ...

    @overload
    def putAll(self, arg0: Map[K, V]) -> None: ...

    @overload
    def putAll(self, arg0: Map[K, V]) -> None: ...

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

    @overload
    def remove(self, arg0: object) -> object: ...

    @overload
    def remove(self, arg0: object) -> object: ...

    @overload
    def remove(self, arg0: object, arg1: object) -> bool: ...

    @overload
    def remove(self, arg0: object, arg1: object) -> bool: ...

    @overload
    def replace(self, arg0: object, arg1: object) -> object: ...

    @overload
    def replace(self, arg0: object, arg1: object) -> object: ...

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

    @overload
    def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

    @overload
    def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

    @overload
    def size(self) -> int: ...

    @overload
    def size(self) -> int: ...

    def toString(self) -> str: ...

    @overload
    def values(self) -> Collection[V]: ...

    @overload
    def values(self) -> Collection[V]: ...

    @staticmethod
    def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

    @staticmethod
    def entry(arg0: object, arg1: object) -> Map.Entry: ...

    @staticmethod
    @overload
    def of() -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

    @staticmethod
    def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

  class SynchronizedSortedMap[K, V](Collections.SynchronizedMap):

    @overload
    def comparator(self) -> Comparator[K]: ...

    @overload
    def comparator(self) -> Comparator[K]: ...

    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    @overload
    def firstKey(self) -> object: ...

    @overload
    def firstKey(self) -> object: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    def keySet(self) -> Set[K]: ...

    @overload
    def lastKey(self) -> object: ...

    @overload
    def lastKey(self) -> object: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    def values(self) -> Collection[V]: ...

  class SynchronizedNavigableMap[K, V](Collections.SynchronizedSortedMap):

    @overload
    def ceilingEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def ceilingEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def ceilingKey(self, arg0: object) -> object: ...

    @overload
    def ceilingKey(self, arg0: object) -> object: ...

    @overload
    def descendingKeySet(self) -> NavigableSet[K]: ...

    @overload
    def descendingKeySet(self) -> NavigableSet[K]: ...

    @overload
    def descendingMap(self) -> NavigableMap[K, V]: ...

    @overload
    def descendingMap(self) -> NavigableMap[K, V]: ...

    @overload
    def firstEntry(self) -> Map.Entry: ...

    @overload
    def firstEntry(self) -> Map.Entry: ...

    @overload
    def floorEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def floorEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def floorKey(self, arg0: object) -> object: ...

    @overload
    def floorKey(self, arg0: object) -> object: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    @overload
    def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    @overload
    def higherEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def higherEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def higherKey(self, arg0: object) -> object: ...

    @overload
    def higherKey(self, arg0: object) -> object: ...

    @overload
    def keySet(self) -> Set: ...

    @overload
    def keySet(self) -> NavigableSet[K]: ...

    @overload
    def lastEntry(self) -> Map.Entry: ...

    @overload
    def lastEntry(self) -> Map.Entry: ...

    @overload
    def lowerEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def lowerEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def lowerKey(self, arg0: object) -> object: ...

    @overload
    def lowerKey(self, arg0: object) -> object: ...

    @overload
    def navigableKeySet(self) -> NavigableSet[K]: ...

    @overload
    def navigableKeySet(self) -> NavigableSet[K]: ...

    @overload
    def pollFirstEntry(self) -> Map.Entry: ...

    @overload
    def pollFirstEntry(self) -> Map.Entry: ...

    @overload
    def pollLastEntry(self) -> Map.Entry: ...

    @overload
    def pollLastEntry(self) -> Map.Entry: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

  class CheckedCollection[E]:

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    def hashCode(self) -> int: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def parallelStream(self) -> Stream[E]: ...

    @overload
    def parallelStream(self) -> Stream[E]: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    @overload
    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def size(self) -> int: ...

    @overload
    def size(self) -> int: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def stream(self) -> Stream[E]: ...

    @overload
    def stream(self) -> Stream[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

    def toString(self) -> str: ...

  class CheckedQueue[E](Collections.CheckedCollection):

    def add(self, arg0: object) -> bool: ...

    @overload
    def element(self) -> object: ...

    @overload
    def element(self) -> object: ...

    def equals(self, arg0: object) -> bool: ...

    def hashCode(self) -> int: ...

    @overload
    def offer(self, arg0: object) -> bool: ...

    @overload
    def offer(self, arg0: object) -> bool: ...

    @overload
    def peek(self) -> object: ...

    @overload
    def peek(self) -> object: ...

    @overload
    def poll(self) -> object: ...

    @overload
    def poll(self) -> object: ...

    @overload
    def remove(self) -> object: ...

    @overload
    def remove(self) -> object: ...

  class CheckedSet[E](Collections.CheckedCollection):

    def add(self, arg0: object) -> bool: ...

    def addAll(self, arg0: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> Set[E]: ...

    @staticmethod
    @overload
    def of() -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...

  class CheckedSortedSet[E](Collections.CheckedSet):

    @overload
    def comparator(self) -> Comparator[E]: ...

    @overload
    def comparator(self) -> Comparator[E]: ...

    @overload
    def first(self) -> object: ...

    @overload
    def first(self) -> object: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def last(self) -> object: ...

    @overload
    def last(self) -> object: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet[E]: ...

  class CheckedNavigableSet[E](Collections.CheckedSortedSet):

    @overload
    def ceiling(self, arg0: object) -> object: ...

    @overload
    def ceiling(self, arg0: object) -> object: ...

    @overload
    def descendingIterator(self) -> Iterator[E]: ...

    @overload
    def descendingIterator(self) -> Iterator[E]: ...

    @overload
    def descendingSet(self) -> NavigableSet[E]: ...

    @overload
    def descendingSet(self) -> NavigableSet[E]: ...

    @overload
    def floor(self, arg0: object) -> object: ...

    @overload
    def floor(self, arg0: object) -> object: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet: ...

    @overload
    def headSet(self, arg0: object) -> NavigableSet[E]: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def headSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def headSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def higher(self, arg0: object) -> object: ...

    @overload
    def higher(self, arg0: object) -> object: ...

    def iterator(self) -> Iterator[E]: ...

    @overload
    def lower(self, arg0: object) -> object: ...

    @overload
    def lower(self, arg0: object) -> object: ...

    @overload
    def pollFirst(self) -> object: ...

    @overload
    def pollFirst(self) -> object: ...

    @overload
    def pollLast(self) -> object: ...

    @overload
    def pollLast(self) -> object: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> NavigableSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> NavigableSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def tailSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def tailSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

  class CheckedRandomAccessList[E](Collections.CheckedList):

    def subList(self, arg0: int, arg1: int) -> List[E]: ...

  class CheckedList[E](Collections.CheckedCollection):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def get(self, arg0: int) -> object: ...

    @overload
    def get(self, arg0: int) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def indexOf(self, arg0: object) -> int: ...

    @overload
    def indexOf(self, arg0: object) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    @overload
    def lastIndexOf(self, arg0: object) -> int: ...

    @overload
    def lastIndexOf(self, arg0: object) -> int: ...

    @overload
    def listIterator(self) -> ListIterator[E]: ...

    @overload
    def listIterator(self) -> ListIterator[E]: ...

    @overload
    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    @overload
    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    @overload
    def remove(self, arg0: int) -> object: ...

    @overload
    def remove(self, arg0: int) -> object: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    @overload
    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def set(self, arg0: int, arg1: object) -> object: ...

    @overload
    def set(self, arg0: int, arg1: object) -> object: ...

    def size(self) -> int: ...

    @overload
    def sort(self, arg0: Comparator[E]) -> None: ...

    @overload
    def sort(self, arg0: Comparator[E]) -> None: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> List[E]: ...

    @staticmethod
    @overload
    def of() -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...

  class CheckedMap[K, V]:

    @overload
    def clear(self) -> None: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

    @overload
    def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

    @overload
    def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    @overload
    def containsKey(self, arg0: object) -> bool: ...

    @overload
    def containsKey(self, arg0: object) -> bool: ...

    @overload
    def containsValue(self, arg0: object) -> bool: ...

    @overload
    def containsValue(self, arg0: object) -> bool: ...

    @overload
    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    @overload
    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

    @overload
    def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

    @overload
    def get(self, arg0: object) -> object: ...

    @overload
    def get(self, arg0: object) -> object: ...

    def getOrDefault(self, arg0: object, arg1: object) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def keySet(self) -> Set[K]: ...

    @overload
    def keySet(self) -> Set[K]: ...

    @overload
    def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

    @overload
    def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

    @overload
    def put(self, arg0: object, arg1: object) -> object: ...

    @overload
    def put(self, arg0: object, arg1: object) -> object: ...

    @overload
    def putAll(self, arg0: Map[K, V]) -> None: ...

    @overload
    def putAll(self, arg0: Map[K, V]) -> None: ...

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

    @overload
    def remove(self, arg0: object) -> object: ...

    @overload
    def remove(self, arg0: object) -> object: ...

    @overload
    def remove(self, arg0: object, arg1: object) -> bool: ...

    @overload
    def remove(self, arg0: object, arg1: object) -> bool: ...

    @overload
    def replace(self, arg0: object, arg1: object) -> object: ...

    @overload
    def replace(self, arg0: object, arg1: object) -> object: ...

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

    @overload
    def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

    @overload
    def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

    @overload
    def size(self) -> int: ...

    @overload
    def size(self) -> int: ...

    def toString(self) -> str: ...

    @overload
    def values(self) -> Collection[V]: ...

    @overload
    def values(self) -> Collection[V]: ...

    @staticmethod
    def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

    @staticmethod
    def entry(arg0: object, arg1: object) -> Map.Entry: ...

    @staticmethod
    @overload
    def of() -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

    @staticmethod
    def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

    class CheckedEntrySet[CheckedEntrySet_K, CheckedEntrySet_V]:

      @overload
      def add(self, arg0: object) -> bool: ...

      @overload
      def add(self, arg0: object) -> bool: ...

      @overload
      def add(self, arg0: Map.Entry) -> bool: ...

      @overload
      def addAll(self, arg0: Collection[Map.Entry[K, V]]) -> bool: ...

      @overload
      def addAll(self, arg0: Collection[E]) -> bool: ...

      @overload
      def clear(self) -> None: ...

      @overload
      def clear(self) -> None: ...

      @overload
      def contains(self, arg0: object) -> bool: ...

      @overload
      def contains(self, arg0: object) -> bool: ...

      @overload
      def containsAll(self, arg0: Collection[Any]) -> bool: ...

      @overload
      def containsAll(self, arg0: Collection[Any]) -> bool: ...

      @overload
      def equals(self, arg0: object) -> bool: ...

      @overload
      def equals(self, arg0: object) -> bool: ...

      @overload
      def hashCode(self) -> int: ...

      @overload
      def hashCode(self) -> int: ...

      @overload
      def isEmpty(self) -> bool: ...

      @overload
      def isEmpty(self) -> bool: ...

      @overload
      def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

      @overload
      def iterator(self) -> Iterator[E]: ...

      @overload
      def remove(self, arg0: object) -> bool: ...

      @overload
      def remove(self, arg0: object) -> bool: ...

      @overload
      def removeAll(self, arg0: Collection[Any]) -> bool: ...

      @overload
      def removeAll(self, arg0: Collection[Any]) -> bool: ...

      @overload
      def retainAll(self, arg0: Collection[Any]) -> bool: ...

      @overload
      def retainAll(self, arg0: Collection[Any]) -> bool: ...

      @overload
      def size(self) -> int: ...

      @overload
      def size(self) -> int: ...

      def spliterator(self) -> Spliterator[E]: ...

      @overload
      def toArray(self) -> list[object]: ...

      @overload
      def toArray(self) -> list[object]: ...

      @overload
      def toArray(self, arg0: list[object]) -> list[object]: ...

      @overload
      def toArray(self, arg0: list[object]) -> list[object]: ...

      def toString(self) -> str: ...

      @staticmethod
      def copyOf(arg0: Collection[E]) -> Set[E]: ...

      @staticmethod
      @overload
      def of() -> Set[E]: ...

      @staticmethod
      @overload
      def of(arg0: list[object]) -> Set[E]: ...

      @staticmethod
      @overload
      def of(arg0: object) -> Set[E]: ...

      @staticmethod
      @overload
      def of(arg0: object, arg1: object) -> Set[E]: ...

      @staticmethod
      @overload
      def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

      @staticmethod
      @overload
      def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

      @staticmethod
      @overload
      def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

      @staticmethod
      @overload
      def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

      @staticmethod
      @overload
      def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

      @staticmethod
      @overload
      def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

      @staticmethod
      @overload
      def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

      @staticmethod
      @overload
      def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...

      class CheckedEntry[CheckedEntry_K, CheckedEntry_V, T]:

        @overload
        def equals(self, arg0: object) -> bool: ...

        @overload
        def equals(self, arg0: object) -> bool: ...

        @overload
        def getKey(self) -> object: ...

        @overload
        def getKey(self) -> object: ...

        @overload
        def getValue(self) -> object: ...

        @overload
        def getValue(self) -> object: ...

        @overload
        def hashCode(self) -> int: ...

        @overload
        def hashCode(self) -> int: ...

        @overload
        def setValue(self, arg0: object) -> object: ...

        @overload
        def setValue(self, arg0: object) -> object: ...

        def toString(self) -> str: ...

        @staticmethod
        @overload
        def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

        @staticmethod
        @overload
        def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

        @staticmethod
        @overload
        def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

        @staticmethod
        @overload
        def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

        @staticmethod
        def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  class CheckedSortedMap[K, V](Collections.CheckedMap):

    @overload
    def comparator(self) -> Comparator[K]: ...

    @overload
    def comparator(self) -> Comparator[K]: ...

    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    @overload
    def firstKey(self) -> object: ...

    @overload
    def firstKey(self) -> object: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    def keySet(self) -> Set[K]: ...

    @overload
    def lastKey(self) -> object: ...

    @overload
    def lastKey(self) -> object: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    def values(self) -> Collection[V]: ...

  class CheckedNavigableMap[K, V](Collections.CheckedSortedMap):

    @overload
    def ceilingEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def ceilingEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def ceilingKey(self, arg0: object) -> object: ...

    @overload
    def ceilingKey(self, arg0: object) -> object: ...

    def comparator(self) -> Comparator[K]: ...

    @overload
    def descendingKeySet(self) -> NavigableSet[K]: ...

    @overload
    def descendingKeySet(self) -> NavigableSet[K]: ...

    @overload
    def descendingMap(self) -> NavigableMap[K, V]: ...

    @overload
    def descendingMap(self) -> NavigableMap[K, V]: ...

    @overload
    def firstEntry(self) -> Map.Entry: ...

    @overload
    def firstEntry(self) -> Map.Entry: ...

    def firstKey(self) -> object: ...

    @overload
    def floorEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def floorEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def floorKey(self, arg0: object) -> object: ...

    @overload
    def floorKey(self, arg0: object) -> object: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap: ...

    @overload
    def headMap(self, arg0: object) -> NavigableMap[K, V]: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    @overload
    def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    @overload
    def higherEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def higherEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def higherKey(self, arg0: object) -> object: ...

    @overload
    def higherKey(self, arg0: object) -> object: ...

    @overload
    def keySet(self) -> NavigableSet[K]: ...

    @overload
    def keySet(self) -> Set: ...

    @overload
    def lastEntry(self) -> Map.Entry: ...

    @overload
    def lastEntry(self) -> Map.Entry: ...

    def lastKey(self) -> object: ...

    @overload
    def lowerEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def lowerEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def lowerKey(self, arg0: object) -> object: ...

    @overload
    def lowerKey(self, arg0: object) -> object: ...

    @overload
    def navigableKeySet(self) -> NavigableSet[K]: ...

    @overload
    def navigableKeySet(self) -> NavigableSet[K]: ...

    @overload
    def pollFirstEntry(self) -> Map.Entry: ...

    @overload
    def pollFirstEntry(self) -> Map.Entry: ...

    @overload
    def pollLastEntry(self) -> Map.Entry: ...

    @overload
    def pollLastEntry(self) -> Map.Entry: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> NavigableMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap: ...

    @overload
    def tailMap(self, arg0: object) -> NavigableMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

  class EmptyIterator[E]:

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

  class EmptyListIterator[E](Collections.EmptyIterator):

    @overload
    def add(self, arg0: object) -> None: ...

    @overload
    def add(self, arg0: object) -> None: ...

    def hasNext(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    def next(self) -> object: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def previousIndex(self) -> int: ...

    def remove(self) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

  class EmptyEnumeration[E]:

    @overload
    def asIterator(self) -> Iterator[E]: ...

    @overload
    def asIterator(self) -> Iterator[E]: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

  class SingletonSet[E](AbstractSet):

    def contains(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    def hashCode(self) -> int: ...

    def iterator(self) -> Iterator[E]: ...

    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

  class SingletonList[E](AbstractList):

    def contains(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    def get(self, arg0: int) -> object: ...

    def hashCode(self) -> int: ...

    def iterator(self) -> Iterator[E]: ...

    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    def size(self) -> int: ...

    def sort(self, arg0: Comparator[E]) -> None: ...

    def spliterator(self) -> Spliterator[E]: ...

  class SingletonMap[K, V](AbstractMap):

    def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

    def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    def containsKey(self, arg0: object) -> bool: ...

    def containsValue(self, arg0: object) -> bool: ...

    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

    def get(self, arg0: object) -> object: ...

    def getOrDefault(self, arg0: object, arg1: object) -> object: ...

    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def keySet(self) -> Set[K]: ...

    def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

    def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

    def remove(self, arg0: object, arg1: object) -> bool: ...

    @overload
    def replace(self, arg0: object, arg1: object) -> object: ...

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

    def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

    def size(self) -> int: ...

    def values(self) -> Collection[V]: ...

  class CopiesList[E](AbstractList):

    def contains(self, arg0: object) -> bool: ...

    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    def get(self, arg0: int) -> object: ...

    def hashCode(self) -> int: ...

    def indexOf(self, arg0: object) -> int: ...

    def lastIndexOf(self, arg0: object) -> int: ...

    def parallelStream(self) -> Stream[E]: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

    def stream(self) -> Stream[E]: ...

    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class ReverseComparator:

    @overload
    def compare(self, arg0: Comparable[object], arg1: Comparable[object]) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    def equals(self, arg0: object) -> bool: ...

    @overload
    def reversed(self) -> Comparator[Comparable[object]]: ...

    @overload
    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

  class ReverseComparator2[T]:

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    def hashCode(self) -> int: ...

    @overload
    def reversed(self) -> Comparator[T]: ...

    @overload
    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

  class SetFromMap[E](AbstractSet):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: object) -> bool: ...

    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    def parallelStream(self) -> Stream[E]: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def size(self) -> int: ...

    @overload
    def size(self) -> int: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    def stream(self) -> Stream[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    def toString(self) -> str: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> Set[E]: ...

    @staticmethod
    @overload
    def of() -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...

  class AsLIFOQueue[E](AbstractQueue):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: object) -> bool: ...

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def element(self) -> object: ...

    @overload
    def element(self) -> object: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    @overload
    def offer(self, arg0: object) -> bool: ...

    @overload
    def offer(self, arg0: object) -> bool: ...

    def parallelStream(self) -> Stream[E]: ...

    @overload
    def peek(self) -> object: ...

    @overload
    def peek(self) -> object: ...

    @overload
    def poll(self) -> object: ...

    @overload
    def poll(self) -> object: ...

    @overload
    def remove(self) -> object: ...

    @overload
    def remove(self) -> object: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

    def stream(self) -> Stream[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

    def toString(self) -> str: ...

  class EmptySet[E](AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class EmptyList[E](AbstractList):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    def get(self, arg0: int) -> object: ...

    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    def listIterator(self) -> ListIterator[E]: ...

    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    def size(self) -> int: ...

    def sort(self, arg0: Comparator[E]) -> None: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class EmptyMap[K, V](AbstractMap):

    def clear(self) -> None: ...

    def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

    def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    def containsKey(self, arg0: object) -> bool: ...

    def containsValue(self, arg0: object) -> bool: ...

    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

    def get(self, arg0: object) -> object: ...

    def getOrDefault(self, arg0: object, arg1: object) -> object: ...

    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def keySet(self) -> Set[K]: ...

    def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

    def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

    def remove(self, arg0: object, arg1: object) -> bool: ...

    @overload
    def replace(self, arg0: object, arg1: object) -> object: ...

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

    def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

    def size(self) -> int: ...

    def values(self) -> Collection[V]: ...


class Comparator[T]:

  def compare(self, arg0: object, arg1: object) -> int: ...

  def equals(self, arg0: object) -> bool: ...

  def reversed(self) -> Comparator[T]: ...

  @overload
  def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

  @overload
  def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

  @overload
  def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

  def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

  def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

  def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

  @staticmethod
  @overload
  def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

  @staticmethod
  @overload
  def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

  @staticmethod
  def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

  @staticmethod
  def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

  @staticmethod
  def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

  @staticmethod
  def naturalOrder() -> Comparator[T]: ...

  @staticmethod
  def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

  @staticmethod
  def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

  @staticmethod
  def reverseOrder() -> Comparator[T]: ...


class Comparators:

  class NullComparator[T]:

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    def equals(self, arg0: object) -> bool: ...

    @overload
    def reversed(self) -> Comparator[T]: ...

    @overload
    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

  class NaturalOrderComparator(Enum):

    INSTANCE: Comparators.NaturalOrderComparator

    @overload
    def compare(self, arg0: Comparable[object], arg1: Comparable[object]) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    @overload
    def compare(self, arg0: object, arg1: object) -> int: ...

    def equals(self, arg0: object) -> bool: ...

    @overload
    def reversed(self) -> Comparator[Comparable[object]]: ...

    @overload
    def reversed(self) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

    @overload
    def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

    def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

    @staticmethod
    @overload
    def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

    @staticmethod
    def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

    @staticmethod
    def naturalOrder() -> Comparator[T]: ...

    @staticmethod
    def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

    @staticmethod
    def reverseOrder() -> Comparator[T]: ...

    @staticmethod
    def valueOf(arg0: str) -> Comparators.NaturalOrderComparator: ...

    @staticmethod
    def values() -> list[Comparators.NaturalOrderComparator]: ...


class ConcurrentModificationException(RuntimeException):

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: str): ...
  @overload
  def __init__(self, arg0: Throwable): ...
  @overload
  def __init__(self, arg0: str, arg1: Throwable): ...


class Currency:

  def getCurrencyCode(self) -> str: ...

  def getDefaultFractionDigits(self) -> int: ...

  @overload
  def getDisplayName(self) -> str: ...

  @overload
  def getDisplayName(self, arg0: Locale) -> str: ...

  def getNumericCode(self) -> int: ...

  def getNumericCodeAsString(self) -> str: ...

  @overload
  def getSymbol(self) -> str: ...

  @overload
  def getSymbol(self, arg0: Locale) -> str: ...

  def toString(self) -> str: ...

  @staticmethod
  def getAvailableCurrencies() -> Set[Currency]: ...

  @staticmethod
  @overload
  def getInstance(arg0: str) -> Currency: ...

  @staticmethod
  @overload
  def getInstance(arg0: Locale) -> Currency: ...

  class SpecialCaseEntry: ...

  class OtherCurrencyEntry: ...

  class CurrencyNameGetter:

    @overload
    def getObject(self, arg0: CurrencyNameProvider, arg1: Locale, arg2: str, arg3: list[object]) -> str: ...

    @overload
    def getObject(self, arg0: LocaleServiceProvider, arg1: Locale, arg2: str, arg3: list[object]) -> object: ...

    @overload
    def getObject(self, arg0: P, arg1: Locale, arg2: str, arg3: list[object]) -> object: ...

  class CurrencyProperty: ...


class Date:

  def after(self, arg0: Date) -> bool: ...

  def before(self, arg0: Date) -> bool: ...

  def clone(self) -> object: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: Date) -> int: ...

  def equals(self, arg0: object) -> bool: ...

  def getDate(self) -> int: ...

  def getDay(self) -> int: ...

  def getHours(self) -> int: ...

  def getMinutes(self) -> int: ...

  def getMonth(self) -> int: ...

  def getSeconds(self) -> int: ...

  def getTime(self) -> int: ...

  def getTimezoneOffset(self) -> int: ...

  def getYear(self) -> int: ...

  def hashCode(self) -> int: ...

  def setDate(self, arg0: int) -> None: ...

  def setHours(self, arg0: int) -> None: ...

  def setMinutes(self, arg0: int) -> None: ...

  def setMonth(self, arg0: int) -> None: ...

  def setSeconds(self, arg0: int) -> None: ...

  def setTime(self, arg0: int) -> None: ...

  def setYear(self, arg0: int) -> None: ...

  def toGMTString(self) -> str: ...

  def toInstant(self) -> Instant: ...

  def toLocaleString(self) -> str: ...

  def toString(self) -> str: ...

  @staticmethod
  def UTC(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int) -> int: ...

  @staticmethod
  def parse(arg0: str) -> int: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: str): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int): ...
  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int): ...
  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): ...


class Deque[E]:

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  def addFirst(self, arg0: object) -> None: ...

  def addLast(self, arg0: object) -> None: ...

  def contains(self, arg0: object) -> bool: ...

  def descendingIterator(self) -> Iterator[E]: ...

  @overload
  def element(self) -> object: ...

  @overload
  def element(self) -> object: ...

  def getFirst(self) -> object: ...

  def getLast(self) -> object: ...

  def iterator(self) -> Iterator[E]: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  def offerFirst(self, arg0: object) -> bool: ...

  def offerLast(self, arg0: object) -> bool: ...

  @overload
  def peek(self) -> object: ...

  @overload
  def peek(self) -> object: ...

  def peekFirst(self) -> object: ...

  def peekLast(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  def pollFirst(self) -> object: ...

  def pollLast(self) -> object: ...

  def pop(self) -> object: ...

  def push(self, arg0: object) -> None: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  def removeFirst(self) -> object: ...

  def removeFirstOccurrence(self, arg0: object) -> bool: ...

  def removeLast(self) -> object: ...

  def removeLastOccurrence(self, arg0: object) -> bool: ...

  def size(self) -> int: ...


class Dictionary[K, V]:

  def elements(self) -> Enumeration[V]: ...

  def get(self, arg0: object) -> object: ...

  def isEmpty(self) -> bool: ...

  def keys(self) -> Enumeration[K]: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def remove(self, arg0: object) -> object: ...

  def size(self) -> int: ...

  def __init__(self): ...


class DoubleSummaryStatistics:

  @overload
  def accept(self, arg0: float) -> None: ...

  @overload
  def accept(self, arg0: float) -> None: ...

  def andThen(self, arg0: DoubleConsumer) -> DoubleConsumer: ...

  def combine(self, arg0: DoubleSummaryStatistics) -> None: ...

  def getAverage(self) -> float: ...

  def getCount(self) -> int: ...

  def getMax(self) -> float: ...

  def getMin(self) -> float: ...

  def getSum(self) -> float: ...

  def toString(self) -> str: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int, arg1: float, arg2: float, arg3: float): ...


class EmptyStackException(RuntimeException):

  def __init__(self): ...


class EnumMap[K, V](AbstractMap):

  def clear(self) -> None: ...

  @overload
  def clone(self) -> object: ...

  @overload
  def clone(self) -> EnumMap[K, V]: ...

  def containsKey(self, arg0: object) -> bool: ...

  def containsValue(self, arg0: object) -> bool: ...

  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  def equals(self, arg0: object) -> bool: ...

  def get(self, arg0: object) -> object: ...

  def hashCode(self) -> int: ...

  def keySet(self) -> Set[K]: ...

  @overload
  def put(self, arg0: K, arg1: object) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, arg0: Map[K, V]) -> None: ...

  def remove(self, arg0: object) -> object: ...

  def size(self) -> int: ...

  def values(self) -> Collection[V]: ...

  @overload
  def __init__(self, arg0: Class[K]): ...
  @overload
  def __init__(self, arg0: EnumMap[K, V]): ...
  @overload
  def __init__(self, arg0: Map[K, V]): ...

  class KeySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[K]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

  class Values(AbstractCollection):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[V]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

  class EntrySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class EntryIterator(EnumMap.EnumMapIterator):

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

    class Entry:

      @overload
      def equals(self, arg0: object) -> bool: ...

      @overload
      def equals(self, arg0: object) -> bool: ...

      @overload
      def getKey(self) -> object: ...

      @overload
      def getKey(self) -> K: ...

      @overload
      def getKey(self) -> object: ...

      @overload
      def getValue(self) -> object: ...

      @overload
      def getValue(self) -> object: ...

      @overload
      def hashCode(self) -> int: ...

      @overload
      def hashCode(self) -> int: ...

      @overload
      def setValue(self, arg0: object) -> object: ...

      @overload
      def setValue(self, arg0: object) -> object: ...

      def toString(self) -> str: ...

      @staticmethod
      @overload
      def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

      @staticmethod
      @overload
      def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

      @staticmethod
      @overload
      def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

      @staticmethod
      @overload
      def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

      @staticmethod
      def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  class ValueIterator(EnumMap.EnumMapIterator):

    def next(self) -> object: ...

  class KeyIterator(EnumMap.EnumMapIterator):

    @overload
    def next(self) -> K: ...

    @overload
    def next(self) -> object: ...

  class EnumMapIterator[T]:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...


class EnumSet[E](AbstractSet):

  @overload
  def clone(self) -> EnumSet[E]: ...

  @overload
  def clone(self) -> object: ...

  @staticmethod
  def allOf(arg0: Class[E]) -> EnumSet[E]: ...

  @staticmethod
  def complementOf(arg0: EnumSet[E]) -> EnumSet[E]: ...

  @staticmethod
  @overload
  def copyOf(arg0: Collection[E]) -> EnumSet[E]: ...

  @staticmethod
  @overload
  def copyOf(arg0: EnumSet[E]) -> EnumSet[E]: ...

  @staticmethod
  def noneOf(arg0: Class[E]) -> EnumSet[E]: ...

  @staticmethod
  @overload
  def of(arg0: E) -> EnumSet[E]: ...

  @staticmethod
  @overload
  def of(arg0: E, arg1: list[Enum]) -> EnumSet[E]: ...

  @staticmethod
  @overload
  def of(arg0: E, arg1: E) -> EnumSet[E]: ...

  @staticmethod
  @overload
  def of(arg0: E, arg1: E, arg2: E) -> EnumSet[E]: ...

  @staticmethod
  @overload
  def of(arg0: E, arg1: E, arg2: E, arg3: E) -> EnumSet[E]: ...

  @staticmethod
  @overload
  def of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E) -> EnumSet[E]: ...

  @staticmethod
  def range(arg0: E, arg1: E) -> EnumSet[E]: ...

  class SerializationProxy[SerializationProxy_E]: ...


class Enumeration[E]:

  def asIterator(self) -> Iterator[E]: ...

  def hasMoreElements(self) -> bool: ...

  def nextElement(self) -> object: ...


class EventListener: ...


class EventObject:

  def getSource(self) -> object: ...

  def toString(self) -> str: ...

  def __init__(self, arg0: object): ...


class Formatter:

  @overload
  def close(self) -> None: ...

  @overload
  def close(self) -> None: ...

  @overload
  def flush(self) -> None: ...

  @overload
  def flush(self) -> None: ...

  @overload
  def format(self, arg0: str, arg1: list[object]) -> Formatter: ...

  @overload
  def format(self, arg0: Locale, arg1: str, arg2: list[object]) -> Formatter: ...

  def ioException(self) -> IOException: ...

  def locale(self) -> Locale: ...

  def out(self) -> Appendable: ...

  def toString(self) -> str: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: File): ...
  @overload
  def __init__(self, arg0: OutputStream): ...
  @overload
  def __init__(self, arg0: PrintStream): ...
  @overload
  def __init__(self, arg0: Appendable): ...
  @overload
  def __init__(self, arg0: str): ...
  @overload
  def __init__(self, arg0: Locale): ...
  @overload
  def __init__(self, arg0: File, arg1: str): ...
  @overload
  def __init__(self, arg0: OutputStream, arg1: str): ...
  @overload
  def __init__(self, arg0: Appendable, arg1: Locale): ...
  @overload
  def __init__(self, arg0: str, arg1: str): ...
  @overload
  def __init__(self, arg0: File, arg1: str, arg2: Locale): ...
  @overload
  def __init__(self, arg0: File, arg1: Charset, arg2: Locale): ...
  @overload
  def __init__(self, arg0: OutputStream, arg1: str, arg2: Locale): ...
  @overload
  def __init__(self, arg0: OutputStream, arg1: Charset, arg2: Locale): ...
  @overload
  def __init__(self, arg0: str, arg1: str, arg2: Locale): ...
  @overload
  def __init__(self, arg0: str, arg1: Charset, arg2: Locale): ...

  class FormatString:

    def index(self) -> int: ...

    def print(self, arg0: object, arg1: Locale) -> None: ...

    def toString(self) -> str: ...

  class FixedString:

    @overload
    def index(self) -> int: ...

    @overload
    def index(self) -> int: ...

    @overload
    def print(self, arg0: object, arg1: Locale) -> None: ...

    @overload
    def print(self, arg0: object, arg1: Locale) -> None: ...

    @overload
    def toString(self) -> str: ...

    @overload
    def toString(self) -> str: ...

  class Conversion: ...

  class FormatSpecifier:

    @overload
    def index(self) -> int: ...

    @overload
    def index(self) -> int: ...

    @overload
    def print(self, arg0: object, arg1: Locale) -> None: ...

    @overload
    def print(self, arg0: object, arg1: Locale) -> None: ...

    @overload
    def toString(self) -> str: ...

    @overload
    def toString(self) -> str: ...

    class BigDecimalLayout:

      def exponent(self) -> StringBuilder: ...

      def hasDot(self) -> bool: ...

      def mantissa(self) -> StringBuilder: ...

      def scale(self) -> int: ...

      def __init__(self, arg0: Formatter.FormatSpecifier, arg1: BigInteger, arg2: int, arg3: Formatter.BigDecimalLayoutForm): ...

  class DateTime: ...

  class Flags:

    def contains(self, arg0: Formatter.Flags) -> bool: ...

    def dup(self) -> Formatter.Flags: ...

    def remove(self, arg0: Formatter.Flags) -> Formatter.Flags: ...

    def toString(self) -> str: ...

    def valueOf(self) -> int: ...

    @staticmethod
    def parse(arg0: str, arg1: int, arg2: int) -> Formatter.Flags: ...

  class BigDecimalLayoutForm(Enum):

    DECIMAL_FLOAT: Formatter.BigDecimalLayoutForm

    SCIENTIFIC: Formatter.BigDecimalLayoutForm

    @staticmethod
    def valueOf(arg0: str) -> Formatter.BigDecimalLayoutForm: ...

    @staticmethod
    def values() -> list[Formatter.BigDecimalLayoutForm]: ...


class GregorianCalendar(Calendar):

  AD: int

  BC: int

  def add(self, arg0: int, arg1: int) -> None: ...

  def clone(self) -> object: ...

  def equals(self, arg0: object) -> bool: ...

  def getActualMaximum(self, arg0: int) -> int: ...

  def getActualMinimum(self, arg0: int) -> int: ...

  def getCalendarType(self) -> str: ...

  def getGreatestMinimum(self, arg0: int) -> int: ...

  def getGregorianChange(self) -> Date: ...

  def getLeastMaximum(self, arg0: int) -> int: ...

  def getMaximum(self, arg0: int) -> int: ...

  def getMinimum(self, arg0: int) -> int: ...

  def getTimeZone(self) -> TimeZone: ...

  def getWeekYear(self) -> int: ...

  def getWeeksInWeekYear(self) -> int: ...

  def hashCode(self) -> int: ...

  def isLeapYear(self, arg0: int) -> bool: ...

  def isWeekDateSupported(self) -> bool: ...

  @overload
  def roll(self, arg0: int, arg1: bool) -> None: ...

  @overload
  def roll(self, arg0: int, arg1: int) -> None: ...

  def setGregorianChange(self, arg0: Date) -> None: ...

  def setTimeZone(self, arg0: TimeZone) -> None: ...

  def setWeekDate(self, arg0: int, arg1: int, arg2: int) -> None: ...

  def toZonedDateTime(self) -> ZonedDateTime: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: Locale): ...
  @overload
  def __init__(self, arg0: TimeZone): ...
  @overload
  def __init__(self, arg0: TimeZone, arg1: Locale): ...
  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int): ...
  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int): ...
  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): ...


class HashMap[K, V](AbstractMap):

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def clone(self) -> object: ...

  @overload
  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  @overload
  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  @overload
  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def containsKey(self, arg0: object) -> bool: ...

  @overload
  def containsKey(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  def equals(self, arg0: object) -> bool: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def get(self, arg0: object) -> object: ...

  @overload
  def get(self, arg0: object) -> object: ...

  @overload
  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  @overload
  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def hashCode(self) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def keySet(self) -> Set[K]: ...

  @overload
  def keySet(self) -> Set[K]: ...

  @overload
  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putAll(self, arg0: Map[K, V]) -> None: ...

  @overload
  def putAll(self, arg0: Map[K, V]) -> None: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  @overload
  def values(self) -> Collection[V]: ...

  @overload
  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Map[K, V]): ...
  @overload
  def __init__(self, arg0: int, arg1: float): ...

  class Node[Node_K, Node_V]:

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    def toString(self) -> str: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  class TreeNode[TreeNode_K, TreeNode_V](LinkedHashMap.Entry): ...

  class KeySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[K]) -> None: ...

    def iterator(self) -> Iterator[K]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[K]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class Values(AbstractCollection):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[V]) -> None: ...

    def iterator(self) -> Iterator[V]: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[V]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class EntrySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[Map.Entry[K, V]]) -> None: ...

    def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[Map.Entry[K, V]]: ...

  class UnsafeHolder: ...

  class EntrySpliterator[EntrySpliterator_K, EntrySpliterator_V](HashMap.HashMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Map.Entry[K, V]]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Map.Entry[K, V]]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> HashMap.EntrySpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class ValueSpliterator[ValueSpliterator_K, ValueSpliterator_V](HashMap.HashMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[V]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[V]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> HashMap.ValueSpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class KeySpliterator[KeySpliterator_K, KeySpliterator_V](HashMap.HashMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[K]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[K]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> HashMap.KeySpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class HashMapSpliterator[HashMapSpliterator_K, HashMapSpliterator_V]:

    def estimateSize(self) -> int: ...

  class EntryIterator(HashMap.HashIterator):

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

  class ValueIterator(HashMap.HashIterator):

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

  class KeyIterator(HashMap.HashIterator):

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

  class HashIterator:

    def hasNext(self) -> bool: ...

    def remove(self) -> None: ...


class HashSet[E](AbstractSet):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def clone(self) -> object: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def hashCode(self) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> Set[E]: ...

  @staticmethod
  @overload
  def of() -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...
  @overload
  def __init__(self, arg0: int, arg1: float): ...


class Hashtable[K, V](Dictionary):

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def clone(self) -> object: ...

  @overload
  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  @overload
  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  @overload
  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def contains(self, arg0: object) -> bool: ...

  @overload
  def containsKey(self, arg0: object) -> bool: ...

  @overload
  def containsKey(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  def elements(self) -> Enumeration[V]: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def get(self, arg0: object) -> object: ...

  @overload
  def get(self, arg0: object) -> object: ...

  @overload
  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  @overload
  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def keySet(self) -> Set[K]: ...

  @overload
  def keySet(self) -> Set[K]: ...

  def keys(self) -> Enumeration[K]: ...

  @overload
  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putAll(self, arg0: Map[K, V]) -> None: ...

  @overload
  def putAll(self, arg0: Map[K, V]) -> None: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  def toString(self) -> str: ...

  @overload
  def values(self) -> Collection[V]: ...

  @overload
  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Map[K, V]): ...
  @overload
  def __init__(self, arg0: int, arg1: float): ...

  class Entry[Entry_K, Entry_V]:

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    def toString(self) -> str: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  class Enumerator[T]:

    def asIterator(self) -> Iterator[E]: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasMoreElements(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

  class KeySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[K]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

  class EntrySet(AbstractSet):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: Map.Entry) -> bool: ...

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

  class ValueCollection(AbstractCollection):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[V]: ...

    def size(self) -> int: ...

  class UnsafeHolder: ...


class HexFormat:

  def delimiter(self) -> str: ...

  def equals(self, arg0: object) -> bool: ...

  @overload
  def formatHex(self, arg0: list[int]) -> str: ...

  @overload
  def formatHex(self, arg0: A, arg1: list[int]) -> A: ...

  @overload
  def formatHex(self, arg0: list[int], arg1: int, arg2: int) -> str: ...

  @overload
  def formatHex(self, arg0: A, arg1: list[int], arg2: int, arg3: int) -> A: ...

  def hashCode(self) -> int: ...

  def isUpperCase(self) -> bool: ...

  @overload
  def parseHex(self, arg0: CharSequence) -> list[int]: ...

  @overload
  def parseHex(self, arg0: list[str], arg1: int, arg2: int) -> list[int]: ...

  @overload
  def parseHex(self, arg0: CharSequence, arg1: int, arg2: int) -> list[int]: ...

  def prefix(self) -> str: ...

  def suffix(self) -> str: ...

  @overload
  def toHexDigits(self, arg0: int) -> str: ...

  @overload
  def toHexDigits(self, arg0: str) -> str: ...

  @overload
  def toHexDigits(self, arg0: int) -> str: ...

  @overload
  def toHexDigits(self, arg0: int) -> str: ...

  @overload
  def toHexDigits(self, arg0: int) -> str: ...

  @overload
  def toHexDigits(self, arg0: A, arg1: int) -> A: ...

  @overload
  def toHexDigits(self, arg0: int, arg1: int) -> str: ...

  def toHighHexDigit(self, arg0: int) -> str: ...

  def toLowHexDigit(self, arg0: int) -> str: ...

  def toString(self) -> str: ...

  def withDelimiter(self, arg0: str) -> HexFormat: ...

  def withLowerCase(self) -> HexFormat: ...

  def withPrefix(self, arg0: str) -> HexFormat: ...

  def withSuffix(self, arg0: str) -> HexFormat: ...

  def withUpperCase(self) -> HexFormat: ...

  @staticmethod
  def fromHexDigit(arg0: int) -> int: ...

  @staticmethod
  @overload
  def fromHexDigits(arg0: CharSequence) -> int: ...

  @staticmethod
  @overload
  def fromHexDigits(arg0: CharSequence, arg1: int, arg2: int) -> int: ...

  @staticmethod
  @overload
  def fromHexDigitsToLong(arg0: CharSequence) -> int: ...

  @staticmethod
  @overload
  def fromHexDigitsToLong(arg0: CharSequence, arg1: int, arg2: int) -> int: ...

  @staticmethod
  def isHexDigit(arg0: int) -> bool: ...

  @staticmethod
  def of() -> HexFormat: ...

  @staticmethod
  def ofDelimiter(arg0: str) -> HexFormat: ...


class IdentityHashMap[K, V](AbstractMap):

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def clone(self) -> object: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def containsKey(self, arg0: object) -> bool: ...

  @overload
  def containsKey(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def get(self, arg0: object) -> object: ...

  @overload
  def get(self, arg0: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def keySet(self) -> Set[K]: ...

  @overload
  def keySet(self) -> Set[K]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putAll(self, arg0: Map[K, V]) -> None: ...

  @overload
  def putAll(self, arg0: Map[K, V]) -> None: ...

  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  @overload
  def values(self) -> Collection[V]: ...

  @overload
  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Map[K, V]): ...

  class KeySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def hashCode(self) -> int: ...

    def iterator(self) -> Iterator[K]: ...

    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[K]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class Values(AbstractCollection):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[V]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[V]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class EntrySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[Map.Entry[K, V]]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class EntrySpliterator[EntrySpliterator_K, EntrySpliterator_V](IdentityHashMap.IdentityHashMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Map.Entry[K, V]]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Map.Entry[K, V]]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> IdentityHashMap.EntrySpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class ValueSpliterator[ValueSpliterator_K, ValueSpliterator_V](IdentityHashMap.IdentityHashMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[V]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[V]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> IdentityHashMap.ValueSpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class KeySpliterator[KeySpliterator_K, KeySpliterator_V](IdentityHashMap.IdentityHashMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[K]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[K]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> IdentityHashMap.KeySpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class IdentityHashMapSpliterator[IdentityHashMapSpliterator_K, IdentityHashMapSpliterator_V]:

    def estimateSize(self) -> int: ...

  class EntryIterator(IdentityHashMap.IdentityHashMapIterator):

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

    class Entry:

      @overload
      def equals(self, arg0: object) -> bool: ...

      @overload
      def equals(self, arg0: object) -> bool: ...

      @overload
      def getKey(self) -> object: ...

      @overload
      def getKey(self) -> object: ...

      @overload
      def getValue(self) -> object: ...

      @overload
      def getValue(self) -> object: ...

      @overload
      def hashCode(self) -> int: ...

      @overload
      def hashCode(self) -> int: ...

      @overload
      def setValue(self, arg0: object) -> object: ...

      @overload
      def setValue(self, arg0: object) -> object: ...

      def toString(self) -> str: ...

      @staticmethod
      @overload
      def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

      @staticmethod
      @overload
      def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

      @staticmethod
      @overload
      def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

      @staticmethod
      @overload
      def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

      @staticmethod
      def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  class ValueIterator(IdentityHashMap.IdentityHashMapIterator):

    def next(self) -> object: ...

  class KeyIterator(IdentityHashMap.IdentityHashMapIterator):

    def next(self) -> object: ...

  class IdentityHashMapIterator[T]:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...


class ImmutableCollections:

  class List12[E](ImmutableCollections.AbstractImmutableList):

    def get(self, arg0: int) -> object: ...

    def indexOf(self, arg0: object) -> int: ...

    def isEmpty(self) -> bool: ...

    def lastIndexOf(self, arg0: object) -> int: ...

    def size(self) -> int: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class ListN[E](ImmutableCollections.AbstractImmutableList):

    def get(self, arg0: int) -> object: ...

    def indexOf(self, arg0: object) -> int: ...

    def isEmpty(self) -> bool: ...

    def lastIndexOf(self, arg0: object) -> int: ...

    def size(self) -> int: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class SetN[E](ImmutableCollections.AbstractImmutableSet):

    def contains(self, arg0: object) -> bool: ...

    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    def size(self) -> int: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    class SetNIterator:

      def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

      @overload
      def hasNext(self) -> bool: ...

      @overload
      def hasNext(self) -> bool: ...

      @overload
      def next(self) -> object: ...

      @overload
      def next(self) -> object: ...

      def remove(self) -> None: ...

  class MapN[K, V](ImmutableCollections.AbstractImmutableMap):

    def containsKey(self, arg0: object) -> bool: ...

    def containsValue(self, arg0: object) -> bool: ...

    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    def get(self, arg0: object) -> object: ...

    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def size(self) -> int: ...

    class MapNIterator:

      def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

      @overload
      def hasNext(self) -> bool: ...

      @overload
      def hasNext(self) -> bool: ...

      @overload
      def next(self) -> Map.Entry: ...

      @overload
      def next(self) -> object: ...

      @overload
      def next(self) -> object: ...

      def remove(self) -> None: ...

  class Map1[K, V](ImmutableCollections.AbstractImmutableMap):

    def containsKey(self, arg0: object) -> bool: ...

    def containsValue(self, arg0: object) -> bool: ...

    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    def get(self, arg0: object) -> object: ...

    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def size(self) -> int: ...

  class AbstractImmutableMap[K, V](AbstractMap):

    def clear(self) -> None: ...

    def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

    def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    def getOrDefault(self, arg0: object, arg1: object) -> object: ...

    def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

    def put(self, arg0: object, arg1: object) -> object: ...

    def putAll(self, arg0: Map[K, V]) -> None: ...

    def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

    @overload
    def remove(self, arg0: object) -> object: ...

    @overload
    def remove(self, arg0: object, arg1: object) -> bool: ...

    @overload
    def replace(self, arg0: object, arg1: object) -> object: ...

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

    def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  class Set12[E](ImmutableCollections.AbstractImmutableSet):

    def contains(self, arg0: object) -> bool: ...

    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    def size(self) -> int: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class AbstractImmutableSet[E](ImmutableCollections.AbstractImmutableCollection):

    def add(self, arg0: object) -> bool: ...

    def addAll(self, arg0: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[E]: ...

    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> Set[E]: ...

    @staticmethod
    @overload
    def of() -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...

  class SubList[E](ImmutableCollections.AbstractImmutableList):

    def get(self, arg0: int) -> object: ...

    def indexOf(self, arg0: object) -> int: ...

    def iterator(self) -> Iterator[E]: ...

    def lastIndexOf(self, arg0: object) -> int: ...

    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    def size(self) -> int: ...

    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class ListItr[E]:

    @overload
    def add(self, arg0: object) -> None: ...

    @overload
    def add(self, arg0: object) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

  class AbstractImmutableList[E](ImmutableCollections.AbstractImmutableCollection):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    def get(self, arg0: int) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    def indexOf(self, arg0: object) -> int: ...

    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    def lastIndexOf(self, arg0: object) -> int: ...

    @overload
    def listIterator(self) -> ListIterator[E]: ...

    @overload
    def listIterator(self) -> ListIterator[E]: ...

    @overload
    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    @overload
    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    @overload
    def remove(self, arg0: int) -> object: ...

    @overload
    def remove(self, arg0: int) -> object: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    @overload
    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def set(self, arg0: int, arg1: object) -> object: ...

    @overload
    def set(self, arg0: int, arg1: object) -> object: ...

    def size(self) -> int: ...

    @overload
    def sort(self, arg0: Comparator[E]) -> None: ...

    @overload
    def sort(self, arg0: Comparator[E]) -> None: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> List[E]: ...

    @staticmethod
    @overload
    def of() -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...

  class AbstractImmutableCollection[E](AbstractCollection):

    def add(self, arg0: object) -> bool: ...

    def addAll(self, arg0: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

  class Access: ...


class IntSummaryStatistics:

  @overload
  def accept(self, arg0: int) -> None: ...

  @overload
  def accept(self, arg0: int) -> None: ...

  def andThen(self, arg0: IntConsumer) -> IntConsumer: ...

  def combine(self, arg0: IntSummaryStatistics) -> None: ...

  def getAverage(self) -> float: ...

  def getCount(self) -> int: ...

  def getMax(self) -> int: ...

  def getMin(self) -> int: ...

  def getSum(self) -> int: ...

  def toString(self) -> str: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int, arg3: int): ...


class InvalidPropertiesFormatException(IOException):

  @overload
  def __init__(self, arg0: str): ...
  @overload
  def __init__(self, arg0: Throwable): ...


class Iterator[E]:

  def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

  def hasNext(self) -> bool: ...

  def next(self) -> object: ...

  def remove(self) -> None: ...


class KeyValueHolder[K, V]:

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def getKey(self) -> object: ...

  @overload
  def getKey(self) -> object: ...

  @overload
  def getValue(self) -> object: ...

  @overload
  def getValue(self) -> object: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def setValue(self, arg0: object) -> object: ...

  @overload
  def setValue(self, arg0: object) -> object: ...

  def toString(self) -> str: ...

  @staticmethod
  @overload
  def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

  @staticmethod
  @overload
  def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

  @staticmethod
  @overload
  def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

  @staticmethod
  @overload
  def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

  @staticmethod
  def copyOf(arg0: Map.Entry) -> Map.Entry: ...


class LinkedHashMap[K, V](HashMap):

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def containsKey(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  def equals(self, arg0: object) -> bool: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def get(self, arg0: object) -> object: ...

  @overload
  def get(self, arg0: object) -> object: ...

  @overload
  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  @overload
  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  @overload
  def keySet(self) -> Set[K]: ...

  @overload
  def keySet(self) -> Set[K]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, arg0: Map[K, V]) -> None: ...

  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  def size(self) -> int: ...

  @overload
  def values(self) -> Collection[V]: ...

  @overload
  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Map[K, V]): ...
  @overload
  def __init__(self, arg0: int, arg1: float): ...
  @overload
  def __init__(self, arg0: int, arg1: float, arg2: bool): ...

  class Entry[Entry_K, Entry_V](HashMap.Node): ...

  class LinkedKeySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[K]) -> None: ...

    def iterator(self) -> Iterator[K]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[K]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class LinkedValues(AbstractCollection):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[V]) -> None: ...

    def iterator(self) -> Iterator[V]: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[V]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class LinkedEntrySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[Map.Entry[K, V]]) -> None: ...

    def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[Map.Entry[K, V]]: ...

  class LinkedEntryIterator(LinkedHashMap.LinkedHashIterator):

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

  class LinkedValueIterator(LinkedHashMap.LinkedHashIterator):

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

  class LinkedKeyIterator(LinkedHashMap.LinkedHashIterator):

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

  class LinkedHashIterator:

    def hasNext(self) -> bool: ...

    def remove(self) -> None: ...


class LinkedHashSet[E](HashSet):

  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  def clear(self) -> None: ...

  def contains(self, arg0: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> Iterator[E]: ...

  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  def size(self) -> int: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> Set[E]: ...

  @staticmethod
  @overload
  def of() -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...
  @overload
  def __init__(self, arg0: int, arg1: float): ...


class LinkedList[E](AbstractSequentialList):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  @overload
  def addFirst(self, arg0: object) -> None: ...

  @overload
  def addFirst(self, arg0: object) -> None: ...

  @overload
  def addLast(self, arg0: object) -> None: ...

  @overload
  def addLast(self, arg0: object) -> None: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def clone(self) -> object: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def descendingIterator(self) -> Iterator[E]: ...

  @overload
  def descendingIterator(self) -> Iterator[E]: ...

  @overload
  def element(self) -> object: ...

  @overload
  def element(self) -> object: ...

  def equals(self, arg0: object) -> bool: ...

  @overload
  def get(self, arg0: int) -> object: ...

  @overload
  def get(self, arg0: int) -> object: ...

  @overload
  def getFirst(self) -> object: ...

  @overload
  def getFirst(self) -> object: ...

  @overload
  def getLast(self) -> object: ...

  @overload
  def getLast(self) -> object: ...

  def hashCode(self) -> int: ...

  @overload
  def indexOf(self, arg0: object) -> int: ...

  @overload
  def indexOf(self, arg0: object) -> int: ...

  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  @overload
  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offerFirst(self, arg0: object) -> bool: ...

  @overload
  def offerFirst(self, arg0: object) -> bool: ...

  @overload
  def offerLast(self, arg0: object) -> bool: ...

  @overload
  def offerLast(self, arg0: object) -> bool: ...

  @overload
  def peek(self) -> object: ...

  @overload
  def peek(self) -> object: ...

  @overload
  def peekFirst(self) -> object: ...

  @overload
  def peekFirst(self) -> object: ...

  @overload
  def peekLast(self) -> object: ...

  @overload
  def peekLast(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def pollFirst(self) -> object: ...

  @overload
  def pollFirst(self) -> object: ...

  @overload
  def pollLast(self) -> object: ...

  @overload
  def pollLast(self) -> object: ...

  @overload
  def pop(self) -> object: ...

  @overload
  def pop(self) -> object: ...

  @overload
  def push(self, arg0: object) -> None: ...

  @overload
  def push(self, arg0: object) -> None: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self, arg0: int) -> object: ...

  @overload
  def remove(self, arg0: int) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def removeFirst(self) -> object: ...

  @overload
  def removeFirst(self) -> object: ...

  @overload
  def removeFirstOccurrence(self, arg0: object) -> bool: ...

  @overload
  def removeFirstOccurrence(self, arg0: object) -> bool: ...

  @overload
  def removeLast(self) -> object: ...

  @overload
  def removeLast(self) -> object: ...

  @overload
  def removeLastOccurrence(self, arg0: object) -> bool: ...

  @overload
  def removeLastOccurrence(self, arg0: object) -> bool: ...

  def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  def sort(self, arg0: Comparator[E]) -> None: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  def subList(self, arg0: int, arg1: int) -> List[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> List[E]: ...

  @staticmethod
  @overload
  def of() -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...

  class Node[Node_E]: ...

  class ListItr:

    @overload
    def add(self, arg0: object) -> None: ...

    @overload
    def add(self, arg0: object) -> None: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

  class DescendingIterator:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

  class LLSpliterator[LLSpliterator_E]:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[E]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator[E]: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...


class List[E]:

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  def get(self, arg0: int) -> object: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  def indexOf(self, arg0: object) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  def parallelStream(self) -> Stream[E]: ...

  @overload
  def remove(self, arg0: int) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  def set(self, arg0: int, arg1: object) -> object: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  def sort(self, arg0: Comparator[E]) -> None: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  def stream(self) -> Stream[E]: ...

  def subList(self, arg0: int, arg1: int) -> List[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> List[E]: ...

  @staticmethod
  @overload
  def of() -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...


class ListIterator[E]:

  def add(self, arg0: object) -> None: ...

  def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

  @overload
  def hasNext(self) -> bool: ...

  @overload
  def hasNext(self) -> bool: ...

  def hasPrevious(self) -> bool: ...

  @overload
  def next(self) -> object: ...

  @overload
  def next(self) -> object: ...

  def nextIndex(self) -> int: ...

  def previous(self) -> object: ...

  def previousIndex(self) -> int: ...

  @overload
  def remove(self) -> None: ...

  @overload
  def remove(self) -> None: ...

  def set(self, arg0: object) -> None: ...


class Locale:

  CANADA: Locale

  CANADA_FRENCH: Locale

  CHINA: Locale

  CHINESE: Locale

  ENGLISH: Locale

  FRANCE: Locale

  FRENCH: Locale

  GERMAN: Locale

  GERMANY: Locale

  ITALIAN: Locale

  ITALY: Locale

  JAPAN: Locale

  JAPANESE: Locale

  KOREA: Locale

  KOREAN: Locale

  PRC: Locale

  PRIVATE_USE_EXTENSION: str

  ROOT: Locale

  SIMPLIFIED_CHINESE: Locale

  TAIWAN: Locale

  TRADITIONAL_CHINESE: Locale

  UK: Locale

  UNICODE_LOCALE_EXTENSION: str

  US: Locale

  def clone(self) -> object: ...

  def equals(self, arg0: object) -> bool: ...

  def getCountry(self) -> str: ...

  @overload
  def getDisplayCountry(self) -> str: ...

  @overload
  def getDisplayCountry(self, arg0: Locale) -> str: ...

  @overload
  def getDisplayLanguage(self) -> str: ...

  @overload
  def getDisplayLanguage(self, arg0: Locale) -> str: ...

  @overload
  def getDisplayName(self) -> str: ...

  @overload
  def getDisplayName(self, arg0: Locale) -> str: ...

  @overload
  def getDisplayScript(self) -> str: ...

  @overload
  def getDisplayScript(self, arg0: Locale) -> str: ...

  @overload
  def getDisplayVariant(self) -> str: ...

  @overload
  def getDisplayVariant(self, arg0: Locale) -> str: ...

  def getExtension(self, arg0: str) -> str: ...

  def getExtensionKeys(self) -> Set[str]: ...

  def getISO3Country(self) -> str: ...

  def getISO3Language(self) -> str: ...

  def getLanguage(self) -> str: ...

  def getScript(self) -> str: ...

  def getUnicodeLocaleAttributes(self) -> Set[str]: ...

  def getUnicodeLocaleKeys(self) -> Set[str]: ...

  def getUnicodeLocaleType(self, arg0: str) -> str: ...

  def getVariant(self) -> str: ...

  def hasExtensions(self) -> bool: ...

  def hashCode(self) -> int: ...

  def stripExtensions(self) -> Locale: ...

  def toLanguageTag(self) -> str: ...

  def toString(self) -> str: ...

  @staticmethod
  @overload
  def filter(arg0: List[Locale.LanguageRange], arg1: Collection[Locale]) -> List[Locale]: ...

  @staticmethod
  @overload
  def filter(arg0: List[Locale.LanguageRange], arg1: Collection[Locale], arg2: Locale.FilteringMode) -> List[Locale]: ...

  @staticmethod
  @overload
  def filterTags(arg0: List[Locale.LanguageRange], arg1: Collection[str]) -> List[str]: ...

  @staticmethod
  @overload
  def filterTags(arg0: List[Locale.LanguageRange], arg1: Collection[str], arg2: Locale.FilteringMode) -> List[str]: ...

  @staticmethod
  def forLanguageTag(arg0: str) -> Locale: ...

  @staticmethod
  def getAvailableLocales() -> list[Locale]: ...

  @staticmethod
  @overload
  def getDefault() -> Locale: ...

  @staticmethod
  @overload
  def getDefault(arg0: Locale.Category) -> Locale: ...

  @staticmethod
  @overload
  def getISOCountries() -> list[str]: ...

  @staticmethod
  @overload
  def getISOCountries(arg0: Locale.IsoCountryCode) -> Set[str]: ...

  @staticmethod
  def getISOLanguages() -> list[str]: ...

  @staticmethod
  def lookup(arg0: List[Locale.LanguageRange], arg1: Collection[Locale]) -> Locale: ...

  @staticmethod
  def lookupTag(arg0: List[Locale.LanguageRange], arg1: Collection[str]) -> str: ...

  @staticmethod
  @overload
  def setDefault(arg0: Locale) -> None: ...

  @staticmethod
  @overload
  def setDefault(arg0: Locale.Category, arg1: Locale) -> None: ...

  @overload
  def __init__(self, arg0: str): ...
  @overload
  def __init__(self, arg0: str, arg1: str): ...
  @overload
  def __init__(self, arg0: str, arg1: str, arg2: str): ...

  class Cache(LocaleObjectCache): ...

  class LocaleKey:

    def equals(self, arg0: object) -> bool: ...

    def hashCode(self) -> int: ...

  class Category(Enum):

    DISPLAY: Locale.Category

    FORMAT: Locale.Category

    @staticmethod
    def valueOf(arg0: str) -> Locale.Category: ...

    @staticmethod
    def values() -> list[Locale.Category]: ...

  class IsoCountryCode(Enum):

    PART1_ALPHA2: Locale.IsoCountryCode

    PART1_ALPHA3: Locale.IsoCountryCode

    PART3: Locale.IsoCountryCode

    @staticmethod
    def valueOf(arg0: str) -> Locale.IsoCountryCode: ...

    @staticmethod
    def values() -> list[Locale.IsoCountryCode]: ...

  class LocaleNameGetter:

    @overload
    def getObject(self, arg0: LocaleNameProvider, arg1: Locale, arg2: str, arg3: list[object]) -> str: ...

    @overload
    def getObject(self, arg0: LocaleServiceProvider, arg1: Locale, arg2: str, arg3: list[object]) -> object: ...

    @overload
    def getObject(self, arg0: P, arg1: Locale, arg2: str, arg3: list[object]) -> object: ...

  class FilteringMode(Enum):

    AUTOSELECT_FILTERING: Locale.FilteringMode

    EXTENDED_FILTERING: Locale.FilteringMode

    IGNORE_EXTENDED_RANGES: Locale.FilteringMode

    MAP_EXTENDED_RANGES: Locale.FilteringMode

    REJECT_EXTENDED_RANGES: Locale.FilteringMode

    @staticmethod
    def valueOf(arg0: str) -> Locale.FilteringMode: ...

    @staticmethod
    def values() -> list[Locale.FilteringMode]: ...

  class LanguageRange:

    MAX_WEIGHT: float

    MIN_WEIGHT: float

    def equals(self, arg0: object) -> bool: ...

    def getRange(self) -> str: ...

    def getWeight(self) -> float: ...

    def hashCode(self) -> int: ...

    def toString(self) -> str: ...

    @staticmethod
    def mapEquivalents(arg0: List[Locale.LanguageRange], arg1: Map[str, List[str]]) -> List[Locale.LanguageRange]: ...

    @staticmethod
    @overload
    def parse(arg0: str) -> List[Locale.LanguageRange]: ...

    @staticmethod
    @overload
    def parse(arg0: str, arg1: Map[str, List[str]]) -> List[Locale.LanguageRange]: ...

    @overload
    def __init__(self, arg0: str): ...
    @overload
    def __init__(self, arg0: str, arg1: float): ...

  class Builder:

    def addUnicodeLocaleAttribute(self, arg0: str) -> Locale.Builder: ...

    def build(self) -> Locale: ...

    def clear(self) -> Locale.Builder: ...

    def clearExtensions(self) -> Locale.Builder: ...

    def removeUnicodeLocaleAttribute(self, arg0: str) -> Locale.Builder: ...

    def setExtension(self, arg0: str, arg1: str) -> Locale.Builder: ...

    def setLanguage(self, arg0: str) -> Locale.Builder: ...

    def setLanguageTag(self, arg0: str) -> Locale.Builder: ...

    def setLocale(self, arg0: Locale) -> Locale.Builder: ...

    def setRegion(self, arg0: str) -> Locale.Builder: ...

    def setScript(self, arg0: str) -> Locale.Builder: ...

    def setUnicodeLocaleKeyword(self, arg0: str, arg1: str) -> Locale.Builder: ...

    def setVariant(self, arg0: str) -> Locale.Builder: ...

    def __init__(self): ...


class LongSummaryStatistics:

  @overload
  def accept(self, arg0: int) -> None: ...

  @overload
  def accept(self, arg0: int) -> None: ...

  @overload
  def accept(self, arg0: int) -> None: ...

  @overload
  def accept(self, arg0: int) -> None: ...

  @overload
  def andThen(self, arg0: IntConsumer) -> IntConsumer: ...

  @overload
  def andThen(self, arg0: LongConsumer) -> LongConsumer: ...

  def combine(self, arg0: LongSummaryStatistics) -> None: ...

  def getAverage(self) -> float: ...

  def getCount(self) -> int: ...

  def getMax(self) -> int: ...

  def getMin(self) -> int: ...

  def getSum(self) -> int: ...

  def toString(self) -> str: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int, arg3: int): ...


class Map[K, V]:

  def clear(self) -> None: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def containsKey(self, arg0: object) -> bool: ...

  def containsValue(self, arg0: object) -> bool: ...

  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  def equals(self, arg0: object) -> bool: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  def get(self, arg0: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  def keySet(self) -> Set[K]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, arg0: Map[K, V]) -> None: ...

  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  def size(self) -> int: ...

  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

  class Entry[Entry_K, Entry_V]:

    def equals(self, arg0: object) -> bool: ...

    def getKey(self) -> object: ...

    def getValue(self) -> object: ...

    def hashCode(self) -> int: ...

    def setValue(self, arg0: object) -> object: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...


class MissingResourceException(RuntimeException):

  def getClassName(self) -> str: ...

  def getKey(self) -> str: ...

  def __init__(self, arg0: str, arg1: str, arg2: str): ...


class NavigableMap[K, V]:

  def ceilingEntry(self, arg0: object) -> Map.Entry: ...

  def ceilingKey(self, arg0: object) -> object: ...

  def comparator(self) -> Comparator[K]: ...

  def descendingKeySet(self) -> NavigableSet[K]: ...

  def descendingMap(self) -> NavigableMap[K, V]: ...

  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  def firstEntry(self) -> Map.Entry: ...

  def firstKey(self) -> object: ...

  def floorEntry(self, arg0: object) -> Map.Entry: ...

  def floorKey(self, arg0: object) -> object: ...

  @overload
  def headMap(self, arg0: object) -> SortedMap[K, V]: ...

  @overload
  def headMap(self, arg0: object) -> SortedMap[K, V]: ...

  @overload
  def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

  def higherEntry(self, arg0: object) -> Map.Entry: ...

  def higherKey(self, arg0: object) -> object: ...

  def keySet(self) -> Set[K]: ...

  def lastEntry(self) -> Map.Entry: ...

  def lastKey(self) -> object: ...

  def lowerEntry(self, arg0: object) -> Map.Entry: ...

  def lowerKey(self, arg0: object) -> object: ...

  def navigableKeySet(self) -> NavigableSet[K]: ...

  def pollFirstEntry(self) -> Map.Entry: ...

  def pollLastEntry(self) -> Map.Entry: ...

  @overload
  def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

  @overload
  def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

  @overload
  def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

  @overload
  def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

  @overload
  def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

  @overload
  def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

  def values(self) -> Collection[V]: ...


class NavigableSet[E]:

  def ceiling(self, arg0: object) -> object: ...

  def comparator(self) -> Comparator[E]: ...

  def descendingIterator(self) -> Iterator[E]: ...

  def descendingSet(self) -> NavigableSet[E]: ...

  def first(self) -> object: ...

  def floor(self, arg0: object) -> object: ...

  @overload
  def headSet(self, arg0: object) -> SortedSet[E]: ...

  @overload
  def headSet(self, arg0: object) -> SortedSet[E]: ...

  @overload
  def headSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

  def higher(self, arg0: object) -> object: ...

  def iterator(self) -> Iterator[E]: ...

  def last(self) -> object: ...

  def lower(self, arg0: object) -> object: ...

  def pollFirst(self) -> object: ...

  def pollLast(self) -> object: ...

  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

  @overload
  def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

  @overload
  def subSet(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableSet[E]: ...

  @overload
  def tailSet(self, arg0: object) -> SortedSet[E]: ...

  @overload
  def tailSet(self, arg0: object) -> SortedSet[E]: ...

  @overload
  def tailSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...


class NoSuchElementException(RuntimeException):

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: str): ...
  @overload
  def __init__(self, arg0: Throwable): ...
  @overload
  def __init__(self, arg0: str, arg1: Throwable): ...


class Objects:

  @staticmethod
  @overload
  def checkFromIndexSize(arg0: int, arg1: int, arg2: int) -> int: ...

  @staticmethod
  @overload
  def checkFromIndexSize(arg0: int, arg1: int, arg2: int) -> int: ...

  @staticmethod
  @overload
  def checkFromToIndex(arg0: int, arg1: int, arg2: int) -> int: ...

  @staticmethod
  @overload
  def checkFromToIndex(arg0: int, arg1: int, arg2: int) -> int: ...

  @staticmethod
  @overload
  def checkIndex(arg0: int, arg1: int) -> int: ...

  @staticmethod
  @overload
  def checkIndex(arg0: int, arg1: int) -> int: ...

  @staticmethod
  def compare(arg0: object, arg1: object, arg2: Comparator[T]) -> int: ...

  @staticmethod
  def deepEquals(arg0: object, arg1: object) -> bool: ...

  @staticmethod
  def equals(arg0: object, arg1: object) -> bool: ...

  @staticmethod
  def hash(arg0: list[object]) -> int: ...

  @staticmethod
  def hashCode(arg0: object) -> int: ...

  @staticmethod
  def isNull(arg0: object) -> bool: ...

  @staticmethod
  def nonNull(arg0: object) -> bool: ...

  @staticmethod
  @overload
  def requireNonNull(arg0: object) -> object: ...

  @staticmethod
  @overload
  def requireNonNull(arg0: object, arg1: str) -> object: ...

  @staticmethod
  @overload
  def requireNonNull(arg0: object, arg1: Supplier[str]) -> object: ...

  @staticmethod
  def requireNonNullElse(arg0: object, arg1: object) -> object: ...

  @staticmethod
  def requireNonNullElseGet(arg0: object, arg1: Supplier[T]) -> object: ...

  @staticmethod
  @overload
  def toString(arg0: object) -> str: ...

  @staticmethod
  @overload
  def toString(arg0: object, arg1: str) -> str: ...


class Optional[T]:

  def equals(self, arg0: object) -> bool: ...

  def filter(self, arg0: Predicate[T]) -> Optional[T]: ...

  def flatMap(self, arg0: Function[T, Optional[U]]) -> Optional[U]: ...

  def get(self) -> object: ...

  def hashCode(self) -> int: ...

  def ifPresent(self, arg0: Consumer[T]) -> None: ...

  def ifPresentOrElse(self, arg0: Consumer[T], arg1: Runnable) -> None: ...

  def isEmpty(self) -> bool: ...

  def isPresent(self) -> bool: ...

  def map(self, arg0: Function[T, U]) -> Optional[U]: ...

  def orElse(self, arg0: object) -> object: ...

  def orElseGet(self, arg0: Supplier[T]) -> object: ...

  @overload
  def orElseThrow(self) -> object: ...

  @overload
  def orElseThrow(self, arg0: Supplier[X]) -> object: ...

  def stream(self) -> Stream[T]: ...

  def toString(self) -> str: ...

  @staticmethod
  def empty() -> Optional[T]: ...

  @staticmethod
  def of(arg0: object) -> Optional[T]: ...

  @staticmethod
  def ofNullable(arg0: object) -> Optional[T]: ...


class OptionalDouble:

  def equals(self, arg0: object) -> bool: ...

  def getAsDouble(self) -> float: ...

  def hashCode(self) -> int: ...

  def ifPresent(self, arg0: DoubleConsumer) -> None: ...

  def ifPresentOrElse(self, arg0: DoubleConsumer, arg1: Runnable) -> None: ...

  def isEmpty(self) -> bool: ...

  def isPresent(self) -> bool: ...

  def orElse(self, arg0: float) -> float: ...

  def orElseGet(self, arg0: DoubleSupplier) -> float: ...

  @overload
  def orElseThrow(self) -> float: ...

  @overload
  def orElseThrow(self, arg0: Supplier[X]) -> float: ...

  def stream(self) -> DoubleStream: ...

  def toString(self) -> str: ...

  @staticmethod
  def empty() -> OptionalDouble: ...

  @staticmethod
  def of(arg0: float) -> OptionalDouble: ...


class OptionalInt:

  def equals(self, arg0: object) -> bool: ...

  def getAsInt(self) -> int: ...

  def hashCode(self) -> int: ...

  def ifPresent(self, arg0: IntConsumer) -> None: ...

  def ifPresentOrElse(self, arg0: IntConsumer, arg1: Runnable) -> None: ...

  def isEmpty(self) -> bool: ...

  def isPresent(self) -> bool: ...

  def orElse(self, arg0: int) -> int: ...

  def orElseGet(self, arg0: IntSupplier) -> int: ...

  @overload
  def orElseThrow(self) -> int: ...

  @overload
  def orElseThrow(self, arg0: Supplier[X]) -> int: ...

  def stream(self) -> IntStream: ...

  def toString(self) -> str: ...

  @staticmethod
  def empty() -> OptionalInt: ...

  @staticmethod
  def of(arg0: int) -> OptionalInt: ...


class OptionalLong:

  def equals(self, arg0: object) -> bool: ...

  def getAsLong(self) -> int: ...

  def hashCode(self) -> int: ...

  def ifPresent(self, arg0: LongConsumer) -> None: ...

  def ifPresentOrElse(self, arg0: LongConsumer, arg1: Runnable) -> None: ...

  def isEmpty(self) -> bool: ...

  def isPresent(self) -> bool: ...

  def orElse(self, arg0: int) -> int: ...

  def orElseGet(self, arg0: LongSupplier) -> int: ...

  @overload
  def orElseThrow(self) -> int: ...

  @overload
  def orElseThrow(self, arg0: Supplier[X]) -> int: ...

  def stream(self) -> LongStream: ...

  def toString(self) -> str: ...

  @staticmethod
  def empty() -> OptionalLong: ...

  @staticmethod
  def of(arg0: int) -> OptionalLong: ...


class PrimitiveIterator[T, T_CONS]:

  @overload
  def forEachRemaining(self, arg0: object) -> None: ...

  @overload
  def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

  def hasNext(self) -> bool: ...

  def next(self) -> object: ...

  def remove(self) -> None: ...

  class OfDouble:

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Double]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: DoubleConsumer) -> None: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> Double: ...

    def nextDouble(self) -> float: ...

  class OfLong:

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Long]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: LongConsumer) -> None: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> Long: ...

    def nextLong(self) -> int: ...

  class OfInt:

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Integer]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: IntConsumer) -> None: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> Integer: ...

    def nextInt(self) -> int: ...


class PriorityQueue[E](AbstractQueue):

  def add(self, arg0: object) -> bool: ...

  def clear(self) -> None: ...

  def comparator(self) -> Comparator[E]: ...

  def contains(self, arg0: object) -> bool: ...

  def forEach(self, arg0: Consumer[E]) -> None: ...

  def iterator(self) -> Iterator[E]: ...

  def offer(self, arg0: object) -> bool: ...

  def peek(self) -> object: ...

  def poll(self) -> object: ...

  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  def size(self) -> int: ...

  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...
  @overload
  def __init__(self, arg0: Comparator[E]): ...
  @overload
  def __init__(self, arg0: PriorityQueue[E]): ...
  @overload
  def __init__(self, arg0: SortedSet[E]): ...
  @overload
  def __init__(self, arg0: int, arg1: Comparator[E]): ...

  class Itr:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

  class PriorityQueueSpliterator:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[E]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> PriorityQueue.PriorityQueueSpliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...


class Properties(Hashtable):

  def clear(self) -> None: ...

  def clone(self) -> object: ...

  def compute(self, arg0: object, arg1: BiFunction[object, object, Any]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[object, Any]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[object, object, Any]) -> object: ...

  def contains(self, arg0: object) -> bool: ...

  def containsKey(self, arg0: object) -> bool: ...

  def containsValue(self, arg0: object) -> bool: ...

  def elements(self) -> Enumeration[object]: ...

  def entrySet(self) -> Set[Map.Entry[object, object]]: ...

  def equals(self, arg0: object) -> bool: ...

  def forEach(self, arg0: BiConsumer[object, object]) -> None: ...

  def get(self, arg0: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  @overload
  def getProperty(self, arg0: str) -> str: ...

  @overload
  def getProperty(self, arg0: str, arg1: str) -> str: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  def keySet(self) -> Set[object]: ...

  def keys(self) -> Enumeration[object]: ...

  @overload
  def list(self, arg0: PrintStream) -> None: ...

  @overload
  def list(self, arg0: PrintWriter) -> None: ...

  @overload
  def load(self, arg0: InputStream) -> None: ...

  @overload
  def load(self, arg0: Reader) -> None: ...

  def loadFromXML(self, arg0: InputStream) -> None: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[object, object, Any]) -> object: ...

  def propertyNames(self) -> Enumeration[Any]: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, arg0: Map[Any, Any]) -> None: ...

  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[object, object, Any]) -> None: ...

  def save(self, arg0: OutputStream, arg1: str) -> None: ...

  def setProperty(self, arg0: str, arg1: str) -> object: ...

  def size(self) -> int: ...

  @overload
  def store(self, arg0: OutputStream, arg1: str) -> None: ...

  @overload
  def store(self, arg0: Writer, arg1: str) -> None: ...

  @overload
  def storeToXML(self, arg0: OutputStream, arg1: str) -> None: ...

  @overload
  def storeToXML(self, arg0: OutputStream, arg1: str, arg2: str) -> None: ...

  @overload
  def storeToXML(self, arg0: OutputStream, arg1: str, arg2: Charset) -> None: ...

  def stringPropertyNames(self) -> Set[str]: ...

  def toString(self) -> str: ...

  def values(self) -> Collection[object]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Properties): ...

  class LineReader: ...

  class EntrySet:

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: Map.Entry) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[Map.Entry[object, object]]) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[Map.Entry[object, object]]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def size(self) -> int: ...

    @overload
    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    def toString(self) -> str: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> Set[E]: ...

    @staticmethod
    @overload
    def of() -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...


class Queue[E]:

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  def clear(self) -> None: ...

  def contains(self, arg0: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  def element(self) -> object: ...

  def equals(self, arg0: object) -> bool: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> Iterator[E]: ...

  def offer(self, arg0: object) -> bool: ...

  def parallelStream(self) -> Stream[E]: ...

  def peek(self) -> object: ...

  def poll(self) -> object: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  def size(self) -> int: ...

  def spliterator(self) -> Spliterator[E]: ...

  def stream(self) -> Stream[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: IntFunction[T]) -> list[object]: ...


class Random:

  @overload
  def doubles(self) -> DoubleStream: ...

  @overload
  def doubles(self) -> DoubleStream: ...

  @overload
  def doubles(self, arg0: int) -> DoubleStream: ...

  @overload
  def doubles(self, arg0: int) -> DoubleStream: ...

  @overload
  def doubles(self, arg0: float, arg1: float) -> DoubleStream: ...

  @overload
  def doubles(self, arg0: float, arg1: float) -> DoubleStream: ...

  @overload
  def doubles(self, arg0: int, arg1: float, arg2: float) -> DoubleStream: ...

  @overload
  def doubles(self, arg0: int, arg1: float, arg2: float) -> DoubleStream: ...

  @overload
  def ints(self) -> IntStream: ...

  @overload
  def ints(self) -> IntStream: ...

  @overload
  def ints(self, arg0: int) -> IntStream: ...

  @overload
  def ints(self, arg0: int) -> IntStream: ...

  @overload
  def ints(self, arg0: int, arg1: int) -> IntStream: ...

  @overload
  def ints(self, arg0: int, arg1: int) -> IntStream: ...

  @overload
  def ints(self, arg0: int, arg1: int, arg2: int) -> IntStream: ...

  @overload
  def ints(self, arg0: int, arg1: int, arg2: int) -> IntStream: ...

  def isDeprecated(self) -> bool: ...

  @overload
  def longs(self) -> LongStream: ...

  @overload
  def longs(self) -> LongStream: ...

  @overload
  def longs(self, arg0: int) -> LongStream: ...

  @overload
  def longs(self, arg0: int) -> LongStream: ...

  @overload
  def longs(self, arg0: int, arg1: int) -> LongStream: ...

  @overload
  def longs(self, arg0: int, arg1: int) -> LongStream: ...

  @overload
  def longs(self, arg0: int, arg1: int, arg2: int) -> LongStream: ...

  @overload
  def longs(self, arg0: int, arg1: int, arg2: int) -> LongStream: ...

  @overload
  def nextBoolean(self) -> bool: ...

  @overload
  def nextBoolean(self) -> bool: ...

  @overload
  def nextBytes(self, arg0: list[int]) -> None: ...

  @overload
  def nextBytes(self, arg0: list[int]) -> None: ...

  @overload
  def nextDouble(self) -> float: ...

  @overload
  def nextDouble(self) -> float: ...

  @overload
  def nextDouble(self, arg0: float) -> float: ...

  @overload
  def nextDouble(self, arg0: float, arg1: float) -> float: ...

  def nextExponential(self) -> float: ...

  @overload
  def nextFloat(self) -> float: ...

  @overload
  def nextFloat(self) -> float: ...

  @overload
  def nextFloat(self, arg0: float) -> float: ...

  @overload
  def nextFloat(self, arg0: float, arg1: float) -> float: ...

  @overload
  def nextGaussian(self) -> float: ...

  @overload
  def nextGaussian(self) -> float: ...

  @overload
  def nextGaussian(self, arg0: float, arg1: float) -> float: ...

  @overload
  def nextInt(self) -> int: ...

  @overload
  def nextInt(self) -> int: ...

  @overload
  def nextInt(self, arg0: int) -> int: ...

  @overload
  def nextInt(self, arg0: int) -> int: ...

  @overload
  def nextInt(self, arg0: int, arg1: int) -> int: ...

  @overload
  def nextLong(self) -> int: ...

  @overload
  def nextLong(self) -> int: ...

  @overload
  def nextLong(self, arg0: int) -> int: ...

  @overload
  def nextLong(self, arg0: int, arg1: int) -> int: ...

  def setSeed(self, arg0: int) -> None: ...

  @staticmethod
  def getDefault() -> RandomGenerator: ...

  @staticmethod
  def of(arg0: str) -> RandomGenerator: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...


class RandomAccess: ...


class RegularEnumSet[E](EnumSet):

  @overload
  def add(self, arg0: E) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  def clear(self) -> None: ...

  def contains(self, arg0: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> Iterator[E]: ...

  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  def size(self) -> int: ...

  class EnumSetIterator[EnumSetIterator_E]:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> E: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...


class ResourceBundle:

  def containsKey(self, arg0: str) -> bool: ...

  def getBaseBundleName(self) -> str: ...

  def getKeys(self) -> Enumeration[str]: ...

  def getLocale(self) -> Locale: ...

  def getObject(self, arg0: str) -> object: ...

  def getString(self, arg0: str) -> str: ...

  def getStringArray(self, arg0: str) -> list[str]: ...

  def keySet(self) -> Set[str]: ...

  @staticmethod
  @overload
  def clearCache() -> None: ...

  @staticmethod
  @overload
  def clearCache(arg0: ClassLoader) -> None: ...

  @staticmethod
  @overload
  def getBundle(arg0: str) -> ResourceBundle: ...

  @staticmethod
  @overload
  def getBundle(arg0: str, arg1: Module) -> ResourceBundle: ...

  @staticmethod
  @overload
  def getBundle(arg0: str, arg1: Locale) -> ResourceBundle: ...

  @staticmethod
  @overload
  def getBundle(arg0: str, arg1: ResourceBundle.Control) -> ResourceBundle: ...

  @staticmethod
  @overload
  def getBundle(arg0: str, arg1: Locale, arg2: ClassLoader) -> ResourceBundle: ...

  @staticmethod
  @overload
  def getBundle(arg0: str, arg1: Locale, arg2: Module) -> ResourceBundle: ...

  @staticmethod
  @overload
  def getBundle(arg0: str, arg1: Locale, arg2: ResourceBundle.Control) -> ResourceBundle: ...

  @staticmethod
  @overload
  def getBundle(arg0: str, arg1: Locale, arg2: ClassLoader, arg3: ResourceBundle.Control) -> ResourceBundle: ...

  def __init__(self): ...

  class Control:

    FORMAT_CLASS: List[str]

    FORMAT_DEFAULT: List[str]

    FORMAT_PROPERTIES: List[str]

    TTL_DONT_CACHE: int

    TTL_NO_EXPIRATION_CONTROL: int

    def getCandidateLocales(self, arg0: str, arg1: Locale) -> List[Locale]: ...

    def getFallbackLocale(self, arg0: str, arg1: Locale) -> Locale: ...

    def getFormats(self, arg0: str) -> List[str]: ...

    def getTimeToLive(self, arg0: str, arg1: Locale) -> int: ...

    def needsReload(self, arg0: str, arg1: Locale, arg2: str, arg3: ClassLoader, arg4: ResourceBundle, arg5: int) -> bool: ...

    def newBundle(self, arg0: str, arg1: Locale, arg2: str, arg3: ClassLoader, arg4: bool) -> ResourceBundle: ...

    def toBundleName(self, arg0: str, arg1: Locale) -> str: ...

    def toResourceName(self, arg0: str, arg1: str) -> str: ...

    @staticmethod
    def getControl(arg0: List[str]) -> ResourceBundle.Control: ...

    @staticmethod
    def getNoFallbackControl(arg0: List[str]) -> ResourceBundle.Control: ...

    class CandidateListCache(LocaleObjectCache): ...

  class ResourceBundleControlProviderHolder: ...

  class CacheKey:

    def equals(self, arg0: object) -> bool: ...

    def hashCode(self) -> int: ...

    def toString(self) -> str: ...

  class BundleReference(SoftReference):

    @overload
    def getCacheKey(self) -> ResourceBundle.CacheKey: ...

    @overload
    def getCacheKey(self) -> ResourceBundle.CacheKey: ...

  class SingleFormatControl(ResourceBundle.Control):

    def getFormats(self, arg0: str) -> List[str]: ...

  class CacheKeyReference:

    def getCacheKey(self) -> ResourceBundle.CacheKey: ...

  class ResourceBundleProviderHelper: ...

  class NoFallbackControl(ResourceBundle.SingleFormatControl):

    def getFallbackLocale(self, arg0: str, arg1: Locale) -> Locale: ...

  class KeyElementReference[T](WeakReference):

    @overload
    def getCacheKey(self) -> ResourceBundle.CacheKey: ...

    @overload
    def getCacheKey(self) -> ResourceBundle.CacheKey: ...


class ServiceConfigurationError(Error):

  @overload
  def __init__(self, arg0: str): ...
  @overload
  def __init__(self, arg0: str, arg1: Throwable): ...


class ServiceLoader[S]:

  def findFirst(self) -> Optional[S]: ...

  def forEach(self, arg0: Consumer[T]) -> None: ...

  @overload
  def iterator(self) -> Iterator[S]: ...

  @overload
  def iterator(self) -> Iterator[T]: ...

  def reload(self) -> None: ...

  def spliterator(self) -> Spliterator[T]: ...

  def stream(self) -> Stream[ServiceLoader.Provider[S]]: ...

  def toString(self) -> str: ...

  @staticmethod
  @overload
  def load(arg0: Class[S]) -> ServiceLoader[S]: ...

  @staticmethod
  @overload
  def load(arg0: Class[S], arg1: ClassLoader) -> ServiceLoader[S]: ...

  @staticmethod
  @overload
  def load(arg0: ModuleLayer, arg1: Class[S]) -> ServiceLoader[S]: ...

  @staticmethod
  def loadInstalled(arg0: Class[S]) -> ServiceLoader[S]: ...

  class ProviderImpl[ProviderImpl_S]:

    def equals(self, arg0: object) -> bool: ...

    @overload
    def get(self) -> object: ...

    @overload
    def get(self) -> object: ...

    def hashCode(self) -> int: ...

    @overload
    def type(self) -> Class[S]: ...

    @overload
    def type(self) -> Class[S]: ...

  class LayerLookupIterator[T]:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> ServiceLoader.Provider: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

  class ModuleServicesLookupIterator[T]:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> ServiceLoader.Provider: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

  class LazyClassPathLookupIterator[T]:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> ServiceLoader.Provider: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

  class ProviderSpliterator[T]:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[ServiceLoader.Provider[T]]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator[ServiceLoader.Provider[T]]: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class Provider[Provider_S]:

    @overload
    def get(self) -> object: ...

    @overload
    def get(self) -> object: ...

    def type(self) -> Class[S]: ...


class Set[E]:

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  def parallelStream(self) -> Stream[E]: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  def stream(self) -> Stream[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> Set[E]: ...

  @staticmethod
  @overload
  def of() -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...


class SortedMap[K, V]:

  def clear(self) -> None: ...

  def comparator(self) -> Comparator[K]: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def containsKey(self, arg0: object) -> bool: ...

  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  def equals(self, arg0: object) -> bool: ...

  def firstKey(self) -> object: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  def get(self, arg0: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def hashCode(self) -> int: ...

  def headMap(self, arg0: object) -> SortedMap[K, V]: ...

  def isEmpty(self) -> bool: ...

  @overload
  def keySet(self) -> Set[K]: ...

  @overload
  def keySet(self) -> Set[K]: ...

  def lastKey(self) -> object: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, arg0: Map[K, V]) -> None: ...

  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  def size(self) -> int: ...

  def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

  def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

  @overload
  def values(self) -> Collection[V]: ...

  @overload
  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...


class SortedSet[E]:

  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  def clear(self) -> None: ...

  def comparator(self) -> Comparator[E]: ...

  def contains(self, arg0: object) -> bool: ...

  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def first(self) -> object: ...

  def hashCode(self) -> int: ...

  def headSet(self, arg0: object) -> SortedSet[E]: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> Iterator[E]: ...

  def last(self) -> object: ...

  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  def size(self) -> int: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

  def tailSet(self, arg0: object) -> SortedSet[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> Set[E]: ...

  @staticmethod
  @overload
  def of() -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...


class Spliterator[T]:

  CONCURRENT: int

  DISTINCT: int

  IMMUTABLE: int

  NONNULL: int

  ORDERED: int

  SIZED: int

  SORTED: int

  SUBSIZED: int

  def characteristics(self) -> int: ...

  def estimateSize(self) -> int: ...

  def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

  def getComparator(self) -> Comparator[T]: ...

  def getExactSizeIfKnown(self) -> int: ...

  def hasCharacteristics(self, arg0: int) -> bool: ...

  def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

  def trySplit(self) -> Spliterator[T]: ...

  class OfDouble:

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Double]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: DoubleConsumer) -> None: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Double]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: DoubleConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfDouble: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

  class OfLong:

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Long]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: LongConsumer) -> None: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Long]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: LongConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfLong: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

  class OfInt:

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Integer]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: IntConsumer) -> None: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Integer]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: IntConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfInt: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

  class OfPrimitive[OfPrimitive_T, T_CONS, T_SPLITR]:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...


class Spliterators:

  @staticmethod
  def emptyDoubleSpliterator() -> Spliterator.OfDouble: ...

  @staticmethod
  def emptyIntSpliterator() -> Spliterator.OfInt: ...

  @staticmethod
  def emptyLongSpliterator() -> Spliterator.OfLong: ...

  @staticmethod
  def emptySpliterator() -> Spliterator[T]: ...

  @staticmethod
  @overload
  def iterator(arg0: Spliterator[T]) -> Iterator[T]: ...

  @staticmethod
  @overload
  def iterator(arg0: Spliterator.OfDouble) -> PrimitiveIterator.OfDouble: ...

  @staticmethod
  @overload
  def iterator(arg0: Spliterator.OfInt) -> PrimitiveIterator.OfInt: ...

  @staticmethod
  @overload
  def iterator(arg0: Spliterator.OfLong) -> PrimitiveIterator.OfLong: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[float], arg1: int) -> Spliterator.OfDouble: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[int], arg1: int) -> Spliterator.OfInt: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[int], arg1: int) -> Spliterator.OfLong: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[object], arg1: int) -> Spliterator[T]: ...

  @staticmethod
  @overload
  def spliterator(arg0: Collection[T], arg1: int) -> Spliterator[T]: ...

  @staticmethod
  @overload
  def spliterator(arg0: Iterator[T], arg1: int, arg2: int) -> Spliterator[T]: ...

  @staticmethod
  @overload
  def spliterator(arg0: PrimitiveIterator.OfDouble, arg1: int, arg2: int) -> Spliterator.OfDouble: ...

  @staticmethod
  @overload
  def spliterator(arg0: PrimitiveIterator.OfInt, arg1: int, arg2: int) -> Spliterator.OfInt: ...

  @staticmethod
  @overload
  def spliterator(arg0: PrimitiveIterator.OfLong, arg1: int, arg2: int) -> Spliterator.OfLong: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[float], arg1: int, arg2: int, arg3: int) -> Spliterator.OfDouble: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[int], arg1: int, arg2: int, arg3: int) -> Spliterator.OfInt: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[int], arg1: int, arg2: int, arg3: int) -> Spliterator.OfLong: ...

  @staticmethod
  @overload
  def spliterator(arg0: list[object], arg1: int, arg2: int, arg3: int) -> Spliterator[T]: ...

  @staticmethod
  @overload
  def spliteratorUnknownSize(arg0: Iterator[T], arg1: int) -> Spliterator[T]: ...

  @staticmethod
  @overload
  def spliteratorUnknownSize(arg0: PrimitiveIterator.OfDouble, arg1: int) -> Spliterator.OfDouble: ...

  @staticmethod
  @overload
  def spliteratorUnknownSize(arg0: PrimitiveIterator.OfInt, arg1: int) -> Spliterator.OfInt: ...

  @staticmethod
  @overload
  def spliteratorUnknownSize(arg0: PrimitiveIterator.OfLong, arg1: int) -> Spliterator.OfLong: ...

  class ArraySpliterator[T]:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    @overload
    def getComparator(self) -> Comparator[T]: ...

    @overload
    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

    @overload
    def __init__(self, arg0: list[object], arg1: int): ...
    @overload
    def __init__(self, arg0: list[object], arg1: int, arg2: int, arg3: int): ...

  class IntArraySpliterator:

    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Integer]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: IntConsumer) -> None: ...

    @overload
    def forEachRemaining(self, arg0: IntConsumer) -> None: ...

    def getComparator(self) -> Comparator[Integer]: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Integer]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: IntConsumer) -> bool: ...

    @overload
    def tryAdvance(self, arg0: IntConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator.OfInt: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfInt: ...

    @overload
    def __init__(self, arg0: list[int], arg1: int): ...
    @overload
    def __init__(self, arg0: list[int], arg1: int, arg2: int, arg3: int): ...

  class LongArraySpliterator:

    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Long]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: LongConsumer) -> None: ...

    @overload
    def forEachRemaining(self, arg0: LongConsumer) -> None: ...

    def getComparator(self) -> Comparator[Long]: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Long]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: LongConsumer) -> bool: ...

    @overload
    def tryAdvance(self, arg0: LongConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator.OfLong: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfLong: ...

    @overload
    def __init__(self, arg0: list[int], arg1: int): ...
    @overload
    def __init__(self, arg0: list[int], arg1: int, arg2: int, arg3: int): ...

  class DoubleArraySpliterator:

    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Double]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: DoubleConsumer) -> None: ...

    @overload
    def forEachRemaining(self, arg0: DoubleConsumer) -> None: ...

    def getComparator(self) -> Comparator[Double]: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Double]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: DoubleConsumer) -> bool: ...

    @overload
    def tryAdvance(self, arg0: DoubleConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator.OfDouble: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfDouble: ...

    @overload
    def __init__(self, arg0: list[float], arg1: int): ...
    @overload
    def __init__(self, arg0: list[float], arg1: int, arg2: int, arg3: int): ...

  class IteratorSpliterator[T]:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    @overload
    def getComparator(self) -> Comparator[T]: ...

    @overload
    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

    @overload
    def __init__(self, arg0: Collection[T], arg1: int): ...
    @overload
    def __init__(self, arg0: Iterator[T], arg1: int): ...
    @overload
    def __init__(self, arg0: Iterator[T], arg1: int, arg2: int): ...

  class IntIteratorSpliterator:

    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Integer]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: IntConsumer) -> None: ...

    @overload
    def forEachRemaining(self, arg0: IntConsumer) -> None: ...

    def getComparator(self) -> Comparator[Integer]: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Integer]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: IntConsumer) -> bool: ...

    @overload
    def tryAdvance(self, arg0: IntConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator.OfInt: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfInt: ...

    @overload
    def __init__(self, arg0: PrimitiveIterator.OfInt, arg1: int): ...
    @overload
    def __init__(self, arg0: PrimitiveIterator.OfInt, arg1: int, arg2: int): ...

  class LongIteratorSpliterator:

    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Long]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: LongConsumer) -> None: ...

    @overload
    def forEachRemaining(self, arg0: LongConsumer) -> None: ...

    def getComparator(self) -> Comparator[Long]: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Long]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: LongConsumer) -> bool: ...

    @overload
    def tryAdvance(self, arg0: LongConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator.OfLong: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfLong: ...

    @overload
    def __init__(self, arg0: PrimitiveIterator.OfLong, arg1: int): ...
    @overload
    def __init__(self, arg0: PrimitiveIterator.OfLong, arg1: int, arg2: int): ...

  class DoubleIteratorSpliterator:

    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Double]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: DoubleConsumer) -> None: ...

    @overload
    def forEachRemaining(self, arg0: DoubleConsumer) -> None: ...

    def getComparator(self) -> Comparator[Double]: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Double]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: DoubleConsumer) -> bool: ...

    @overload
    def tryAdvance(self, arg0: DoubleConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator.OfDouble: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfDouble: ...

    @overload
    def __init__(self, arg0: PrimitiveIterator.OfDouble, arg1: int): ...
    @overload
    def __init__(self, arg0: PrimitiveIterator.OfDouble, arg1: int, arg2: int): ...

  class EmptySpliterator[T, S, C]:

    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    def forEachRemaining(self, arg0: object) -> None: ...

    def tryAdvance(self, arg0: object) -> bool: ...

    def trySplit(self) -> S: ...

    class OfDouble(Spliterators.EmptySpliterator):

      @overload
      def forEachRemaining(self, arg0: object) -> None: ...

      @overload
      def forEachRemaining(self, arg0: Consumer[Double]) -> None: ...

      @overload
      def forEachRemaining(self, arg0: DoubleConsumer) -> None: ...

      @overload
      def forEachRemaining(self, arg0: DoubleConsumer) -> None: ...

      @overload
      def tryAdvance(self, arg0: object) -> bool: ...

      @overload
      def tryAdvance(self, arg0: Consumer[Double]) -> bool: ...

      @overload
      def tryAdvance(self, arg0: DoubleConsumer) -> bool: ...

      @overload
      def tryAdvance(self, arg0: DoubleConsumer) -> bool: ...

      @overload
      def trySplit(self) -> Spliterator.OfDouble: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

      @overload
      def trySplit(self) -> Spliterator: ...

      @overload
      def trySplit(self) -> Spliterator.OfDouble: ...

    class OfLong(Spliterators.EmptySpliterator):

      @overload
      def forEachRemaining(self, arg0: object) -> None: ...

      @overload
      def forEachRemaining(self, arg0: Consumer[Long]) -> None: ...

      @overload
      def forEachRemaining(self, arg0: LongConsumer) -> None: ...

      @overload
      def forEachRemaining(self, arg0: LongConsumer) -> None: ...

      @overload
      def tryAdvance(self, arg0: object) -> bool: ...

      @overload
      def tryAdvance(self, arg0: Consumer[Long]) -> bool: ...

      @overload
      def tryAdvance(self, arg0: LongConsumer) -> bool: ...

      @overload
      def tryAdvance(self, arg0: LongConsumer) -> bool: ...

      @overload
      def trySplit(self) -> Spliterator.OfLong: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

      @overload
      def trySplit(self) -> Spliterator: ...

      @overload
      def trySplit(self) -> Spliterator.OfLong: ...

    class OfInt(Spliterators.EmptySpliterator):

      @overload
      def forEachRemaining(self, arg0: object) -> None: ...

      @overload
      def forEachRemaining(self, arg0: Consumer[Integer]) -> None: ...

      @overload
      def forEachRemaining(self, arg0: IntConsumer) -> None: ...

      @overload
      def forEachRemaining(self, arg0: IntConsumer) -> None: ...

      @overload
      def tryAdvance(self, arg0: object) -> bool: ...

      @overload
      def tryAdvance(self, arg0: Consumer[Integer]) -> bool: ...

      @overload
      def tryAdvance(self, arg0: IntConsumer) -> bool: ...

      @overload
      def tryAdvance(self, arg0: IntConsumer) -> bool: ...

      @overload
      def trySplit(self) -> Spliterator.OfInt: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

      @overload
      def trySplit(self) -> Spliterator: ...

      @overload
      def trySplit(self) -> Spliterator.OfInt: ...

    class OfRef[OfRef_T](Spliterators.EmptySpliterator):

      CONCURRENT: int

      DISTINCT: int

      IMMUTABLE: int

      NONNULL: int

      ORDERED: int

      SIZED: int

      SORTED: int

      SUBSIZED: int

      def characteristics(self) -> int: ...

      def estimateSize(self) -> int: ...

      @overload
      def forEachRemaining(self, arg0: Consumer) -> None: ...

      @overload
      def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

      def getComparator(self) -> Comparator[T]: ...

      def getExactSizeIfKnown(self) -> int: ...

      def hasCharacteristics(self, arg0: int) -> bool: ...

      @overload
      def tryAdvance(self, arg0: Consumer) -> bool: ...

      @overload
      def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

      def trySplit(self) -> Spliterator[T]: ...

  class AbstractDoubleSpliterator:

    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Double]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: DoubleConsumer) -> None: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Double]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: DoubleConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfDouble: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfDouble: ...

    class HoldingDoubleConsumer:

      @overload
      def accept(self, arg0: float) -> None: ...

      @overload
      def accept(self, arg0: float) -> None: ...

      def andThen(self, arg0: DoubleConsumer) -> DoubleConsumer: ...

  class AbstractLongSpliterator:

    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Long]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: LongConsumer) -> None: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Long]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: LongConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfLong: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfLong: ...

    class HoldingLongConsumer:

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      def andThen(self, arg0: LongConsumer) -> LongConsumer: ...

  class AbstractIntSpliterator:

    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: object) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Integer]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: IntConsumer) -> None: ...

    @overload
    def tryAdvance(self, arg0: object) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Integer]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: IntConsumer) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfInt: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator.OfPrimitive: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator.OfInt: ...

    class HoldingIntConsumer:

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      def andThen(self, arg0: IntConsumer) -> IntConsumer: ...

  class AbstractSpliterator[T]:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

    class HoldingConsumer[HoldingConsumer_T]:

      @overload
      def accept(self, arg0: object) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      def andThen(self, arg0: Consumer[T]) -> Consumer[T]: ...


class Stack[E](Vector):

  def empty(self) -> bool: ...

  def peek(self) -> object: ...

  def pop(self) -> object: ...

  def push(self, arg0: object) -> object: ...

  def search(self, arg0: object) -> int: ...

  def __init__(self): ...


class StringJoiner:

  def add(self, arg0: CharSequence) -> StringJoiner: ...

  def length(self) -> int: ...

  def merge(self, arg0: StringJoiner) -> StringJoiner: ...

  def setEmptyValue(self, arg0: CharSequence) -> StringJoiner: ...

  def toString(self) -> str: ...

  @overload
  def __init__(self, arg0: CharSequence): ...
  @overload
  def __init__(self, arg0: CharSequence, arg1: CharSequence, arg2: CharSequence): ...


class StringTokenizer:

  def asIterator(self) -> Iterator[E]: ...

  def countTokens(self) -> int: ...

  @overload
  def hasMoreElements(self) -> bool: ...

  @overload
  def hasMoreElements(self) -> bool: ...

  def hasMoreTokens(self) -> bool: ...

  @overload
  def nextElement(self) -> object: ...

  @overload
  def nextElement(self) -> object: ...

  @overload
  def nextToken(self) -> str: ...

  @overload
  def nextToken(self, arg0: str) -> str: ...

  @overload
  def __init__(self, arg0: str): ...
  @overload
  def __init__(self, arg0: str, arg1: str): ...
  @overload
  def __init__(self, arg0: str, arg1: str, arg2: bool): ...


class TaskQueue: ...


class TimSort[T]: ...


class TimeZone:

  LONG: int

  SHORT: int

  def clone(self) -> object: ...

  def getDSTSavings(self) -> int: ...

  @overload
  def getDisplayName(self) -> str: ...

  @overload
  def getDisplayName(self, arg0: Locale) -> str: ...

  @overload
  def getDisplayName(self, arg0: bool, arg1: int) -> str: ...

  @overload
  def getDisplayName(self, arg0: bool, arg1: int, arg2: Locale) -> str: ...

  def getID(self) -> str: ...

  @overload
  def getOffset(self, arg0: int) -> int: ...

  @overload
  def getOffset(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int) -> int: ...

  def getRawOffset(self) -> int: ...

  def hasSameRules(self, arg0: TimeZone) -> bool: ...

  def inDaylightTime(self, arg0: Date) -> bool: ...

  def observesDaylightTime(self) -> bool: ...

  def setID(self, arg0: str) -> None: ...

  def setRawOffset(self, arg0: int) -> None: ...

  def toZoneId(self) -> ZoneId: ...

  def useDaylightTime(self) -> bool: ...

  @staticmethod
  @overload
  def getAvailableIDs() -> list[str]: ...

  @staticmethod
  @overload
  def getAvailableIDs(arg0: int) -> list[str]: ...

  @staticmethod
  def getDefault() -> TimeZone: ...

  @staticmethod
  @overload
  def getTimeZone(arg0: str) -> TimeZone: ...

  @staticmethod
  @overload
  def getTimeZone(arg0: ZoneId) -> TimeZone: ...

  @staticmethod
  def setDefault(arg0: TimeZone) -> None: ...

  def __init__(self): ...


class Timer:

  def cancel(self) -> None: ...

  def purge(self) -> int: ...

  @overload
  def schedule(self, arg0: TimerTask, arg1: Date) -> None: ...

  @overload
  def schedule(self, arg0: TimerTask, arg1: int) -> None: ...

  @overload
  def schedule(self, arg0: TimerTask, arg1: Date, arg2: int) -> None: ...

  @overload
  def schedule(self, arg0: TimerTask, arg1: int, arg2: int) -> None: ...

  @overload
  def scheduleAtFixedRate(self, arg0: TimerTask, arg1: Date, arg2: int) -> None: ...

  @overload
  def scheduleAtFixedRate(self, arg0: TimerTask, arg1: int, arg2: int) -> None: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: bool): ...
  @overload
  def __init__(self, arg0: str): ...
  @overload
  def __init__(self, arg0: str, arg1: bool): ...

  class ThreadReaper:

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...


class TimerTask:

  def cancel(self) -> bool: ...

  @overload
  def run(self) -> None: ...

  @overload
  def run(self) -> None: ...

  def scheduledExecutionTime(self) -> int: ...


class TimerThread(Thread):

  def run(self) -> None: ...


class TooManyListenersException(Exception):

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: str): ...


class TreeMap[K, V](AbstractMap):

  @overload
  def ceilingEntry(self, arg0: object) -> Map.Entry: ...

  @overload
  def ceilingEntry(self, arg0: object) -> Map.Entry: ...

  @overload
  def ceilingKey(self, arg0: object) -> object: ...

  @overload
  def ceilingKey(self, arg0: object) -> object: ...

  def clear(self) -> None: ...

  def clone(self) -> object: ...

  def comparator(self) -> Comparator[K]: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def containsKey(self, arg0: object) -> bool: ...

  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def descendingKeySet(self) -> NavigableSet[K]: ...

  @overload
  def descendingKeySet(self) -> NavigableSet[K]: ...

  @overload
  def descendingMap(self) -> NavigableMap[K, V]: ...

  @overload
  def descendingMap(self) -> NavigableMap[K, V]: ...

  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def firstEntry(self) -> Map.Entry: ...

  @overload
  def firstEntry(self) -> Map.Entry: ...

  def firstKey(self) -> object: ...

  @overload
  def floorEntry(self, arg0: object) -> Map.Entry: ...

  @overload
  def floorEntry(self, arg0: object) -> Map.Entry: ...

  @overload
  def floorKey(self, arg0: object) -> object: ...

  @overload
  def floorKey(self, arg0: object) -> object: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  def get(self, arg0: object) -> object: ...

  @overload
  def headMap(self, arg0: object) -> SortedMap[K, V]: ...

  @overload
  def headMap(self, arg0: object) -> SortedMap[K, V]: ...

  @overload
  def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

  @overload
  def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

  @overload
  def higherEntry(self, arg0: object) -> Map.Entry: ...

  @overload
  def higherEntry(self, arg0: object) -> Map.Entry: ...

  @overload
  def higherKey(self, arg0: object) -> object: ...

  @overload
  def higherKey(self, arg0: object) -> object: ...

  def keySet(self) -> Set[K]: ...

  @overload
  def lastEntry(self) -> Map.Entry: ...

  @overload
  def lastEntry(self) -> Map.Entry: ...

  def lastKey(self) -> object: ...

  @overload
  def lowerEntry(self, arg0: object) -> Map.Entry: ...

  @overload
  def lowerEntry(self, arg0: object) -> Map.Entry: ...

  @overload
  def lowerKey(self, arg0: object) -> object: ...

  @overload
  def lowerKey(self, arg0: object) -> object: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def navigableKeySet(self) -> NavigableSet[K]: ...

  @overload
  def navigableKeySet(self) -> NavigableSet[K]: ...

  @overload
  def pollFirstEntry(self) -> Map.Entry: ...

  @overload
  def pollFirstEntry(self) -> Map.Entry: ...

  @overload
  def pollLastEntry(self) -> Map.Entry: ...

  @overload
  def pollLastEntry(self) -> Map.Entry: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, arg0: Map[K, V]) -> None: ...

  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  def remove(self, arg0: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  def size(self) -> int: ...

  @overload
  def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

  @overload
  def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

  @overload
  def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

  @overload
  def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

  @overload
  def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

  @overload
  def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

  @overload
  def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

  @overload
  def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

  def values(self) -> Collection[V]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: Comparator[K]): ...
  @overload
  def __init__(self, arg0: Map[K, V]): ...
  @overload
  def __init__(self, arg0: SortedMap[K, V]): ...

  class Entry[Entry_K, Entry_V]:

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    def toString(self) -> str: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  class EntrySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[Map.Entry[K, V]]: ...

  class KeySet[E](AbstractSet):

    @overload
    def ceiling(self, arg0: object) -> object: ...

    @overload
    def ceiling(self, arg0: object) -> object: ...

    def clear(self) -> None: ...

    def comparator(self) -> Comparator[E]: ...

    def contains(self, arg0: object) -> bool: ...

    @overload
    def descendingIterator(self) -> Iterator[E]: ...

    @overload
    def descendingIterator(self) -> Iterator[E]: ...

    @overload
    def descendingSet(self) -> NavigableSet[E]: ...

    @overload
    def descendingSet(self) -> NavigableSet[E]: ...

    def first(self) -> object: ...

    @overload
    def floor(self, arg0: object) -> object: ...

    @overload
    def floor(self, arg0: object) -> object: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def headSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def headSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def headSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def higher(self, arg0: object) -> object: ...

    @overload
    def higher(self, arg0: object) -> object: ...

    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    def last(self) -> object: ...

    @overload
    def lower(self, arg0: object) -> object: ...

    @overload
    def lower(self, arg0: object) -> object: ...

    @overload
    def pollFirst(self) -> object: ...

    @overload
    def pollFirst(self) -> object: ...

    @overload
    def pollLast(self) -> object: ...

    @overload
    def pollLast(self) -> object: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableSet[E]: ...

    @overload
    def subSet(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def tailSet(self, arg0: object) -> SortedSet[E]: ...

    @overload
    def tailSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

    @overload
    def tailSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

  class Values(AbstractCollection):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[V]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[V]: ...

  class DescendingSubMap[DescendingSubMap_K, DescendingSubMap_V](TreeMap.NavigableSubMap):

    def comparator(self) -> Comparator[K]: ...

    def descendingMap(self) -> NavigableMap[K, V]: ...

    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

    def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    class DescendingEntrySetView(TreeMap.NavigableSubMap.EntrySetView):

      def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

  class AscendingSubMap[AscendingSubMap_K, AscendingSubMap_V](TreeMap.NavigableSubMap):

    def comparator(self) -> Comparator[K]: ...

    def descendingMap(self) -> NavigableMap[K, V]: ...

    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

    def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    class AscendingEntrySetView(TreeMap.NavigableSubMap.EntrySetView):

      def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

  class KeyIterator(TreeMap.PrivateEntryIterator):

    def next(self) -> object: ...

  class DescendingKeyIterator(TreeMap.PrivateEntryIterator):

    def next(self) -> object: ...

    def remove(self) -> None: ...

  class NavigableSubMap[NavigableSubMap_K, NavigableSubMap_V](AbstractMap):

    @overload
    def ceilingEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def ceilingEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def ceilingKey(self, arg0: object) -> object: ...

    @overload
    def ceilingKey(self, arg0: object) -> object: ...

    def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

    def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    def containsKey(self, arg0: object) -> bool: ...

    @overload
    def descendingKeySet(self) -> NavigableSet[K]: ...

    @overload
    def descendingKeySet(self) -> NavigableSet[K]: ...

    def descendingMap(self) -> NavigableMap[K, V]: ...

    @overload
    def firstEntry(self) -> Map.Entry: ...

    @overload
    def firstEntry(self) -> Map.Entry: ...

    def firstKey(self) -> object: ...

    @overload
    def floorEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def floorEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def floorKey(self, arg0: object) -> object: ...

    @overload
    def floorKey(self, arg0: object) -> object: ...

    def get(self, arg0: object) -> object: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    @overload
    def higherEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def higherEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def higherKey(self, arg0: object) -> object: ...

    @overload
    def higherKey(self, arg0: object) -> object: ...

    def isEmpty(self) -> bool: ...

    def keySet(self) -> Set[K]: ...

    @overload
    def lastEntry(self) -> Map.Entry: ...

    @overload
    def lastEntry(self) -> Map.Entry: ...

    def lastKey(self) -> object: ...

    @overload
    def lowerEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def lowerEntry(self, arg0: object) -> Map.Entry: ...

    @overload
    def lowerKey(self, arg0: object) -> object: ...

    @overload
    def lowerKey(self, arg0: object) -> object: ...

    def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

    @overload
    def navigableKeySet(self) -> NavigableSet[K]: ...

    @overload
    def navigableKeySet(self) -> NavigableSet[K]: ...

    @overload
    def pollFirstEntry(self) -> Map.Entry: ...

    @overload
    def pollFirstEntry(self) -> Map.Entry: ...

    @overload
    def pollLastEntry(self) -> Map.Entry: ...

    @overload
    def pollLastEntry(self) -> Map.Entry: ...

    def put(self, arg0: object, arg1: object) -> object: ...

    def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

    def remove(self, arg0: object) -> object: ...

    def size(self) -> int: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

    class DescendingSubMapKeyIterator(TreeMap.NavigableSubMap.SubMapIterator):

      CONCURRENT: int

      DISTINCT: int

      IMMUTABLE: int

      NONNULL: int

      ORDERED: int

      SIZED: int

      SORTED: int

      SUBSIZED: int

      @overload
      def characteristics(self) -> int: ...

      @overload
      def characteristics(self) -> int: ...

      @overload
      def estimateSize(self) -> int: ...

      @overload
      def estimateSize(self) -> int: ...

      @overload
      def forEachRemaining(self, arg0: Consumer[K]) -> None: ...

      @overload
      def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

      def getComparator(self) -> Comparator[T]: ...

      def getExactSizeIfKnown(self) -> int: ...

      def hasCharacteristics(self, arg0: int) -> bool: ...

      def next(self) -> object: ...

      def remove(self) -> None: ...

      @overload
      def tryAdvance(self, arg0: Consumer[K]) -> bool: ...

      @overload
      def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

      @overload
      def trySplit(self) -> Spliterator[K]: ...

      @overload
      def trySplit(self) -> Spliterator[T]: ...

    class SubMapKeyIterator(TreeMap.NavigableSubMap.SubMapIterator):

      CONCURRENT: int

      DISTINCT: int

      IMMUTABLE: int

      NONNULL: int

      ORDERED: int

      SIZED: int

      SORTED: int

      SUBSIZED: int

      @overload
      def characteristics(self) -> int: ...

      @overload
      def characteristics(self) -> int: ...

      @overload
      def estimateSize(self) -> int: ...

      @overload
      def estimateSize(self) -> int: ...

      @overload
      def forEachRemaining(self, arg0: Consumer[K]) -> None: ...

      @overload
      def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

      @overload
      def getComparator(self) -> Comparator[K]: ...

      @overload
      def getComparator(self) -> Comparator[T]: ...

      def getExactSizeIfKnown(self) -> int: ...

      def hasCharacteristics(self, arg0: int) -> bool: ...

      def next(self) -> object: ...

      def remove(self) -> None: ...

      @overload
      def tryAdvance(self, arg0: Consumer[K]) -> bool: ...

      @overload
      def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

      @overload
      def trySplit(self) -> Spliterator[K]: ...

      @overload
      def trySplit(self) -> Spliterator[T]: ...

    class DescendingSubMapEntryIterator(TreeMap.NavigableSubMap.SubMapIterator):

      @overload
      def next(self) -> Map.Entry: ...

      @overload
      def next(self) -> object: ...

      def remove(self) -> None: ...

    class SubMapEntryIterator(TreeMap.NavigableSubMap.SubMapIterator):

      @overload
      def next(self) -> Map.Entry: ...

      @overload
      def next(self) -> object: ...

      def remove(self) -> None: ...

    class SubMapIterator[T]:

      def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

      @overload
      def hasNext(self) -> bool: ...

      @overload
      def hasNext(self) -> bool: ...

      def next(self) -> object: ...

      def remove(self) -> None: ...

    class EntrySetView(AbstractSet):

      def contains(self, arg0: object) -> bool: ...

      def isEmpty(self) -> bool: ...

      def remove(self, arg0: object) -> bool: ...

      def size(self) -> int: ...

  class KeySpliterator[KeySpliterator_K, KeySpliterator_V](TreeMap.TreeMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[K]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    @overload
    def getComparator(self) -> Comparator[K]: ...

    @overload
    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[K]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> TreeMap.KeySpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class DescendingKeySpliterator[DescendingKeySpliterator_K, DescendingKeySpliterator_V](TreeMap.TreeMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[K]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[K]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> TreeMap.DescendingKeySpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class EntrySpliterator[EntrySpliterator_K, EntrySpliterator_V](TreeMap.TreeMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Map.Entry[K, V]]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    @overload
    def getComparator(self) -> Comparator[Map.Entry[K, V]]: ...

    @overload
    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Map.Entry[K, V]]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> TreeMap.EntrySpliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class ValueSpliterator[ValueSpliterator_K, ValueSpliterator_V](TreeMap.TreeMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[V]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[V]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> TreeMap.ValueSpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class TreeMapSpliterator[TreeMapSpliterator_K, TreeMapSpliterator_V]:

    def estimateSize(self) -> int: ...

  class SubMap(AbstractMap):

    @overload
    def comparator(self) -> Comparator[K]: ...

    @overload
    def comparator(self) -> Comparator[K]: ...

    @overload
    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    @overload
    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    @overload
    def firstKey(self) -> object: ...

    @overload
    def firstKey(self) -> object: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def headMap(self, arg0: object) -> SortedMap[K, V]: ...

    def keySet(self) -> Set[K]: ...

    @overload
    def lastKey(self) -> object: ...

    @overload
    def lastKey(self) -> object: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    @overload
    def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

    def values(self) -> Collection[V]: ...

  class ValueIterator(TreeMap.PrivateEntryIterator):

    def next(self) -> object: ...

  class EntryIterator(TreeMap.PrivateEntryIterator):

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

  class PrivateEntryIterator[T]:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...


class TreeSet[E](AbstractSet):

  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def ceiling(self, arg0: object) -> object: ...

  @overload
  def ceiling(self, arg0: object) -> object: ...

  def clear(self) -> None: ...

  def clone(self) -> object: ...

  def comparator(self) -> Comparator[E]: ...

  def contains(self, arg0: object) -> bool: ...

  @overload
  def descendingIterator(self) -> Iterator[E]: ...

  @overload
  def descendingIterator(self) -> Iterator[E]: ...

  @overload
  def descendingSet(self) -> NavigableSet[E]: ...

  @overload
  def descendingSet(self) -> NavigableSet[E]: ...

  def first(self) -> object: ...

  @overload
  def floor(self, arg0: object) -> object: ...

  @overload
  def floor(self, arg0: object) -> object: ...

  @overload
  def headSet(self, arg0: object) -> SortedSet[E]: ...

  @overload
  def headSet(self, arg0: object) -> SortedSet[E]: ...

  @overload
  def headSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

  @overload
  def headSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

  @overload
  def higher(self, arg0: object) -> object: ...

  @overload
  def higher(self, arg0: object) -> object: ...

  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  def last(self) -> object: ...

  @overload
  def lower(self, arg0: object) -> object: ...

  @overload
  def lower(self, arg0: object) -> object: ...

  @overload
  def pollFirst(self) -> object: ...

  @overload
  def pollFirst(self) -> object: ...

  @overload
  def pollLast(self) -> object: ...

  @overload
  def pollLast(self) -> object: ...

  def remove(self, arg0: object) -> bool: ...

  def size(self) -> int: ...

  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

  @overload
  def subSet(self, arg0: object, arg1: object) -> SortedSet[E]: ...

  @overload
  def subSet(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableSet[E]: ...

  @overload
  def subSet(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableSet[E]: ...

  @overload
  def tailSet(self, arg0: object) -> SortedSet[E]: ...

  @overload
  def tailSet(self, arg0: object) -> SortedSet[E]: ...

  @overload
  def tailSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

  @overload
  def tailSet(self, arg0: object, arg1: bool) -> NavigableSet[E]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...
  @overload
  def __init__(self, arg0: Comparator[E]): ...
  @overload
  def __init__(self, arg0: SortedSet[E]): ...


class UUID:

  def clockSequence(self) -> int: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: object) -> int: ...

  @overload
  def compareTo(self, arg0: UUID) -> int: ...

  def equals(self, arg0: object) -> bool: ...

  def getLeastSignificantBits(self) -> int: ...

  def getMostSignificantBits(self) -> int: ...

  def hashCode(self) -> int: ...

  def node(self) -> int: ...

  def timestamp(self) -> int: ...

  def toString(self) -> str: ...

  def variant(self) -> int: ...

  def version(self) -> int: ...

  @staticmethod
  def fromString(arg0: str) -> UUID: ...

  @staticmethod
  def nameUUIDFromBytes(arg0: list[int]) -> UUID: ...

  @staticmethod
  def randomUUID() -> UUID: ...

  def __init__(self, arg0: int, arg1: int): ...

  class Holder: ...


class Vector[E](AbstractList):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  def addElement(self, arg0: object) -> None: ...

  def capacity(self) -> int: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def clone(self) -> object: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  def copyInto(self, arg0: list[object]) -> None: ...

  def elementAt(self, arg0: int) -> object: ...

  def elements(self) -> Enumeration[E]: ...

  def ensureCapacity(self, arg0: int) -> None: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  def firstElement(self) -> object: ...

  def forEach(self, arg0: Consumer[E]) -> None: ...

  @overload
  def get(self, arg0: int) -> object: ...

  @overload
  def get(self, arg0: int) -> object: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def indexOf(self, arg0: object) -> int: ...

  @overload
  def indexOf(self, arg0: object) -> int: ...

  @overload
  def indexOf(self, arg0: object, arg1: int) -> int: ...

  def insertElementAt(self, arg0: object, arg1: int) -> None: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  def lastElement(self) -> object: ...

  @overload
  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def lastIndexOf(self, arg0: object, arg1: int) -> int: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  @overload
  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  @overload
  def remove(self, arg0: int) -> object: ...

  @overload
  def remove(self, arg0: int) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def removeAllElements(self) -> None: ...

  def removeElement(self, arg0: object) -> bool: ...

  def removeElementAt(self, arg0: int) -> None: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  @overload
  def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

  @overload
  def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  def setElementAt(self, arg0: object, arg1: int) -> None: ...

  def setSize(self, arg0: int) -> None: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  @overload
  def sort(self, arg0: Comparator[E]) -> None: ...

  @overload
  def sort(self, arg0: Comparator[E]) -> None: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def subList(self, arg0: int, arg1: int) -> List[E]: ...

  @overload
  def subList(self, arg0: int, arg1: int) -> List[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  def toString(self) -> str: ...

  def trimToSize(self) -> None: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> List[E]: ...

  @staticmethod
  @overload
  def of() -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...
  @overload
  def __init__(self, arg0: int, arg1: int): ...

  class ListItr(Vector.Itr):

    @overload
    def add(self, arg0: object) -> None: ...

    @overload
    def add(self, arg0: object) -> None: ...

    def hasNext(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    def next(self) -> object: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def previousIndex(self) -> int: ...

    def remove(self) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

  class Itr:

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

  class VectorSpliterator:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[E]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator[E]: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...


class WeakHashMap[K, V](AbstractMap):

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def containsKey(self, arg0: object) -> bool: ...

  @overload
  def containsKey(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def containsValue(self, arg0: object) -> bool: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  @overload
  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  def equals(self, arg0: object) -> bool: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def get(self, arg0: object) -> object: ...

  @overload
  def get(self, arg0: object) -> object: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def hashCode(self) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def keySet(self) -> Set[K]: ...

  @overload
  def keySet(self) -> Set[K]: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def put(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putAll(self, arg0: Map[K, V]) -> None: ...

  @overload
  def putAll(self, arg0: Map[K, V]) -> None: ...

  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  @overload
  def values(self) -> Collection[V]: ...

  @overload
  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Map[K, V]): ...
  @overload
  def __init__(self, arg0: int, arg1: float): ...

  class Entry[Entry_K, Entry_V](WeakReference):

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    def toString(self) -> str: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  class KeySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[K]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[K]: ...

  class Values(AbstractCollection):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[V]: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[V]: ...

  class EntrySet(AbstractSet):

    def clear(self) -> None: ...

    def contains(self, arg0: object) -> bool: ...

    def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[Map.Entry[K, V]]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

  class EntrySpliterator[EntrySpliterator_K, EntrySpliterator_V](WeakHashMap.WeakHashMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Map.Entry[K, V]]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Map.Entry[K, V]]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> WeakHashMap.EntrySpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class ValueSpliterator[ValueSpliterator_K, ValueSpliterator_V](WeakHashMap.WeakHashMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[V]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[V]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> WeakHashMap.ValueSpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class KeySpliterator[KeySpliterator_K, KeySpliterator_V](WeakHashMap.WeakHashMapSpliterator):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[K]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[K]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> WeakHashMap.KeySpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class WeakHashMapSpliterator[WeakHashMapSpliterator_K, WeakHashMapSpliterator_V]:

    def estimateSize(self) -> int: ...

  class EntryIterator(WeakHashMap.HashIterator):

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

  class KeyIterator(WeakHashMap.HashIterator):

    def next(self) -> object: ...

  class ValueIterator(WeakHashMap.HashIterator):

    def next(self) -> object: ...

  class HashIterator[T]:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

