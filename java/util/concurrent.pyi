from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.lang import Runnable, Void, Throwable, Thread, RuntimeException, Boolean, Double, Long, Integer, Exception, ClassLoader, Enum
from java.time import Duration
from java.time.temporal import ChronoUnit
from java.util import Collection, List, AbstractMap, Enumeration, Set, Map, Comparator, Iterator, Spliterator, AbstractCollection, AbstractQueue, NavigableSet, NavigableMap, SortedMap, ListIterator
from java.util.concurrent.locks import ReentrantLock, AbstractQueuedSynchronizer
from java.util.function import Consumer, Function, Supplier, BiFunction, BiConsumer, ToDoubleFunction, DoubleBinaryOperator, ToIntFunction, IntBinaryOperator, ToLongFunction, LongBinaryOperator, ToDoubleBiFunction, ToIntBiFunction, ToLongBiFunction, Predicate, IntFunction, UnaryOperator
from java.util.stream import Stream

T = TypeVar('T', default=Any)
E = TypeVar('E', default=Any)
V = TypeVar('V', default=Any)
U = TypeVar('U', default=Any)
UniApply_T = TypeVar('UniApply_T', default=Any)
UniAccept_T = TypeVar('UniAccept_T', default=Any)
UniRun_T = TypeVar('UniRun_T', default=Any)
UniWhenComplete_T = TypeVar('UniWhenComplete_T', default=Any)
UniHandle_T = TypeVar('UniHandle_T', default=Any)
UniExceptionally_T = TypeVar('UniExceptionally_T', default=Any)
UniComposeExceptionally_T = TypeVar('UniComposeExceptionally_T', default=Any)
UniRelay_T = TypeVar('UniRelay_T', default=Any)
MinimalStage_T = TypeVar('MinimalStage_T', default=Any)
UniCompose_T = TypeVar('UniCompose_T', default=Any)
BiCompletion_T = TypeVar('BiCompletion_T', default=Any)
BiApply_T = TypeVar('BiApply_T', default=Any)
BiAccept_T = TypeVar('BiAccept_T', default=Any)
BiRun_T = TypeVar('BiRun_T', default=Any)
BiRelay_T = TypeVar('BiRelay_T', default=Any)
OrApply_T = TypeVar('OrApply_T', default=Any)
OrAccept_T = TypeVar('OrAccept_T', default=Any)
OrRun_T = TypeVar('OrRun_T', default=Any)
AsyncSupply_T = TypeVar('AsyncSupply_T', default=Any)
UniCompletion_T = TypeVar('UniCompletion_T', default=Any)
K = TypeVar('K', default=Any)
Node_K = TypeVar('Node_K', default=Any)
Node_V = TypeVar('Node_V', default=Any)
Traverser_K = TypeVar('Traverser_K', default=Any)
Traverser_V = TypeVar('Traverser_V', default=Any)
TreeBin_K = TypeVar('TreeBin_K', default=Any)
TreeBin_V = TypeVar('TreeBin_V', default=Any)
TreeNode_K = TypeVar('TreeNode_K', default=Any)
TreeNode_V = TypeVar('TreeNode_V', default=Any)
ReservationNode_K = TypeVar('ReservationNode_K', default=Any)
ReservationNode_V = TypeVar('ReservationNode_V', default=Any)
KeySetView_K = TypeVar('KeySetView_K', default=Any)
KeySetView_V = TypeVar('KeySetView_V', default=Any)
ValuesView_K = TypeVar('ValuesView_K', default=Any)
ValuesView_V = TypeVar('ValuesView_V', default=Any)
EntrySetView_K = TypeVar('EntrySetView_K', default=Any)
EntrySetView_V = TypeVar('EntrySetView_V', default=Any)
Segment_K = TypeVar('Segment_K', default=Any)
Segment_V = TypeVar('Segment_V', default=Any)
KeyIterator_K = TypeVar('KeyIterator_K', default=Any)
KeyIterator_V = TypeVar('KeyIterator_V', default=Any)
ValueIterator_K = TypeVar('ValueIterator_K', default=Any)
ValueIterator_V = TypeVar('ValueIterator_V', default=Any)
ForwardingNode_K = TypeVar('ForwardingNode_K', default=Any)
ForwardingNode_V = TypeVar('ForwardingNode_V', default=Any)
ForEachMappingTask_K = TypeVar('ForEachMappingTask_K', default=Any)
ForEachMappingTask_V = TypeVar('ForEachMappingTask_V', default=Any)
BulkTask_K = TypeVar('BulkTask_K', default=Any)
BulkTask_V = TypeVar('BulkTask_V', default=Any)
R = TypeVar('R', default=Any)
ForEachTransformedMappingTask_K = TypeVar('ForEachTransformedMappingTask_K', default=Any)
ForEachTransformedMappingTask_V = TypeVar('ForEachTransformedMappingTask_V', default=Any)
SearchMappingsTask_K = TypeVar('SearchMappingsTask_K', default=Any)
SearchMappingsTask_V = TypeVar('SearchMappingsTask_V', default=Any)
MapReduceMappingsTask_K = TypeVar('MapReduceMappingsTask_K', default=Any)
MapReduceMappingsTask_V = TypeVar('MapReduceMappingsTask_V', default=Any)
MapReduceMappingsToDoubleTask_K = TypeVar('MapReduceMappingsToDoubleTask_K', default=Any)
MapReduceMappingsToDoubleTask_V = TypeVar('MapReduceMappingsToDoubleTask_V', default=Any)
MapReduceMappingsToLongTask_K = TypeVar('MapReduceMappingsToLongTask_K', default=Any)
MapReduceMappingsToLongTask_V = TypeVar('MapReduceMappingsToLongTask_V', default=Any)
MapReduceMappingsToIntTask_K = TypeVar('MapReduceMappingsToIntTask_K', default=Any)
MapReduceMappingsToIntTask_V = TypeVar('MapReduceMappingsToIntTask_V', default=Any)
ForEachKeyTask_K = TypeVar('ForEachKeyTask_K', default=Any)
ForEachKeyTask_V = TypeVar('ForEachKeyTask_V', default=Any)
ForEachTransformedKeyTask_K = TypeVar('ForEachTransformedKeyTask_K', default=Any)
ForEachTransformedKeyTask_V = TypeVar('ForEachTransformedKeyTask_V', default=Any)
SearchKeysTask_K = TypeVar('SearchKeysTask_K', default=Any)
SearchKeysTask_V = TypeVar('SearchKeysTask_V', default=Any)
ReduceKeysTask_K = TypeVar('ReduceKeysTask_K', default=Any)
ReduceKeysTask_V = TypeVar('ReduceKeysTask_V', default=Any)
MapReduceKeysTask_K = TypeVar('MapReduceKeysTask_K', default=Any)
MapReduceKeysTask_V = TypeVar('MapReduceKeysTask_V', default=Any)
MapReduceKeysToDoubleTask_K = TypeVar('MapReduceKeysToDoubleTask_K', default=Any)
MapReduceKeysToDoubleTask_V = TypeVar('MapReduceKeysToDoubleTask_V', default=Any)
MapReduceKeysToLongTask_K = TypeVar('MapReduceKeysToLongTask_K', default=Any)
MapReduceKeysToLongTask_V = TypeVar('MapReduceKeysToLongTask_V', default=Any)
MapReduceKeysToIntTask_K = TypeVar('MapReduceKeysToIntTask_K', default=Any)
MapReduceKeysToIntTask_V = TypeVar('MapReduceKeysToIntTask_V', default=Any)
ForEachValueTask_K = TypeVar('ForEachValueTask_K', default=Any)
ForEachValueTask_V = TypeVar('ForEachValueTask_V', default=Any)
ForEachTransformedValueTask_K = TypeVar('ForEachTransformedValueTask_K', default=Any)
ForEachTransformedValueTask_V = TypeVar('ForEachTransformedValueTask_V', default=Any)
SearchValuesTask_K = TypeVar('SearchValuesTask_K', default=Any)
SearchValuesTask_V = TypeVar('SearchValuesTask_V', default=Any)
ReduceValuesTask_K = TypeVar('ReduceValuesTask_K', default=Any)
ReduceValuesTask_V = TypeVar('ReduceValuesTask_V', default=Any)
MapReduceValuesTask_K = TypeVar('MapReduceValuesTask_K', default=Any)
MapReduceValuesTask_V = TypeVar('MapReduceValuesTask_V', default=Any)
MapReduceValuesToDoubleTask_K = TypeVar('MapReduceValuesToDoubleTask_K', default=Any)
MapReduceValuesToDoubleTask_V = TypeVar('MapReduceValuesToDoubleTask_V', default=Any)
MapReduceValuesToLongTask_K = TypeVar('MapReduceValuesToLongTask_K', default=Any)
MapReduceValuesToLongTask_V = TypeVar('MapReduceValuesToLongTask_V', default=Any)
MapReduceValuesToIntTask_K = TypeVar('MapReduceValuesToIntTask_K', default=Any)
MapReduceValuesToIntTask_V = TypeVar('MapReduceValuesToIntTask_V', default=Any)
ForEachEntryTask_K = TypeVar('ForEachEntryTask_K', default=Any)
ForEachEntryTask_V = TypeVar('ForEachEntryTask_V', default=Any)
ForEachTransformedEntryTask_K = TypeVar('ForEachTransformedEntryTask_K', default=Any)
ForEachTransformedEntryTask_V = TypeVar('ForEachTransformedEntryTask_V', default=Any)
SearchEntriesTask_K = TypeVar('SearchEntriesTask_K', default=Any)
SearchEntriesTask_V = TypeVar('SearchEntriesTask_V', default=Any)
ReduceEntriesTask_K = TypeVar('ReduceEntriesTask_K', default=Any)
ReduceEntriesTask_V = TypeVar('ReduceEntriesTask_V', default=Any)
MapReduceEntriesTask_K = TypeVar('MapReduceEntriesTask_K', default=Any)
MapReduceEntriesTask_V = TypeVar('MapReduceEntriesTask_V', default=Any)
MapReduceEntriesToDoubleTask_K = TypeVar('MapReduceEntriesToDoubleTask_K', default=Any)
MapReduceEntriesToDoubleTask_V = TypeVar('MapReduceEntriesToDoubleTask_V', default=Any)
MapReduceEntriesToLongTask_K = TypeVar('MapReduceEntriesToLongTask_K', default=Any)
MapReduceEntriesToLongTask_V = TypeVar('MapReduceEntriesToLongTask_V', default=Any)
MapReduceEntriesToIntTask_K = TypeVar('MapReduceEntriesToIntTask_K', default=Any)
MapReduceEntriesToIntTask_V = TypeVar('MapReduceEntriesToIntTask_V', default=Any)
CollectionView_K = TypeVar('CollectionView_K', default=Any)
CollectionView_V = TypeVar('CollectionView_V', default=Any)
EntrySpliterator_K = TypeVar('EntrySpliterator_K', default=Any)
EntrySpliterator_V = TypeVar('EntrySpliterator_V', default=Any)
ValueSpliterator_K = TypeVar('ValueSpliterator_K', default=Any)
ValueSpliterator_V = TypeVar('ValueSpliterator_V', default=Any)
KeySpliterator_K = TypeVar('KeySpliterator_K', default=Any)
KeySpliterator_V = TypeVar('KeySpliterator_V', default=Any)
MapEntry_K = TypeVar('MapEntry_K', default=Any)
MapEntry_V = TypeVar('MapEntry_V', default=Any)
EntryIterator_K = TypeVar('EntryIterator_K', default=Any)
EntryIterator_V = TypeVar('EntryIterator_V', default=Any)
BaseIterator_K = TypeVar('BaseIterator_K', default=Any)
BaseIterator_V = TypeVar('BaseIterator_V', default=Any)
TableStack_K = TypeVar('TableStack_K', default=Any)
TableStack_V = TypeVar('TableStack_V', default=Any)
Node_E = TypeVar('Node_E', default=Any)
COWIterator_E = TypeVar('COWIterator_E', default=Any)
COWSubListIterator_E = TypeVar('COWSubListIterator_E', default=Any)

class AbstractExecutorService:

  def awaitTermination(self, arg0: int, arg1: TimeUnit) -> bool: ...

  @overload
  def invokeAll(self, arg0: Collection[Callable[T]]) -> List[Future[T]]: ...

  @overload
  def invokeAll(self, arg0: Collection[Callable[T]]) -> List[Future[T]]: ...

  @overload
  def invokeAll(self, arg0: Collection[Callable[T]], arg1: int, arg2: TimeUnit) -> List[Future[T]]: ...

  @overload
  def invokeAll(self, arg0: Collection[Callable[T]], arg1: int, arg2: TimeUnit) -> List[Future[T]]: ...

  @overload
  def invokeAny(self, arg0: Collection[Callable[T]]) -> object: ...

  @overload
  def invokeAny(self, arg0: Collection[Callable[T]]) -> object: ...

  @overload
  def invokeAny(self, arg0: Collection[Callable[T]], arg1: int, arg2: TimeUnit) -> object: ...

  @overload
  def invokeAny(self, arg0: Collection[Callable[T]], arg1: int, arg2: TimeUnit) -> object: ...

  def isShutdown(self) -> bool: ...

  def isTerminated(self) -> bool: ...

  def shutdown(self) -> None: ...

  def shutdownNow(self) -> List[Runnable]: ...

  @overload
  def submit(self, arg0: Runnable) -> Future[Any]: ...

  @overload
  def submit(self, arg0: Runnable) -> Future[Any]: ...

  @overload
  def submit(self, arg0: Callable[T]) -> Future[T]: ...

  @overload
  def submit(self, arg0: Callable[T]) -> Future[T]: ...

  @overload
  def submit(self, arg0: Runnable, arg1: object) -> Future[T]: ...

  @overload
  def submit(self, arg0: Runnable, arg1: object) -> Future[T]: ...

  def __init__(self): ...


class BlockingQueue[E]:

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  def contains(self, arg0: object) -> bool: ...

  @overload
  def drainTo(self, arg0: Collection[E]) -> int: ...

  @overload
  def drainTo(self, arg0: Collection[E], arg1: int) -> int: ...

  def element(self) -> object: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offer(self, arg0: object, arg1: int, arg2: TimeUnit) -> bool: ...

  def peek(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def poll(self, arg0: int, arg1: TimeUnit) -> object: ...

  def put(self, arg0: object) -> None: ...

  def remainingCapacity(self) -> int: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  def take(self) -> object: ...


class Callable[V]:

  def call(self) -> object: ...


class CompletableFuture[T]:

  @overload
  def acceptEither(self, arg0: CompletionStage[T], arg1: Consumer[T]) -> CompletableFuture[Void]: ...

  @overload
  def acceptEither(self, arg0: CompletionStage, arg1: Consumer) -> CompletionStage: ...

  @overload
  def acceptEither(self, arg0: CompletionStage[T], arg1: Consumer[T]) -> CompletionStage[Void]: ...

  @overload
  def acceptEitherAsync(self, arg0: CompletionStage[T], arg1: Consumer[T]) -> CompletableFuture[Void]: ...

  @overload
  def acceptEitherAsync(self, arg0: CompletionStage, arg1: Consumer) -> CompletionStage: ...

  @overload
  def acceptEitherAsync(self, arg0: CompletionStage[T], arg1: Consumer[T]) -> CompletionStage[Void]: ...

  @overload
  def acceptEitherAsync(self, arg0: CompletionStage[T], arg1: Consumer[T], arg2: Executor) -> CompletableFuture[Void]: ...

  @overload
  def acceptEitherAsync(self, arg0: CompletionStage, arg1: Consumer, arg2: Executor) -> CompletionStage: ...

  @overload
  def acceptEitherAsync(self, arg0: CompletionStage[T], arg1: Consumer[T], arg2: Executor) -> CompletionStage[Void]: ...

  @overload
  def applyToEither(self, arg0: CompletionStage, arg1: Function) -> CompletionStage: ...

  @overload
  def applyToEither(self, arg0: CompletionStage[T], arg1: Function[T, U]) -> CompletableFuture[U]: ...

  @overload
  def applyToEither(self, arg0: CompletionStage[T], arg1: Function[T, U]) -> CompletionStage[U]: ...

  @overload
  def applyToEitherAsync(self, arg0: CompletionStage, arg1: Function) -> CompletionStage: ...

  @overload
  def applyToEitherAsync(self, arg0: CompletionStage[T], arg1: Function[T, U]) -> CompletableFuture[U]: ...

  @overload
  def applyToEitherAsync(self, arg0: CompletionStage[T], arg1: Function[T, U]) -> CompletionStage[U]: ...

  @overload
  def applyToEitherAsync(self, arg0: CompletionStage[T], arg1: Function[T, U], arg2: Executor) -> CompletableFuture[U]: ...

  @overload
  def applyToEitherAsync(self, arg0: CompletionStage, arg1: Function, arg2: Executor) -> CompletionStage: ...

  @overload
  def applyToEitherAsync(self, arg0: CompletionStage[T], arg1: Function[T, U], arg2: Executor) -> CompletionStage[U]: ...

  @overload
  def cancel(self, arg0: bool) -> bool: ...

  @overload
  def cancel(self, arg0: bool) -> bool: ...

  def complete(self, arg0: object) -> bool: ...

  @overload
  def completeAsync(self, arg0: Supplier[T]) -> CompletableFuture[T]: ...

  @overload
  def completeAsync(self, arg0: Supplier[T], arg1: Executor) -> CompletableFuture[T]: ...

  def completeExceptionally(self, arg0: Throwable) -> bool: ...

  def completeOnTimeout(self, arg0: object, arg1: int, arg2: TimeUnit) -> CompletableFuture[T]: ...

  def copy(self) -> CompletableFuture[T]: ...

  def defaultExecutor(self) -> Executor: ...

  @overload
  def exceptionally(self, arg0: Function[Throwable, T]) -> CompletableFuture[T]: ...

  @overload
  def exceptionally(self, arg0: Function) -> CompletionStage: ...

  @overload
  def exceptionally(self, arg0: Function[Throwable, T]) -> CompletionStage[T]: ...

  @overload
  def exceptionallyAsync(self, arg0: Function[Throwable, T]) -> CompletableFuture[T]: ...

  @overload
  def exceptionallyAsync(self, arg0: Function) -> CompletionStage: ...

  @overload
  def exceptionallyAsync(self, arg0: Function[Throwable, T]) -> CompletionStage[T]: ...

  @overload
  def exceptionallyAsync(self, arg0: Function[Throwable, T], arg1: Executor) -> CompletableFuture[T]: ...

  @overload
  def exceptionallyAsync(self, arg0: Function, arg1: Executor) -> CompletionStage: ...

  @overload
  def exceptionallyAsync(self, arg0: Function[Throwable, T], arg1: Executor) -> CompletionStage[T]: ...

  @overload
  def exceptionallyCompose(self, arg0: Function) -> CompletionStage: ...

  @overload
  def exceptionallyCompose(self, arg0: Function[Throwable, CompletionStage[T]]) -> CompletableFuture[T]: ...

  @overload
  def exceptionallyCompose(self, arg0: Function[Throwable, CompletionStage[T]]) -> CompletionStage[T]: ...

  @overload
  def exceptionallyComposeAsync(self, arg0: Function[Throwable, CompletionStage[T]]) -> CompletableFuture[T]: ...

  @overload
  def exceptionallyComposeAsync(self, arg0: Function) -> CompletionStage: ...

  @overload
  def exceptionallyComposeAsync(self, arg0: Function[Throwable, CompletionStage[T]]) -> CompletionStage[T]: ...

  @overload
  def exceptionallyComposeAsync(self, arg0: Function[Throwable, CompletionStage[T]], arg1: Executor) -> CompletableFuture[T]: ...

  @overload
  def exceptionallyComposeAsync(self, arg0: Function, arg1: Executor) -> CompletionStage: ...

  @overload
  def exceptionallyComposeAsync(self, arg0: Function[Throwable, CompletionStage[T]], arg1: Executor) -> CompletionStage[T]: ...

  @overload
  def get(self) -> object: ...

  @overload
  def get(self) -> object: ...

  @overload
  def get(self, arg0: int, arg1: TimeUnit) -> object: ...

  @overload
  def get(self, arg0: int, arg1: TimeUnit) -> object: ...

  def getNow(self, arg0: object) -> object: ...

  def getNumberOfDependents(self) -> int: ...

  @overload
  def handle(self, arg0: BiFunction[T, Throwable, U]) -> CompletableFuture[U]: ...

  @overload
  def handle(self, arg0: BiFunction) -> CompletionStage: ...

  @overload
  def handle(self, arg0: BiFunction[T, Throwable, U]) -> CompletionStage[U]: ...

  @overload
  def handleAsync(self, arg0: BiFunction) -> CompletionStage: ...

  @overload
  def handleAsync(self, arg0: BiFunction[T, Throwable, U]) -> CompletableFuture[U]: ...

  @overload
  def handleAsync(self, arg0: BiFunction[T, Throwable, U]) -> CompletionStage[U]: ...

  @overload
  def handleAsync(self, arg0: BiFunction, arg1: Executor) -> CompletionStage: ...

  @overload
  def handleAsync(self, arg0: BiFunction[T, Throwable, U], arg1: Executor) -> CompletableFuture[U]: ...

  @overload
  def handleAsync(self, arg0: BiFunction[T, Throwable, U], arg1: Executor) -> CompletionStage[U]: ...

  @overload
  def isCancelled(self) -> bool: ...

  @overload
  def isCancelled(self) -> bool: ...

  def isCompletedExceptionally(self) -> bool: ...

  @overload
  def isDone(self) -> bool: ...

  @overload
  def isDone(self) -> bool: ...

  def join(self) -> object: ...

  def minimalCompletionStage(self) -> CompletionStage[T]: ...

  def newIncompleteFuture(self) -> CompletableFuture[U]: ...

  def obtrudeException(self, arg0: Throwable) -> None: ...

  def obtrudeValue(self, arg0: object) -> None: ...

  def orTimeout(self, arg0: int, arg1: TimeUnit) -> CompletableFuture[T]: ...

  @overload
  def runAfterBoth(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletableFuture[Void]: ...

  @overload
  def runAfterBoth(self, arg0: CompletionStage, arg1: Runnable) -> CompletionStage: ...

  @overload
  def runAfterBoth(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletionStage[Void]: ...

  @overload
  def runAfterBothAsync(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletableFuture[Void]: ...

  @overload
  def runAfterBothAsync(self, arg0: CompletionStage, arg1: Runnable) -> CompletionStage: ...

  @overload
  def runAfterBothAsync(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletionStage[Void]: ...

  @overload
  def runAfterBothAsync(self, arg0: CompletionStage[Any], arg1: Runnable, arg2: Executor) -> CompletableFuture[Void]: ...

  @overload
  def runAfterBothAsync(self, arg0: CompletionStage, arg1: Runnable, arg2: Executor) -> CompletionStage: ...

  @overload
  def runAfterBothAsync(self, arg0: CompletionStage[Any], arg1: Runnable, arg2: Executor) -> CompletionStage[Void]: ...

  @overload
  def runAfterEither(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletableFuture[Void]: ...

  @overload
  def runAfterEither(self, arg0: CompletionStage, arg1: Runnable) -> CompletionStage: ...

  @overload
  def runAfterEither(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletionStage[Void]: ...

  @overload
  def runAfterEitherAsync(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletableFuture[Void]: ...

  @overload
  def runAfterEitherAsync(self, arg0: CompletionStage, arg1: Runnable) -> CompletionStage: ...

  @overload
  def runAfterEitherAsync(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletionStage[Void]: ...

  @overload
  def runAfterEitherAsync(self, arg0: CompletionStage, arg1: Runnable, arg2: Executor) -> CompletionStage: ...

  @overload
  def runAfterEitherAsync(self, arg0: CompletionStage[Any], arg1: Runnable, arg2: Executor) -> CompletableFuture[Void]: ...

  @overload
  def runAfterEitherAsync(self, arg0: CompletionStage[Any], arg1: Runnable, arg2: Executor) -> CompletionStage[Void]: ...

  @overload
  def thenAccept(self, arg0: Consumer) -> CompletionStage: ...

  @overload
  def thenAccept(self, arg0: Consumer[T]) -> CompletableFuture[Void]: ...

  @overload
  def thenAccept(self, arg0: Consumer[T]) -> CompletionStage[Void]: ...

  @overload
  def thenAcceptAsync(self, arg0: Consumer) -> CompletionStage: ...

  @overload
  def thenAcceptAsync(self, arg0: Consumer[T]) -> CompletableFuture[Void]: ...

  @overload
  def thenAcceptAsync(self, arg0: Consumer[T]) -> CompletionStage[Void]: ...

  @overload
  def thenAcceptAsync(self, arg0: Consumer[T], arg1: Executor) -> CompletableFuture[Void]: ...

  @overload
  def thenAcceptAsync(self, arg0: Consumer, arg1: Executor) -> CompletionStage: ...

  @overload
  def thenAcceptAsync(self, arg0: Consumer[T], arg1: Executor) -> CompletionStage[Void]: ...

  @overload
  def thenAcceptBoth(self, arg0: CompletionStage, arg1: BiConsumer) -> CompletionStage: ...

  @overload
  def thenAcceptBoth(self, arg0: CompletionStage[U], arg1: BiConsumer[T, U]) -> CompletableFuture[Void]: ...

  @overload
  def thenAcceptBoth(self, arg0: CompletionStage[U], arg1: BiConsumer[T, U]) -> CompletionStage[Void]: ...

  @overload
  def thenAcceptBothAsync(self, arg0: CompletionStage[U], arg1: BiConsumer[T, U]) -> CompletableFuture[Void]: ...

  @overload
  def thenAcceptBothAsync(self, arg0: CompletionStage, arg1: BiConsumer) -> CompletionStage: ...

  @overload
  def thenAcceptBothAsync(self, arg0: CompletionStage[U], arg1: BiConsumer[T, U]) -> CompletionStage[Void]: ...

  @overload
  def thenAcceptBothAsync(self, arg0: CompletionStage[U], arg1: BiConsumer[T, U], arg2: Executor) -> CompletableFuture[Void]: ...

  @overload
  def thenAcceptBothAsync(self, arg0: CompletionStage, arg1: BiConsumer, arg2: Executor) -> CompletionStage: ...

  @overload
  def thenAcceptBothAsync(self, arg0: CompletionStage[U], arg1: BiConsumer[T, U], arg2: Executor) -> CompletionStage[Void]: ...

  @overload
  def thenApply(self, arg0: Function[T, U]) -> CompletableFuture[U]: ...

  @overload
  def thenApply(self, arg0: Function) -> CompletionStage: ...

  @overload
  def thenApply(self, arg0: Function[T, U]) -> CompletionStage[U]: ...

  @overload
  def thenApplyAsync(self, arg0: Function[T, U]) -> CompletableFuture[U]: ...

  @overload
  def thenApplyAsync(self, arg0: Function) -> CompletionStage: ...

  @overload
  def thenApplyAsync(self, arg0: Function[T, U]) -> CompletionStage[U]: ...

  @overload
  def thenApplyAsync(self, arg0: Function, arg1: Executor) -> CompletionStage: ...

  @overload
  def thenApplyAsync(self, arg0: Function[T, U], arg1: Executor) -> CompletableFuture[U]: ...

  @overload
  def thenApplyAsync(self, arg0: Function[T, U], arg1: Executor) -> CompletionStage[U]: ...

  @overload
  def thenCombine(self, arg0: CompletionStage, arg1: BiFunction) -> CompletionStage: ...

  @overload
  def thenCombine(self, arg0: CompletionStage[U], arg1: BiFunction[T, U, V]) -> CompletableFuture[V]: ...

  @overload
  def thenCombine(self, arg0: CompletionStage[U], arg1: BiFunction[T, U, V]) -> CompletionStage[V]: ...

  @overload
  def thenCombineAsync(self, arg0: CompletionStage[U], arg1: BiFunction[T, U, V]) -> CompletableFuture[V]: ...

  @overload
  def thenCombineAsync(self, arg0: CompletionStage, arg1: BiFunction) -> CompletionStage: ...

  @overload
  def thenCombineAsync(self, arg0: CompletionStage[U], arg1: BiFunction[T, U, V]) -> CompletionStage[V]: ...

  @overload
  def thenCombineAsync(self, arg0: CompletionStage[U], arg1: BiFunction[T, U, V], arg2: Executor) -> CompletableFuture[V]: ...

  @overload
  def thenCombineAsync(self, arg0: CompletionStage, arg1: BiFunction, arg2: Executor) -> CompletionStage: ...

  @overload
  def thenCombineAsync(self, arg0: CompletionStage[U], arg1: BiFunction[T, U, V], arg2: Executor) -> CompletionStage[V]: ...

  @overload
  def thenCompose(self, arg0: Function) -> CompletionStage: ...

  @overload
  def thenCompose(self, arg0: Function[T, CompletionStage[U]]) -> CompletableFuture[U]: ...

  @overload
  def thenCompose(self, arg0: Function[T, CompletionStage[U]]) -> CompletionStage[U]: ...

  @overload
  def thenComposeAsync(self, arg0: Function) -> CompletionStage: ...

  @overload
  def thenComposeAsync(self, arg0: Function[T, CompletionStage[U]]) -> CompletableFuture[U]: ...

  @overload
  def thenComposeAsync(self, arg0: Function[T, CompletionStage[U]]) -> CompletionStage[U]: ...

  @overload
  def thenComposeAsync(self, arg0: Function, arg1: Executor) -> CompletionStage: ...

  @overload
  def thenComposeAsync(self, arg0: Function[T, CompletionStage[U]], arg1: Executor) -> CompletableFuture[U]: ...

  @overload
  def thenComposeAsync(self, arg0: Function[T, CompletionStage[U]], arg1: Executor) -> CompletionStage[U]: ...

  @overload
  def thenRun(self, arg0: Runnable) -> CompletableFuture[Void]: ...

  @overload
  def thenRun(self, arg0: Runnable) -> CompletionStage: ...

  @overload
  def thenRun(self, arg0: Runnable) -> CompletionStage[Void]: ...

  @overload
  def thenRunAsync(self, arg0: Runnable) -> CompletionStage: ...

  @overload
  def thenRunAsync(self, arg0: Runnable) -> CompletableFuture[Void]: ...

  @overload
  def thenRunAsync(self, arg0: Runnable) -> CompletionStage[Void]: ...

  @overload
  def thenRunAsync(self, arg0: Runnable, arg1: Executor) -> CompletionStage: ...

  @overload
  def thenRunAsync(self, arg0: Runnable, arg1: Executor) -> CompletableFuture[Void]: ...

  @overload
  def thenRunAsync(self, arg0: Runnable, arg1: Executor) -> CompletionStage[Void]: ...

  @overload
  def toCompletableFuture(self) -> CompletableFuture[T]: ...

  @overload
  def toCompletableFuture(self) -> CompletableFuture[T]: ...

  def toString(self) -> str: ...

  @overload
  def whenComplete(self, arg0: BiConsumer) -> CompletionStage: ...

  @overload
  def whenComplete(self, arg0: BiConsumer[T, Throwable]) -> CompletableFuture[T]: ...

  @overload
  def whenComplete(self, arg0: BiConsumer[T, Throwable]) -> CompletionStage[T]: ...

  @overload
  def whenCompleteAsync(self, arg0: BiConsumer) -> CompletionStage: ...

  @overload
  def whenCompleteAsync(self, arg0: BiConsumer[T, Throwable]) -> CompletableFuture[T]: ...

  @overload
  def whenCompleteAsync(self, arg0: BiConsumer[T, Throwable]) -> CompletionStage[T]: ...

  @overload
  def whenCompleteAsync(self, arg0: BiConsumer, arg1: Executor) -> CompletionStage: ...

  @overload
  def whenCompleteAsync(self, arg0: BiConsumer[T, Throwable], arg1: Executor) -> CompletableFuture[T]: ...

  @overload
  def whenCompleteAsync(self, arg0: BiConsumer[T, Throwable], arg1: Executor) -> CompletionStage[T]: ...

  @staticmethod
  def allOf(arg0: list[CompletableFuture]) -> CompletableFuture[Void]: ...

  @staticmethod
  def anyOf(arg0: list[CompletableFuture]) -> CompletableFuture[object]: ...

  @staticmethod
  def completedFuture(arg0: object) -> CompletableFuture[U]: ...

  @staticmethod
  def completedStage(arg0: object) -> CompletionStage[U]: ...

  @staticmethod
  @overload
  def delayedExecutor(arg0: int, arg1: TimeUnit) -> Executor: ...

  @staticmethod
  @overload
  def delayedExecutor(arg0: int, arg1: TimeUnit, arg2: Executor) -> Executor: ...

  @staticmethod
  def failedFuture(arg0: Throwable) -> CompletableFuture[U]: ...

  @staticmethod
  def failedStage(arg0: Throwable) -> CompletionStage[U]: ...

  @staticmethod
  @overload
  def runAsync(arg0: Runnable) -> CompletableFuture[Void]: ...

  @staticmethod
  @overload
  def runAsync(arg0: Runnable, arg1: Executor) -> CompletableFuture[Void]: ...

  @staticmethod
  @overload
  def supplyAsync(arg0: Supplier[U]) -> CompletableFuture[U]: ...

  @staticmethod
  @overload
  def supplyAsync(arg0: Supplier[U], arg1: Executor) -> CompletableFuture[U]: ...

  def __init__(self): ...

  class Completion(ForkJoinTask):

    def exec(self) -> bool: ...

    @overload
    def getRawResult(self) -> Void: ...

    @overload
    def getRawResult(self) -> object: ...

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...

    @overload
    def setRawResult(self, arg0: object) -> None: ...

    @overload
    def setRawResult(self, arg0: Void) -> None: ...

  class AltResult: ...

  class UniApply[UniApply_T, V](CompletableFuture.UniCompletion): ...

  class UniAccept[UniAccept_T](CompletableFuture.UniCompletion): ...

  class UniRun[UniRun_T](CompletableFuture.UniCompletion): ...

  class UniWhenComplete[UniWhenComplete_T](CompletableFuture.UniCompletion): ...

  class UniHandle[UniHandle_T, V](CompletableFuture.UniCompletion): ...

  class UniExceptionally[UniExceptionally_T](CompletableFuture.UniCompletion): ...

  class UniComposeExceptionally[UniComposeExceptionally_T](CompletableFuture.UniCompletion): ...

  class UniRelay[U, UniRelay_T](CompletableFuture.UniCompletion): ...

  class MinimalStage[MinimalStage_T](CompletableFuture):

    def acceptEither(self, arg0: CompletionStage, arg1: Consumer) -> CompletionStage: ...

    @overload
    def acceptEitherAsync(self, arg0: CompletionStage, arg1: Consumer) -> CompletionStage: ...

    @overload
    def acceptEitherAsync(self, arg0: CompletionStage, arg1: Consumer, arg2: Executor) -> CompletionStage: ...

    def applyToEither(self, arg0: CompletionStage, arg1: Function) -> CompletionStage: ...

    @overload
    def applyToEitherAsync(self, arg0: CompletionStage, arg1: Function) -> CompletionStage: ...

    @overload
    def applyToEitherAsync(self, arg0: CompletionStage, arg1: Function, arg2: Executor) -> CompletionStage: ...

    def cancel(self, arg0: bool) -> bool: ...

    def complete(self, arg0: object) -> bool: ...

    @overload
    def completeAsync(self, arg0: Supplier[T]) -> CompletableFuture[T]: ...

    @overload
    def completeAsync(self, arg0: Supplier[T], arg1: Executor) -> CompletableFuture[T]: ...

    def completeExceptionally(self, arg0: Throwable) -> bool: ...

    def completeOnTimeout(self, arg0: object, arg1: int, arg2: TimeUnit) -> CompletableFuture[T]: ...

    def exceptionally(self, arg0: Function) -> CompletionStage: ...

    @overload
    def exceptionallyAsync(self, arg0: Function) -> CompletionStage: ...

    @overload
    def exceptionallyAsync(self, arg0: Function, arg1: Executor) -> CompletionStage: ...

    def exceptionallyCompose(self, arg0: Function) -> CompletionStage: ...

    @overload
    def exceptionallyComposeAsync(self, arg0: Function) -> CompletionStage: ...

    @overload
    def exceptionallyComposeAsync(self, arg0: Function, arg1: Executor) -> CompletionStage: ...

    @overload
    def get(self) -> object: ...

    @overload
    def get(self, arg0: int, arg1: TimeUnit) -> object: ...

    def getNow(self, arg0: object) -> object: ...

    def getNumberOfDependents(self) -> int: ...

    def handle(self, arg0: BiFunction) -> CompletionStage: ...

    @overload
    def handleAsync(self, arg0: BiFunction) -> CompletionStage: ...

    @overload
    def handleAsync(self, arg0: BiFunction, arg1: Executor) -> CompletionStage: ...

    def isCancelled(self) -> bool: ...

    def isCompletedExceptionally(self) -> bool: ...

    def isDone(self) -> bool: ...

    def join(self) -> object: ...

    def newIncompleteFuture(self) -> CompletableFuture[U]: ...

    def obtrudeException(self, arg0: Throwable) -> None: ...

    def obtrudeValue(self, arg0: object) -> None: ...

    def orTimeout(self, arg0: int, arg1: TimeUnit) -> CompletableFuture[T]: ...

    def runAfterBoth(self, arg0: CompletionStage, arg1: Runnable) -> CompletionStage: ...

    @overload
    def runAfterBothAsync(self, arg0: CompletionStage, arg1: Runnable) -> CompletionStage: ...

    @overload
    def runAfterBothAsync(self, arg0: CompletionStage, arg1: Runnable, arg2: Executor) -> CompletionStage: ...

    def runAfterEither(self, arg0: CompletionStage, arg1: Runnable) -> CompletionStage: ...

    @overload
    def runAfterEitherAsync(self, arg0: CompletionStage, arg1: Runnable) -> CompletionStage: ...

    @overload
    def runAfterEitherAsync(self, arg0: CompletionStage, arg1: Runnable, arg2: Executor) -> CompletionStage: ...

    def thenAccept(self, arg0: Consumer) -> CompletionStage: ...

    @overload
    def thenAcceptAsync(self, arg0: Consumer) -> CompletionStage: ...

    @overload
    def thenAcceptAsync(self, arg0: Consumer, arg1: Executor) -> CompletionStage: ...

    def thenAcceptBoth(self, arg0: CompletionStage, arg1: BiConsumer) -> CompletionStage: ...

    @overload
    def thenAcceptBothAsync(self, arg0: CompletionStage, arg1: BiConsumer) -> CompletionStage: ...

    @overload
    def thenAcceptBothAsync(self, arg0: CompletionStage, arg1: BiConsumer, arg2: Executor) -> CompletionStage: ...

    def thenApply(self, arg0: Function) -> CompletionStage: ...

    @overload
    def thenApplyAsync(self, arg0: Function) -> CompletionStage: ...

    @overload
    def thenApplyAsync(self, arg0: Function, arg1: Executor) -> CompletionStage: ...

    def thenCombine(self, arg0: CompletionStage, arg1: BiFunction) -> CompletionStage: ...

    @overload
    def thenCombineAsync(self, arg0: CompletionStage, arg1: BiFunction) -> CompletionStage: ...

    @overload
    def thenCombineAsync(self, arg0: CompletionStage, arg1: BiFunction, arg2: Executor) -> CompletionStage: ...

    def thenCompose(self, arg0: Function) -> CompletionStage: ...

    @overload
    def thenComposeAsync(self, arg0: Function) -> CompletionStage: ...

    @overload
    def thenComposeAsync(self, arg0: Function, arg1: Executor) -> CompletionStage: ...

    def thenRun(self, arg0: Runnable) -> CompletionStage: ...

    @overload
    def thenRunAsync(self, arg0: Runnable) -> CompletionStage: ...

    @overload
    def thenRunAsync(self, arg0: Runnable, arg1: Executor) -> CompletionStage: ...

    def toCompletableFuture(self) -> CompletableFuture[T]: ...

    def whenComplete(self, arg0: BiConsumer) -> CompletionStage: ...

    @overload
    def whenCompleteAsync(self, arg0: BiConsumer) -> CompletionStage: ...

    @overload
    def whenCompleteAsync(self, arg0: BiConsumer, arg1: Executor) -> CompletionStage: ...

  class UniCompose[UniCompose_T, V](CompletableFuture.UniCompletion): ...

  class CoCompletion(CompletableFuture.Completion): ...

  class BiCompletion[BiCompletion_T, U, V](CompletableFuture.UniCompletion): ...

  class BiApply[BiApply_T, U, V](CompletableFuture.BiCompletion): ...

  class BiAccept[BiAccept_T, U](CompletableFuture.BiCompletion): ...

  class BiRun[BiRun_T, U](CompletableFuture.BiCompletion): ...

  class BiRelay[BiRelay_T, U](CompletableFuture.BiCompletion): ...

  class OrApply[OrApply_T, U, V](CompletableFuture.BiCompletion): ...

  class OrAccept[OrAccept_T, U](CompletableFuture.BiCompletion): ...

  class OrRun[OrRun_T, U](CompletableFuture.BiCompletion): ...

  class AsyncSupply[AsyncSupply_T](ForkJoinTask):

    def exec(self) -> bool: ...

    @overload
    def getRawResult(self) -> Void: ...

    @overload
    def getRawResult(self) -> object: ...

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...

    @overload
    def setRawResult(self, arg0: object) -> None: ...

    @overload
    def setRawResult(self, arg0: Void) -> None: ...

  class AsyncRun(ForkJoinTask):

    def exec(self) -> bool: ...

    @overload
    def getRawResult(self) -> Void: ...

    @overload
    def getRawResult(self) -> object: ...

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...

    @overload
    def setRawResult(self, arg0: object) -> None: ...

    @overload
    def setRawResult(self, arg0: Void) -> None: ...

  class Signaller(CompletableFuture.Completion):

    @overload
    def block(self) -> bool: ...

    @overload
    def block(self) -> bool: ...

    @overload
    def isReleasable(self) -> bool: ...

    @overload
    def isReleasable(self) -> bool: ...

  class AnyOf(CompletableFuture.Completion): ...

  class Canceller:

    @overload
    def accept(self, arg0: object, arg1: object) -> None: ...

    @overload
    def accept(self, arg0: object, arg1: object) -> None: ...

    @overload
    def accept(self, arg0: object, arg1: Throwable) -> None: ...

    def andThen(self, arg0: BiConsumer[T, U]) -> BiConsumer[T, U]: ...

  class Timeout:

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...

  class Delayer:

    class DaemonThreadFactory:

      @overload
      def newThread(self, arg0: Runnable) -> Thread: ...

      @overload
      def newThread(self, arg0: Runnable) -> Thread: ...

  class DelayedCompleter[U]:

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...

  class DelayedExecutor:

    @overload
    def execute(self, arg0: Runnable) -> None: ...

    @overload
    def execute(self, arg0: Runnable) -> None: ...

  class ThreadPerTaskExecutor:

    @overload
    def execute(self, arg0: Runnable) -> None: ...

    @overload
    def execute(self, arg0: Runnable) -> None: ...

  class TaskSubmitter:

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...

  class UniCompletion[UniCompletion_T, V](CompletableFuture.Completion): ...

  class AsynchronousCompletionTask: ...


class CompletionException(RuntimeException):

  @overload
  def __init__(self, arg0: Throwable): ...
  @overload
  def __init__(self, arg0: str, arg1: Throwable): ...


class CompletionStage[T]:

  def acceptEither(self, arg0: CompletionStage[T], arg1: Consumer[T]) -> CompletionStage[Void]: ...

  @overload
  def acceptEitherAsync(self, arg0: CompletionStage[T], arg1: Consumer[T]) -> CompletionStage[Void]: ...

  @overload
  def acceptEitherAsync(self, arg0: CompletionStage[T], arg1: Consumer[T], arg2: Executor) -> CompletionStage[Void]: ...

  def applyToEither(self, arg0: CompletionStage[T], arg1: Function[T, U]) -> CompletionStage[U]: ...

  @overload
  def applyToEitherAsync(self, arg0: CompletionStage[T], arg1: Function[T, U]) -> CompletionStage[U]: ...

  @overload
  def applyToEitherAsync(self, arg0: CompletionStage[T], arg1: Function[T, U], arg2: Executor) -> CompletionStage[U]: ...

  def exceptionally(self, arg0: Function[Throwable, T]) -> CompletionStage[T]: ...

  @overload
  def exceptionallyAsync(self, arg0: Function[Throwable, T]) -> CompletionStage[T]: ...

  @overload
  def exceptionallyAsync(self, arg0: Function[Throwable, T], arg1: Executor) -> CompletionStage[T]: ...

  def exceptionallyCompose(self, arg0: Function[Throwable, CompletionStage[T]]) -> CompletionStage[T]: ...

  @overload
  def exceptionallyComposeAsync(self, arg0: Function[Throwable, CompletionStage[T]]) -> CompletionStage[T]: ...

  @overload
  def exceptionallyComposeAsync(self, arg0: Function[Throwable, CompletionStage[T]], arg1: Executor) -> CompletionStage[T]: ...

  def handle(self, arg0: BiFunction[T, Throwable, U]) -> CompletionStage[U]: ...

  @overload
  def handleAsync(self, arg0: BiFunction[T, Throwable, U]) -> CompletionStage[U]: ...

  @overload
  def handleAsync(self, arg0: BiFunction[T, Throwable, U], arg1: Executor) -> CompletionStage[U]: ...

  def runAfterBoth(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletionStage[Void]: ...

  @overload
  def runAfterBothAsync(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletionStage[Void]: ...

  @overload
  def runAfterBothAsync(self, arg0: CompletionStage[Any], arg1: Runnable, arg2: Executor) -> CompletionStage[Void]: ...

  def runAfterEither(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletionStage[Void]: ...

  @overload
  def runAfterEitherAsync(self, arg0: CompletionStage[Any], arg1: Runnable) -> CompletionStage[Void]: ...

  @overload
  def runAfterEitherAsync(self, arg0: CompletionStage[Any], arg1: Runnable, arg2: Executor) -> CompletionStage[Void]: ...

  def thenAccept(self, arg0: Consumer[T]) -> CompletionStage[Void]: ...

  @overload
  def thenAcceptAsync(self, arg0: Consumer[T]) -> CompletionStage[Void]: ...

  @overload
  def thenAcceptAsync(self, arg0: Consumer[T], arg1: Executor) -> CompletionStage[Void]: ...

  def thenAcceptBoth(self, arg0: CompletionStage[U], arg1: BiConsumer[T, U]) -> CompletionStage[Void]: ...

  @overload
  def thenAcceptBothAsync(self, arg0: CompletionStage[U], arg1: BiConsumer[T, U]) -> CompletionStage[Void]: ...

  @overload
  def thenAcceptBothAsync(self, arg0: CompletionStage[U], arg1: BiConsumer[T, U], arg2: Executor) -> CompletionStage[Void]: ...

  def thenApply(self, arg0: Function[T, U]) -> CompletionStage[U]: ...

  @overload
  def thenApplyAsync(self, arg0: Function[T, U]) -> CompletionStage[U]: ...

  @overload
  def thenApplyAsync(self, arg0: Function[T, U], arg1: Executor) -> CompletionStage[U]: ...

  def thenCombine(self, arg0: CompletionStage[U], arg1: BiFunction[T, U, V]) -> CompletionStage[V]: ...

  @overload
  def thenCombineAsync(self, arg0: CompletionStage[U], arg1: BiFunction[T, U, V]) -> CompletionStage[V]: ...

  @overload
  def thenCombineAsync(self, arg0: CompletionStage[U], arg1: BiFunction[T, U, V], arg2: Executor) -> CompletionStage[V]: ...

  def thenCompose(self, arg0: Function[T, CompletionStage[U]]) -> CompletionStage[U]: ...

  @overload
  def thenComposeAsync(self, arg0: Function[T, CompletionStage[U]]) -> CompletionStage[U]: ...

  @overload
  def thenComposeAsync(self, arg0: Function[T, CompletionStage[U]], arg1: Executor) -> CompletionStage[U]: ...

  def thenRun(self, arg0: Runnable) -> CompletionStage[Void]: ...

  @overload
  def thenRunAsync(self, arg0: Runnable) -> CompletionStage[Void]: ...

  @overload
  def thenRunAsync(self, arg0: Runnable, arg1: Executor) -> CompletionStage[Void]: ...

  def toCompletableFuture(self) -> CompletableFuture[T]: ...

  def whenComplete(self, arg0: BiConsumer[T, Throwable]) -> CompletionStage[T]: ...

  @overload
  def whenCompleteAsync(self, arg0: BiConsumer[T, Throwable]) -> CompletionStage[T]: ...

  @overload
  def whenCompleteAsync(self, arg0: BiConsumer[T, Throwable], arg1: Executor) -> CompletionStage[T]: ...


class ConcurrentHashMap[K, V](AbstractMap):

  def clear(self) -> None: ...

  @overload
  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  @overload
  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  @overload
  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def contains(self, arg0: object) -> bool: ...

  def containsKey(self, arg0: object) -> bool: ...

  def containsValue(self, arg0: object) -> bool: ...

  def elements(self) -> Enumeration[V]: ...

  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  def equals(self, arg0: object) -> bool: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def forEach(self, arg0: int, arg1: BiConsumer[K, V]) -> None: ...

  @overload
  def forEach(self, arg0: int, arg1: BiFunction[K, V, U], arg2: Consumer[U]) -> None: ...

  @overload
  def forEachEntry(self, arg0: int, arg1: Consumer[Map.Entry[K, V]]) -> None: ...

  @overload
  def forEachEntry(self, arg0: int, arg1: Function[Map.Entry[K, V], U], arg2: Consumer[U]) -> None: ...

  @overload
  def forEachKey(self, arg0: int, arg1: Consumer[K]) -> None: ...

  @overload
  def forEachKey(self, arg0: int, arg1: Function[K, U], arg2: Consumer[U]) -> None: ...

  @overload
  def forEachValue(self, arg0: int, arg1: Consumer[V]) -> None: ...

  @overload
  def forEachValue(self, arg0: int, arg1: Function[V, U], arg2: Consumer[U]) -> None: ...

  def get(self, arg0: object) -> object: ...

  @overload
  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  @overload
  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  @overload
  def keySet(self) -> Set: ...

  @overload
  def keySet(self) -> ConcurrentHashMap.KeySetView: ...

  @overload
  def keySet(self, arg0: object) -> ConcurrentHashMap.KeySetView: ...

  def keys(self) -> Enumeration[K]: ...

  def mappingCount(self) -> int: ...

  @overload
  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, arg0: Map[K, V]) -> None: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  def reduce(self, arg0: int, arg1: BiFunction[K, V, U], arg2: BiFunction[U, U, U]) -> object: ...

  @overload
  def reduceEntries(self, arg0: int, arg1: BiFunction[Map.Entry[K, V], Map.Entry[K, V], Map.Entry[K, V]]) -> Map.Entry: ...

  @overload
  def reduceEntries(self, arg0: int, arg1: Function[Map.Entry[K, V], U], arg2: BiFunction[U, U, U]) -> object: ...

  def reduceEntriesToDouble(self, arg0: int, arg1: ToDoubleFunction[Map.Entry[K, V]], arg2: float, arg3: DoubleBinaryOperator) -> float: ...

  def reduceEntriesToInt(self, arg0: int, arg1: ToIntFunction[Map.Entry[K, V]], arg2: int, arg3: IntBinaryOperator) -> int: ...

  def reduceEntriesToLong(self, arg0: int, arg1: ToLongFunction[Map.Entry[K, V]], arg2: int, arg3: LongBinaryOperator) -> int: ...

  @overload
  def reduceKeys(self, arg0: int, arg1: BiFunction[K, K, K]) -> object: ...

  @overload
  def reduceKeys(self, arg0: int, arg1: Function[K, U], arg2: BiFunction[U, U, U]) -> object: ...

  def reduceKeysToDouble(self, arg0: int, arg1: ToDoubleFunction[K], arg2: float, arg3: DoubleBinaryOperator) -> float: ...

  def reduceKeysToInt(self, arg0: int, arg1: ToIntFunction[K], arg2: int, arg3: IntBinaryOperator) -> int: ...

  def reduceKeysToLong(self, arg0: int, arg1: ToLongFunction[K], arg2: int, arg3: LongBinaryOperator) -> int: ...

  def reduceToDouble(self, arg0: int, arg1: ToDoubleBiFunction[K, V], arg2: float, arg3: DoubleBinaryOperator) -> float: ...

  def reduceToInt(self, arg0: int, arg1: ToIntBiFunction[K, V], arg2: int, arg3: IntBinaryOperator) -> int: ...

  def reduceToLong(self, arg0: int, arg1: ToLongBiFunction[K, V], arg2: int, arg3: LongBinaryOperator) -> int: ...

  @overload
  def reduceValues(self, arg0: int, arg1: BiFunction[V, V, V]) -> object: ...

  @overload
  def reduceValues(self, arg0: int, arg1: Function[V, U], arg2: BiFunction[U, U, U]) -> object: ...

  def reduceValuesToDouble(self, arg0: int, arg1: ToDoubleFunction[V], arg2: float, arg3: DoubleBinaryOperator) -> float: ...

  def reduceValuesToInt(self, arg0: int, arg1: ToIntFunction[V], arg2: int, arg3: IntBinaryOperator) -> int: ...

  def reduceValuesToLong(self, arg0: int, arg1: ToLongFunction[V], arg2: int, arg3: LongBinaryOperator) -> int: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  def search(self, arg0: int, arg1: BiFunction[K, V, U]) -> object: ...

  def searchEntries(self, arg0: int, arg1: Function[Map.Entry[K, V], U]) -> object: ...

  def searchKeys(self, arg0: int, arg1: Function[K, U]) -> object: ...

  def searchValues(self, arg0: int, arg1: Function[V, U]) -> object: ...

  def size(self) -> int: ...

  def toString(self) -> str: ...

  def values(self) -> Collection[V]: ...

  @staticmethod
  @overload
  def newKeySet() -> ConcurrentHashMap.KeySetView: ...

  @staticmethod
  @overload
  def newKeySet(arg0: int) -> ConcurrentHashMap.KeySetView: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Map[K, V]): ...
  @overload
  def __init__(self, arg0: int, arg1: float): ...
  @overload
  def __init__(self, arg0: int, arg1: float, arg2: int): ...

  class Node[Node_K, Node_V]:

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    def toString(self) -> str: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  class Traverser[Traverser_K, Traverser_V]: ...

  class TreeBin[TreeBin_K, TreeBin_V](ConcurrentHashMap.Node): ...

  class TreeNode[TreeNode_K, TreeNode_V](ConcurrentHashMap.Node): ...

  class ReservationNode[ReservationNode_K, ReservationNode_V](ConcurrentHashMap.Node): ...

  class KeySetView[KeySetView_K, KeySetView_V](ConcurrentHashMap.CollectionView):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[K]) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[K]) -> None: ...

    def getMap(self) -> ConcurrentHashMap: ...

    def getMappedValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[K]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    def size(self) -> int: ...

    @overload
    def spliterator(self) -> Spliterator[K]: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> Set[E]: ...

    @staticmethod
    @overload
    def of() -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...

  class ValuesView[ValuesView_K, ValuesView_V](ConcurrentHashMap.CollectionView):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[V]) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[V]) -> None: ...

    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[V]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    def parallelStream(self) -> Stream[E]: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeIf(self, arg0: Predicate[V]) -> bool: ...

    @overload
    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    def size(self) -> int: ...

    @overload
    def spliterator(self) -> Spliterator[V]: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    def stream(self) -> Stream[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

  class EntrySetView[EntrySetView_K, EntrySetView_V](ConcurrentHashMap.CollectionView):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: Map.Entry) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[Map.Entry[K, V]]) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[Map.Entry[K, V]]) -> None: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[Map.Entry[K, V]]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def removeIf(self, arg0: Predicate[Map.Entry[K, V]]) -> bool: ...

    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    def size(self) -> int: ...

    @overload
    def spliterator(self) -> Spliterator[Map.Entry[K, V]]: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> Set[E]: ...

    @staticmethod
    @overload
    def of() -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> Set[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Set[E]: ...

  class Segment[Segment_K, Segment_V](ReentrantLock): ...

  class KeyIterator[KeyIterator_K, KeyIterator_V](ConcurrentHashMap.BaseIterator):

    def asIterator(self) -> Iterator[E]: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    def hasMoreElements(self) -> bool: ...

    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    def remove(self) -> None: ...

  class ValueIterator[ValueIterator_K, ValueIterator_V](ConcurrentHashMap.BaseIterator):

    def asIterator(self) -> Iterator[E]: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    def hasMoreElements(self) -> bool: ...

    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    @overload
    def nextElement(self) -> object: ...

    def remove(self) -> None: ...

  class CounterCell: ...

  class ForwardingNode[ForwardingNode_K, ForwardingNode_V](ConcurrentHashMap.Node): ...

  class ForEachMappingTask[ForEachMappingTask_K, ForEachMappingTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

  class BulkTask[BulkTask_K, BulkTask_V, R](CountedCompleter): ...

  class ForEachTransformedMappingTask[ForEachTransformedMappingTask_K, ForEachTransformedMappingTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

  class SearchMappingsTask[SearchMappingsTask_K, SearchMappingsTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    def getRawResult(self) -> object: ...

  class MapReduceMappingsTask[MapReduceMappingsTask_K, MapReduceMappingsTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    def getRawResult(self) -> object: ...

  class MapReduceMappingsToDoubleTask[MapReduceMappingsToDoubleTask_K, MapReduceMappingsToDoubleTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Double: ...

    @overload
    def getRawResult(self) -> object: ...

  class MapReduceMappingsToLongTask[MapReduceMappingsToLongTask_K, MapReduceMappingsToLongTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Long: ...

    @overload
    def getRawResult(self) -> object: ...

  class MapReduceMappingsToIntTask[MapReduceMappingsToIntTask_K, MapReduceMappingsToIntTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Integer: ...

    @overload
    def getRawResult(self) -> object: ...

  class ForEachKeyTask[ForEachKeyTask_K, ForEachKeyTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

  class ForEachTransformedKeyTask[ForEachTransformedKeyTask_K, ForEachTransformedKeyTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

  class SearchKeysTask[SearchKeysTask_K, SearchKeysTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    def getRawResult(self) -> object: ...

  class ReduceKeysTask[ReduceKeysTask_K, ReduceKeysTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    def getRawResult(self) -> object: ...

  class MapReduceKeysTask[MapReduceKeysTask_K, MapReduceKeysTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    def getRawResult(self) -> object: ...

  class MapReduceKeysToDoubleTask[MapReduceKeysToDoubleTask_K, MapReduceKeysToDoubleTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Double: ...

    @overload
    def getRawResult(self) -> object: ...

  class MapReduceKeysToLongTask[MapReduceKeysToLongTask_K, MapReduceKeysToLongTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Long: ...

    @overload
    def getRawResult(self) -> object: ...

  class MapReduceKeysToIntTask[MapReduceKeysToIntTask_K, MapReduceKeysToIntTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Integer: ...

    @overload
    def getRawResult(self) -> object: ...

  class ForEachValueTask[ForEachValueTask_K, ForEachValueTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

  class ForEachTransformedValueTask[ForEachTransformedValueTask_K, ForEachTransformedValueTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

  class SearchValuesTask[SearchValuesTask_K, SearchValuesTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    def getRawResult(self) -> object: ...

  class ReduceValuesTask[ReduceValuesTask_K, ReduceValuesTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    def getRawResult(self) -> object: ...

  class MapReduceValuesTask[MapReduceValuesTask_K, MapReduceValuesTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    def getRawResult(self) -> object: ...

  class MapReduceValuesToDoubleTask[MapReduceValuesToDoubleTask_K, MapReduceValuesToDoubleTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Double: ...

    @overload
    def getRawResult(self) -> object: ...

  class MapReduceValuesToLongTask[MapReduceValuesToLongTask_K, MapReduceValuesToLongTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Long: ...

    @overload
    def getRawResult(self) -> object: ...

  class MapReduceValuesToIntTask[MapReduceValuesToIntTask_K, MapReduceValuesToIntTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Integer: ...

    @overload
    def getRawResult(self) -> object: ...

  class ForEachEntryTask[ForEachEntryTask_K, ForEachEntryTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

  class ForEachTransformedEntryTask[ForEachTransformedEntryTask_K, ForEachTransformedEntryTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

  class SearchEntriesTask[SearchEntriesTask_K, SearchEntriesTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    def getRawResult(self) -> object: ...

  class ReduceEntriesTask[ReduceEntriesTask_K, ReduceEntriesTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Map.Entry: ...

    @overload
    def getRawResult(self) -> object: ...

  class MapReduceEntriesTask[MapReduceEntriesTask_K, MapReduceEntriesTask_V, U](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    def getRawResult(self) -> object: ...

  class MapReduceEntriesToDoubleTask[MapReduceEntriesToDoubleTask_K, MapReduceEntriesToDoubleTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Double: ...

    @overload
    def getRawResult(self) -> object: ...

  class MapReduceEntriesToLongTask[MapReduceEntriesToLongTask_K, MapReduceEntriesToLongTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Long: ...

    @overload
    def getRawResult(self) -> object: ...

  class MapReduceEntriesToIntTask[MapReduceEntriesToIntTask_K, MapReduceEntriesToIntTask_V](ConcurrentHashMap.BulkTask):

    def compute(self) -> None: ...

    @overload
    def getRawResult(self) -> Integer: ...

    @overload
    def getRawResult(self) -> object: ...

  class CollectionView[CollectionView_K, CollectionView_V, E]:

    def add(self, arg0: object) -> bool: ...

    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    def equals(self, arg0: object) -> bool: ...

    def getMap(self) -> ConcurrentHashMap[K, V]: ...

    def hashCode(self) -> int: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    def parallelStream(self) -> Stream[E]: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def size(self) -> int: ...

    @overload
    def size(self) -> int: ...

    def spliterator(self) -> Spliterator[E]: ...

    def stream(self) -> Stream[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: IntFunction[T]) -> list[object]: ...

    def toString(self) -> str: ...

  class EntrySpliterator[EntrySpliterator_K, EntrySpliterator_V](ConcurrentHashMap.Traverser):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[Map.Entry[K, V]]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[Map.Entry[K, V]]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> ConcurrentHashMap.EntrySpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class ValueSpliterator[ValueSpliterator_K, ValueSpliterator_V](ConcurrentHashMap.Traverser):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[V]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[V]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> ConcurrentHashMap.ValueSpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class KeySpliterator[KeySpliterator_K, KeySpliterator_V](ConcurrentHashMap.Traverser):

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[K]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[K]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> ConcurrentHashMap.KeySpliterator: ...

    @overload
    def trySplit(self) -> Spliterator: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class MapEntry[MapEntry_K, MapEntry_V]:

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getKey(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def getValue(self) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    @overload
    def setValue(self, arg0: object) -> object: ...

    def toString(self) -> str: ...

    @staticmethod
    @overload
    def comparingByKey() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByKey(arg0: Comparator[K]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue() -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    @overload
    def comparingByValue(arg0: Comparator[V]) -> Comparator[Map.Entry[K, V]]: ...

    @staticmethod
    def copyOf(arg0: Map.Entry) -> Map.Entry: ...

  class EntryIterator[EntryIterator_K, EntryIterator_V](ConcurrentHashMap.BaseIterator):

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> Map.Entry: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    def remove(self) -> None: ...

  class BaseIterator[BaseIterator_K, BaseIterator_V](ConcurrentHashMap.Traverser):

    def hasMoreElements(self) -> bool: ...

    def hasNext(self) -> bool: ...

    def remove(self) -> None: ...

  class TableStack[TableStack_K, TableStack_V]: ...


class ConcurrentLinkedDeque[E](AbstractCollection):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addFirst(self, arg0: object) -> None: ...

  @overload
  def addFirst(self, arg0: object) -> None: ...

  @overload
  def addLast(self, arg0: object) -> None: ...

  @overload
  def addLast(self, arg0: object) -> None: ...

  def clear(self) -> None: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def descendingIterator(self) -> Iterator[E]: ...

  @overload
  def descendingIterator(self) -> Iterator[E]: ...

  @overload
  def element(self) -> object: ...

  @overload
  def element(self) -> object: ...

  def forEach(self, arg0: Consumer[E]) -> None: ...

  @overload
  def getFirst(self) -> object: ...

  @overload
  def getFirst(self) -> object: ...

  @overload
  def getLast(self) -> object: ...

  @overload
  def getLast(self) -> object: ...

  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offerFirst(self, arg0: object) -> bool: ...

  @overload
  def offerFirst(self, arg0: object) -> bool: ...

  @overload
  def offerLast(self, arg0: object) -> bool: ...

  @overload
  def offerLast(self, arg0: object) -> bool: ...

  @overload
  def peek(self) -> object: ...

  @overload
  def peek(self) -> object: ...

  @overload
  def peekFirst(self) -> object: ...

  @overload
  def peekFirst(self) -> object: ...

  @overload
  def peekLast(self) -> object: ...

  @overload
  def peekLast(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def pollFirst(self) -> object: ...

  @overload
  def pollFirst(self) -> object: ...

  @overload
  def pollLast(self) -> object: ...

  @overload
  def pollLast(self) -> object: ...

  @overload
  def pop(self) -> object: ...

  @overload
  def pop(self) -> object: ...

  @overload
  def push(self, arg0: object) -> None: ...

  @overload
  def push(self, arg0: object) -> None: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def removeFirst(self) -> object: ...

  @overload
  def removeFirst(self) -> object: ...

  @overload
  def removeFirstOccurrence(self, arg0: object) -> bool: ...

  @overload
  def removeFirstOccurrence(self, arg0: object) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  @overload
  def removeLast(self) -> object: ...

  @overload
  def removeLast(self) -> object: ...

  @overload
  def removeLastOccurrence(self, arg0: object) -> bool: ...

  @overload
  def removeLastOccurrence(self, arg0: object) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  def toString(self) -> str: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...

  class Node[Node_E]: ...

  class Itr(ConcurrentLinkedDeque.AbstractItr): ...

  class DescendingItr(ConcurrentLinkedDeque.AbstractItr): ...

  class CLDSpliterator:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[E]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator[E]: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

  class AbstractItr:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...


class ConcurrentLinkedQueue[E](AbstractQueue):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  def addAll(self, arg0: Collection[E]) -> bool: ...

  def clear(self) -> None: ...

  def contains(self, arg0: object) -> bool: ...

  def element(self) -> object: ...

  def forEach(self, arg0: Consumer[E]) -> None: ...

  def isEmpty(self) -> bool: ...

  def iterator(self) -> Iterator[E]: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def peek(self) -> object: ...

  @overload
  def peek(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def remove(self) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  def size(self) -> int: ...

  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  def toString(self) -> str: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...

  class Node[Node_E]: ...

  class Itr:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

  class CLQSpliterator:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[E]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator[E]: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...


class ConcurrentMap[K, V]:

  def clear(self) -> None: ...

  @overload
  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  @overload
  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  @overload
  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def containsKey(self, arg0: object) -> bool: ...

  def containsValue(self, arg0: object) -> bool: ...

  def entrySet(self) -> Set[Map.Entry[K, V]]: ...

  def equals(self, arg0: object) -> bool: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  @overload
  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  def get(self, arg0: object) -> object: ...

  @overload
  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  @overload
  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  def keySet(self) -> Set[K]: ...

  @overload
  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  def put(self, arg0: object, arg1: object) -> object: ...

  def putAll(self, arg0: Map[K, V]) -> None: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  @overload
  def remove(self, arg0: object) -> object: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  def size(self) -> int: ...

  def values(self) -> Collection[V]: ...

  @staticmethod
  def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

  @staticmethod
  def entry(arg0: object, arg1: object) -> Map.Entry: ...

  @staticmethod
  @overload
  def of() -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

  @staticmethod
  def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...


class ConcurrentNavigableMap[K, V]:

  def ceilingEntry(self, arg0: object) -> Map.Entry: ...

  def ceilingKey(self, arg0: object) -> object: ...

  def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

  def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

  @overload
  def descendingKeySet(self) -> NavigableSet[K]: ...

  @overload
  def descendingKeySet(self) -> NavigableSet[K]: ...

  @overload
  def descendingMap(self) -> NavigableMap: ...

  @overload
  def descendingMap(self) -> ConcurrentNavigableMap[K, V]: ...

  @overload
  def descendingMap(self) -> NavigableMap[K, V]: ...

  def firstEntry(self) -> Map.Entry: ...

  def floorEntry(self, arg0: object) -> Map.Entry: ...

  def floorKey(self, arg0: object) -> object: ...

  def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

  def getOrDefault(self, arg0: object, arg1: object) -> object: ...

  @overload
  def headMap(self, arg0: object) -> SortedMap: ...

  @overload
  def headMap(self, arg0: object) -> ConcurrentNavigableMap[K, V]: ...

  @overload
  def headMap(self, arg0: object) -> SortedMap[K, V]: ...

  @overload
  def headMap(self, arg0: object, arg1: bool) -> NavigableMap: ...

  @overload
  def headMap(self, arg0: object, arg1: bool) -> ConcurrentNavigableMap[K, V]: ...

  @overload
  def headMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...

  def higherEntry(self, arg0: object) -> Map.Entry: ...

  def higherKey(self, arg0: object) -> object: ...

  @overload
  def keySet(self) -> NavigableSet[K]: ...

  @overload
  def keySet(self) -> Set: ...

  def lastEntry(self) -> Map.Entry: ...

  def lowerEntry(self, arg0: object) -> Map.Entry: ...

  def lowerKey(self, arg0: object) -> object: ...

  def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

  @overload
  def navigableKeySet(self) -> NavigableSet[K]: ...

  @overload
  def navigableKeySet(self) -> NavigableSet[K]: ...

  def pollFirstEntry(self) -> Map.Entry: ...

  def pollLastEntry(self) -> Map.Entry: ...

  def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

  def remove(self, arg0: object, arg1: object) -> bool: ...

  @overload
  def replace(self, arg0: object, arg1: object) -> object: ...

  @overload
  def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

  def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

  @overload
  def subMap(self, arg0: object, arg1: object) -> SortedMap: ...

  @overload
  def subMap(self, arg0: object, arg1: object) -> ConcurrentNavigableMap[K, V]: ...

  @overload
  def subMap(self, arg0: object, arg1: object) -> SortedMap[K, V]: ...

  @overload
  def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap: ...

  @overload
  def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> ConcurrentNavigableMap[K, V]: ...

  @overload
  def subMap(self, arg0: object, arg1: bool, arg2: object, arg3: bool) -> NavigableMap[K, V]: ...

  @overload
  def tailMap(self, arg0: object) -> ConcurrentNavigableMap[K, V]: ...

  @overload
  def tailMap(self, arg0: object) -> SortedMap: ...

  @overload
  def tailMap(self, arg0: object) -> SortedMap[K, V]: ...

  @overload
  def tailMap(self, arg0: object, arg1: bool) -> ConcurrentNavigableMap[K, V]: ...

  @overload
  def tailMap(self, arg0: object, arg1: bool) -> NavigableMap: ...

  @overload
  def tailMap(self, arg0: object, arg1: bool) -> NavigableMap[K, V]: ...


class CopyOnWriteArrayList[E]:

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def add(self, arg0: int, arg1: object) -> None: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  @overload
  def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

  def addAllAbsent(self, arg0: Collection[E]) -> int: ...

  def addIfAbsent(self, arg0: object) -> bool: ...

  @overload
  def clear(self) -> None: ...

  @overload
  def clear(self) -> None: ...

  def clone(self) -> object: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def containsAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  @overload
  def equals(self, arg0: object) -> bool: ...

  def forEach(self, arg0: Consumer[E]) -> None: ...

  @overload
  def get(self, arg0: int) -> object: ...

  @overload
  def get(self, arg0: int) -> object: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def hashCode(self) -> int: ...

  @overload
  def indexOf(self, arg0: object) -> int: ...

  @overload
  def indexOf(self, arg0: object) -> int: ...

  @overload
  def indexOf(self, arg0: object, arg1: int) -> int: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def isEmpty(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def lastIndexOf(self, arg0: object) -> int: ...

  @overload
  def lastIndexOf(self, arg0: object, arg1: int) -> int: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self) -> ListIterator[E]: ...

  @overload
  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  @overload
  def listIterator(self, arg0: int) -> ListIterator[E]: ...

  @overload
  def remove(self, arg0: int) -> object: ...

  @overload
  def remove(self, arg0: int) -> object: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  @overload
  def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

  @overload
  def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  @overload
  def set(self, arg0: int, arg1: object) -> object: ...

  @overload
  def size(self) -> int: ...

  @overload
  def size(self) -> int: ...

  @overload
  def sort(self, arg0: Comparator[E]) -> None: ...

  @overload
  def sort(self, arg0: Comparator[E]) -> None: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def subList(self, arg0: int, arg1: int) -> List[E]: ...

  @overload
  def subList(self, arg0: int, arg1: int) -> List[E]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  def toString(self) -> str: ...

  @staticmethod
  def copyOf(arg0: Collection[E]) -> List[E]: ...

  @staticmethod
  @overload
  def of() -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

  @staticmethod
  @overload
  def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: list[object]): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...

  class COWIterator[COWIterator_E]:

    @overload
    def add(self, arg0: object) -> None: ...

    @overload
    def add(self, arg0: object) -> None: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

  class COWSubList:

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def add(self, arg0: int, arg1: object) -> None: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    @overload
    def addAll(self, arg0: int, arg1: Collection[E]) -> bool: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def containsAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    @overload
    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: Consumer[E]) -> None: ...

    @overload
    def get(self, arg0: int) -> object: ...

    @overload
    def get(self, arg0: int) -> object: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def hashCode(self) -> int: ...

    @overload
    def indexOf(self, arg0: object) -> int: ...

    @overload
    def indexOf(self, arg0: object) -> int: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def isEmpty(self) -> bool: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def lastIndexOf(self, arg0: object) -> int: ...

    @overload
    def lastIndexOf(self, arg0: object) -> int: ...

    @overload
    def listIterator(self) -> ListIterator[E]: ...

    @overload
    def listIterator(self) -> ListIterator[E]: ...

    @overload
    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    @overload
    def listIterator(self, arg0: int) -> ListIterator[E]: ...

    @overload
    def remove(self, arg0: int) -> object: ...

    @overload
    def remove(self, arg0: int) -> object: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def removeAll(self, arg0: Collection[Any]) -> bool: ...

    def removeIf(self, arg0: Predicate[E]) -> bool: ...

    @overload
    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    @overload
    def replaceAll(self, arg0: UnaryOperator[E]) -> None: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def retainAll(self, arg0: Collection[Any]) -> bool: ...

    @overload
    def set(self, arg0: int, arg1: object) -> object: ...

    @overload
    def set(self, arg0: int, arg1: object) -> object: ...

    @overload
    def size(self) -> int: ...

    @overload
    def size(self) -> int: ...

    @overload
    def sort(self, arg0: Comparator[E]) -> None: ...

    @overload
    def sort(self, arg0: Comparator[E]) -> None: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def spliterator(self) -> Spliterator[E]: ...

    @overload
    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def subList(self, arg0: int, arg1: int) -> List[E]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    def toString(self) -> str: ...

    @staticmethod
    def copyOf(arg0: Collection[E]) -> List[E]: ...

    @staticmethod
    @overload
    def of() -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: list[object]) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object) -> List[E]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> List[E]: ...

  class COWSubListIterator[COWSubListIterator_E]:

    @overload
    def add(self, arg0: object) -> None: ...

    @overload
    def add(self, arg0: object) -> None: ...

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def hasPrevious(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def nextIndex(self) -> int: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previous(self) -> object: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def previousIndex(self) -> int: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...

    @overload
    def set(self, arg0: object) -> None: ...


class CountedCompleter[T](ForkJoinTask):

  def addToPendingCount(self, arg0: int) -> None: ...

  def compareAndSetPendingCount(self, arg0: int, arg1: int) -> bool: ...

  def complete(self, arg0: object) -> None: ...

  def compute(self) -> None: ...

  def decrementPendingCountUnlessZero(self) -> int: ...

  def firstComplete(self) -> CountedCompleter[Any]: ...

  def getCompleter(self) -> CountedCompleter[Any]: ...

  def getPendingCount(self) -> int: ...

  def getRawResult(self) -> object: ...

  def getRoot(self) -> CountedCompleter[Any]: ...

  def helpComplete(self, arg0: int) -> None: ...

  def nextComplete(self) -> CountedCompleter[Any]: ...

  def onCompletion(self, arg0: CountedCompleter[Any]) -> None: ...

  def onExceptionalCompletion(self, arg0: Throwable, arg1: CountedCompleter[Any]) -> bool: ...

  def propagateCompletion(self) -> None: ...

  def quietlyCompleteRoot(self) -> None: ...

  def setPendingCount(self, arg0: int) -> None: ...

  def tryComplete(self) -> None: ...


class DelayQueue[E](AbstractQueue):

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: object) -> bool: ...

  @overload
  def add(self, arg0: E) -> bool: ...

  def clear(self) -> None: ...

  def contains(self, arg0: object) -> bool: ...

  @overload
  def drainTo(self, arg0: Collection[E]) -> int: ...

  @overload
  def drainTo(self, arg0: Collection[E]) -> int: ...

  @overload
  def drainTo(self, arg0: Collection[E], arg1: int) -> int: ...

  @overload
  def drainTo(self, arg0: Collection[E], arg1: int) -> int: ...

  def iterator(self) -> Iterator[E]: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offer(self, arg0: E) -> bool: ...

  @overload
  def offer(self, arg0: object, arg1: int, arg2: TimeUnit) -> bool: ...

  @overload
  def offer(self, arg0: object, arg1: int, arg2: TimeUnit) -> bool: ...

  @overload
  def offer(self, arg0: E, arg1: int, arg2: TimeUnit) -> bool: ...

  @overload
  def peek(self) -> E: ...

  @overload
  def peek(self) -> object: ...

  @overload
  def poll(self) -> E: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def poll(self, arg0: int, arg1: TimeUnit) -> object: ...

  @overload
  def poll(self, arg0: int, arg1: TimeUnit) -> E: ...

  @overload
  def poll(self, arg0: int, arg1: TimeUnit) -> object: ...

  @overload
  def put(self, arg0: object) -> None: ...

  @overload
  def put(self, arg0: object) -> None: ...

  @overload
  def put(self, arg0: E) -> None: ...

  @overload
  def remainingCapacity(self) -> int: ...

  @overload
  def remainingCapacity(self) -> int: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  def size(self) -> int: ...

  @overload
  def take(self) -> object: ...

  @overload
  def take(self) -> E: ...

  @overload
  def take(self) -> object: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...

  class Itr:

    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> E: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...


class Delayed:

  def compareTo(self, arg0: object) -> int: ...

  def getDelay(self, arg0: TimeUnit) -> int: ...


class ExecutionException(Exception):

  @overload
  def __init__(self, arg0: Throwable): ...
  @overload
  def __init__(self, arg0: str, arg1: Throwable): ...


class Executor:

  def execute(self, arg0: Runnable) -> None: ...


class ExecutorService:

  def awaitTermination(self, arg0: int, arg1: TimeUnit) -> bool: ...

  def execute(self, arg0: Runnable) -> None: ...

  @overload
  def invokeAll(self, arg0: Collection[Callable[T]]) -> List[Future[T]]: ...

  @overload
  def invokeAll(self, arg0: Collection[Callable[T]], arg1: int, arg2: TimeUnit) -> List[Future[T]]: ...

  @overload
  def invokeAny(self, arg0: Collection[Callable[T]]) -> object: ...

  @overload
  def invokeAny(self, arg0: Collection[Callable[T]], arg1: int, arg2: TimeUnit) -> object: ...

  def isShutdown(self) -> bool: ...

  def isTerminated(self) -> bool: ...

  def shutdown(self) -> None: ...

  def shutdownNow(self) -> List[Runnable]: ...

  @overload
  def submit(self, arg0: Runnable) -> Future[Any]: ...

  @overload
  def submit(self, arg0: Callable[T]) -> Future[T]: ...

  @overload
  def submit(self, arg0: Runnable, arg1: object) -> Future[T]: ...


class ForkJoinPool(AbstractExecutorService):

  defaultForkJoinWorkerThreadFactory: ForkJoinPool.ForkJoinWorkerThreadFactory

  def awaitQuiescence(self, arg0: int, arg1: TimeUnit) -> bool: ...

  def awaitTermination(self, arg0: int, arg1: TimeUnit) -> bool: ...

  @overload
  def execute(self, arg0: Runnable) -> None: ...

  @overload
  def execute(self, arg0: ForkJoinTask[Any]) -> None: ...

  def getActiveThreadCount(self) -> int: ...

  def getAsyncMode(self) -> bool: ...

  def getFactory(self) -> ForkJoinPool.ForkJoinWorkerThreadFactory: ...

  def getParallelism(self) -> int: ...

  def getPoolSize(self) -> int: ...

  def getQueuedSubmissionCount(self) -> int: ...

  def getQueuedTaskCount(self) -> int: ...

  def getRunningThreadCount(self) -> int: ...

  def getStealCount(self) -> int: ...

  def getUncaughtExceptionHandler(self) -> Thread.UncaughtExceptionHandler: ...

  def hasQueuedSubmissions(self) -> bool: ...

  def invoke(self, arg0: ForkJoinTask[T]) -> object: ...

  @overload
  def invokeAll(self, arg0: Collection[Callable[T]]) -> List[Future[T]]: ...

  @overload
  def invokeAll(self, arg0: Collection[Callable[T]], arg1: int, arg2: TimeUnit) -> List[Future[T]]: ...

  @overload
  def invokeAny(self, arg0: Collection[Callable[T]]) -> object: ...

  @overload
  def invokeAny(self, arg0: Collection[Callable[T]], arg1: int, arg2: TimeUnit) -> object: ...

  def isQuiescent(self) -> bool: ...

  def isShutdown(self) -> bool: ...

  def isTerminated(self) -> bool: ...

  def isTerminating(self) -> bool: ...

  def shutdown(self) -> None: ...

  def shutdownNow(self) -> List[Runnable]: ...

  @overload
  def submit(self, arg0: Runnable) -> ForkJoinTask[Any]: ...

  @overload
  def submit(self, arg0: Runnable) -> Future: ...

  @overload
  def submit(self, arg0: Callable[T]) -> ForkJoinTask[T]: ...

  @overload
  def submit(self, arg0: Callable) -> Future: ...

  @overload
  def submit(self, arg0: ForkJoinTask[T]) -> ForkJoinTask[T]: ...

  @overload
  def submit(self, arg0: Runnable, arg1: object) -> ForkJoinTask[T]: ...

  @overload
  def submit(self, arg0: Runnable, arg1: object) -> Future: ...

  def toString(self) -> str: ...

  @staticmethod
  def commonPool() -> ForkJoinPool: ...

  @staticmethod
  def getCommonPoolParallelism() -> int: ...

  @staticmethod
  def managedBlock(arg0: ForkJoinPool.ManagedBlocker) -> None: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: int, arg1: ForkJoinPool.ForkJoinWorkerThreadFactory, arg2: Thread.UncaughtExceptionHandler, arg3: bool): ...
  @overload
  def __init__(self, arg0: int, arg1: ForkJoinPool.ForkJoinWorkerThreadFactory, arg2: Thread.UncaughtExceptionHandler, arg3: bool, arg4: int, arg5: int, arg6: int, arg7: Predicate[ForkJoinPool], arg8: int, arg9: TimeUnit): ...

  class ForkJoinWorkerThreadFactory:

    def newThread(self, arg0: ForkJoinPool) -> ForkJoinWorkerThread: ...

  class WorkQueue: ...

  class ManagedBlocker:

    def block(self) -> bool: ...

    def isReleasable(self) -> bool: ...

  class DefaultCommonPoolForkJoinWorkerThreadFactory:

    @overload
    def newThread(self, arg0: ForkJoinPool) -> ForkJoinWorkerThread: ...

    @overload
    def newThread(self, arg0: ForkJoinPool) -> ForkJoinWorkerThread: ...

  class InvokeAnyRoot[E](ForkJoinTask):

    def exec(self) -> bool: ...

    def getRawResult(self) -> object: ...

    def setRawResult(self, arg0: object) -> None: ...

  class InvokeAnyTask[E](ForkJoinTask):

    def cancel(self, arg0: bool) -> bool: ...

    def exec(self) -> bool: ...

    def getRawResult(self) -> object: ...

    def setRawResult(self, arg0: object) -> None: ...

  class DefaultForkJoinWorkerThreadFactory:

    @overload
    def newThread(self, arg0: ForkJoinPool) -> ForkJoinWorkerThread: ...

    @overload
    def newThread(self, arg0: ForkJoinPool) -> ForkJoinWorkerThread: ...


class ForkJoinTask[V]:

  @overload
  def cancel(self, arg0: bool) -> bool: ...

  @overload
  def cancel(self, arg0: bool) -> bool: ...

  def compareAndSetForkJoinTaskTag(self, arg0: int, arg1: int) -> bool: ...

  def complete(self, arg0: object) -> None: ...

  def completeExceptionally(self, arg0: Throwable) -> None: ...

  def fork(self) -> ForkJoinTask[V]: ...

  @overload
  def get(self) -> object: ...

  @overload
  def get(self) -> object: ...

  @overload
  def get(self, arg0: int, arg1: TimeUnit) -> object: ...

  @overload
  def get(self, arg0: int, arg1: TimeUnit) -> object: ...

  def getException(self) -> Throwable: ...

  def getForkJoinTaskTag(self) -> int: ...

  def getRawResult(self) -> object: ...

  def invoke(self) -> object: ...

  @overload
  def isCancelled(self) -> bool: ...

  @overload
  def isCancelled(self) -> bool: ...

  def isCompletedAbnormally(self) -> bool: ...

  def isCompletedNormally(self) -> bool: ...

  @overload
  def isDone(self) -> bool: ...

  @overload
  def isDone(self) -> bool: ...

  def join(self) -> object: ...

  def quietlyComplete(self) -> None: ...

  def quietlyInvoke(self) -> None: ...

  def quietlyJoin(self) -> None: ...

  def reinitialize(self) -> None: ...

  def setForkJoinTaskTag(self, arg0: int) -> int: ...

  def tryUnfork(self) -> bool: ...

  @staticmethod
  @overload
  def adapt(arg0: Runnable) -> ForkJoinTask[Any]: ...

  @staticmethod
  @overload
  def adapt(arg0: Callable[T]) -> ForkJoinTask[T]: ...

  @staticmethod
  @overload
  def adapt(arg0: Runnable, arg1: object) -> ForkJoinTask[T]: ...

  @staticmethod
  def getPool() -> ForkJoinPool: ...

  @staticmethod
  def getQueuedTaskCount() -> int: ...

  @staticmethod
  def getSurplusQueuedTaskCount() -> int: ...

  @staticmethod
  def helpQuiesce() -> None: ...

  @staticmethod
  def inForkJoinPool() -> bool: ...

  @staticmethod
  @overload
  def invokeAll(arg0: list[ForkJoinTask]) -> None: ...

  @staticmethod
  @overload
  def invokeAll(arg0: Collection[T]) -> Collection[T]: ...

  @staticmethod
  @overload
  def invokeAll(arg0: ForkJoinTask[Any], arg1: ForkJoinTask[Any]) -> None: ...

  def __init__(self): ...

  class Aux: ...

  class AdaptedRunnableAction(ForkJoinTask):

    def exec(self) -> bool: ...

    @overload
    def getRawResult(self) -> Void: ...

    @overload
    def getRawResult(self) -> object: ...

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...

    @overload
    def setRawResult(self, arg0: object) -> None: ...

    @overload
    def setRawResult(self, arg0: Void) -> None: ...

    def toString(self) -> str: ...

  class AdaptedRunnable[T](ForkJoinTask):

    def exec(self) -> bool: ...

    def getRawResult(self) -> object: ...

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...

    def setRawResult(self, arg0: object) -> None: ...

    def toString(self) -> str: ...

  class AdaptedCallable[T](ForkJoinTask):

    def exec(self) -> bool: ...

    def getRawResult(self) -> object: ...

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...

    def setRawResult(self, arg0: object) -> None: ...

    def toString(self) -> str: ...

  class AdaptedInterruptibleCallable[T](ForkJoinTask):

    def cancel(self, arg0: bool) -> bool: ...

    def exec(self) -> bool: ...

    def getRawResult(self) -> object: ...

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...

    def setRawResult(self, arg0: object) -> None: ...

    def toString(self) -> str: ...

  class RunnableExecuteAction(ForkJoinTask):

    def exec(self) -> bool: ...

    @overload
    def getRawResult(self) -> Void: ...

    @overload
    def getRawResult(self) -> object: ...

    @overload
    def setRawResult(self, arg0: object) -> None: ...

    @overload
    def setRawResult(self, arg0: Void) -> None: ...


class ForkJoinWorkerThread(Thread):

  def getPool(self) -> ForkJoinPool: ...

  def getPoolIndex(self) -> int: ...

  def run(self) -> None: ...

  class InnocuousForkJoinWorkerThread(ForkJoinWorkerThread):

    def setContextClassLoader(self, arg0: ClassLoader) -> None: ...

    def setUncaughtExceptionHandler(self, arg0: Thread.UncaughtExceptionHandler) -> None: ...


class Future[V]:

  def cancel(self, arg0: bool) -> bool: ...

  @overload
  def get(self) -> object: ...

  @overload
  def get(self, arg0: int, arg1: TimeUnit) -> object: ...

  def isCancelled(self) -> bool: ...

  def isDone(self) -> bool: ...


class FutureTask[V]:

  def cancel(self, arg0: bool) -> bool: ...

  @overload
  def get(self) -> object: ...

  @overload
  def get(self, arg0: int, arg1: TimeUnit) -> object: ...

  def isCancelled(self) -> bool: ...

  def isDone(self) -> bool: ...

  @overload
  def run(self) -> None: ...

  @overload
  def run(self) -> None: ...

  def toString(self) -> str: ...

  @overload
  def __init__(self, arg0: Callable[V]): ...
  @overload
  def __init__(self, arg0: Runnable, arg1: object): ...

  class WaitNode: ...


class LinkedBlockingQueue[E](AbstractQueue):

  def add(self, arg0: object) -> bool: ...

  def clear(self) -> None: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def contains(self, arg0: object) -> bool: ...

  @overload
  def drainTo(self, arg0: Collection[E]) -> int: ...

  @overload
  def drainTo(self, arg0: Collection[E]) -> int: ...

  @overload
  def drainTo(self, arg0: Collection[E], arg1: int) -> int: ...

  @overload
  def drainTo(self, arg0: Collection[E], arg1: int) -> int: ...

  def forEach(self, arg0: Consumer[E]) -> None: ...

  def iterator(self) -> Iterator[E]: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offer(self, arg0: object) -> bool: ...

  @overload
  def offer(self, arg0: object, arg1: int, arg2: TimeUnit) -> bool: ...

  @overload
  def offer(self, arg0: object, arg1: int, arg2: TimeUnit) -> bool: ...

  def peek(self) -> object: ...

  @overload
  def poll(self) -> object: ...

  @overload
  def poll(self, arg0: int, arg1: TimeUnit) -> object: ...

  @overload
  def poll(self, arg0: int, arg1: TimeUnit) -> object: ...

  @overload
  def put(self, arg0: object) -> None: ...

  @overload
  def put(self, arg0: object) -> None: ...

  @overload
  def remainingCapacity(self) -> int: ...

  @overload
  def remainingCapacity(self) -> int: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  @overload
  def remove(self, arg0: object) -> bool: ...

  def removeAll(self, arg0: Collection[Any]) -> bool: ...

  def removeIf(self, arg0: Predicate[E]) -> bool: ...

  def retainAll(self, arg0: Collection[Any]) -> bool: ...

  def size(self) -> int: ...

  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def take(self) -> object: ...

  @overload
  def take(self) -> object: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: list[object]) -> list[object]: ...

  def toString(self) -> str: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: Collection[E]): ...

  class Node[Node_E]: ...

  class Itr:

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def hasNext(self) -> bool: ...

    @overload
    def next(self) -> object: ...

    @overload
    def next(self) -> object: ...

    @overload
    def remove(self) -> None: ...

    @overload
    def remove(self) -> None: ...

  class LBQSpliterator:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[E]) -> bool: ...

    @overload
    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> Spliterator[E]: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...


class RejectedExecutionHandler:

  def rejectedExecution(self, arg0: Runnable, arg1: ThreadPoolExecutor) -> None: ...


class RunnableFuture[V]:

  def cancel(self, arg0: bool) -> bool: ...

  @overload
  def get(self) -> object: ...

  @overload
  def get(self, arg0: int, arg1: TimeUnit) -> object: ...

  def isCancelled(self) -> bool: ...

  def isDone(self) -> bool: ...

  @overload
  def run(self) -> None: ...

  @overload
  def run(self) -> None: ...


class RunnableScheduledFuture[V]:

  def isPeriodic(self) -> bool: ...

  def run(self) -> None: ...


class ScheduledExecutorService:

  def awaitTermination(self, arg0: int, arg1: TimeUnit) -> bool: ...

  @overload
  def invokeAll(self, arg0: Collection[Callable[T]]) -> List[Future[T]]: ...

  @overload
  def invokeAll(self, arg0: Collection[Callable[T]], arg1: int, arg2: TimeUnit) -> List[Future[T]]: ...

  @overload
  def invokeAny(self, arg0: Collection[Callable[T]]) -> object: ...

  @overload
  def invokeAny(self, arg0: Collection[Callable[T]], arg1: int, arg2: TimeUnit) -> object: ...

  def isShutdown(self) -> bool: ...

  def isTerminated(self) -> bool: ...

  @overload
  def schedule(self, arg0: Runnable, arg1: int, arg2: TimeUnit) -> ScheduledFuture[Any]: ...

  @overload
  def schedule(self, arg0: Callable[V], arg1: int, arg2: TimeUnit) -> ScheduledFuture[V]: ...

  def scheduleAtFixedRate(self, arg0: Runnable, arg1: int, arg2: int, arg3: TimeUnit) -> ScheduledFuture[Any]: ...

  def scheduleWithFixedDelay(self, arg0: Runnable, arg1: int, arg2: int, arg3: TimeUnit) -> ScheduledFuture[Any]: ...

  def shutdown(self) -> None: ...

  def shutdownNow(self) -> List[Runnable]: ...

  @overload
  def submit(self, arg0: Runnable) -> Future[Any]: ...

  @overload
  def submit(self, arg0: Callable[T]) -> Future[T]: ...

  @overload
  def submit(self, arg0: Runnable, arg1: object) -> Future[T]: ...


class ScheduledFuture[V]:

  def cancel(self, arg0: bool) -> bool: ...

  @overload
  def get(self) -> object: ...

  @overload
  def get(self, arg0: int, arg1: TimeUnit) -> object: ...

  def getDelay(self, arg0: TimeUnit) -> int: ...

  def isCancelled(self) -> bool: ...

  def isDone(self) -> bool: ...


class ScheduledThreadPoolExecutor(ThreadPoolExecutor):

  def execute(self, arg0: Runnable) -> None: ...

  def getContinueExistingPeriodicTasksAfterShutdownPolicy(self) -> bool: ...

  def getExecuteExistingDelayedTasksAfterShutdownPolicy(self) -> bool: ...

  def getQueue(self) -> BlockingQueue[Runnable]: ...

  def getRemoveOnCancelPolicy(self) -> bool: ...

  @overload
  def schedule(self, arg0: Runnable, arg1: int, arg2: TimeUnit) -> ScheduledFuture[Any]: ...

  @overload
  def schedule(self, arg0: Runnable, arg1: int, arg2: TimeUnit) -> ScheduledFuture[Any]: ...

  @overload
  def schedule(self, arg0: Callable[V], arg1: int, arg2: TimeUnit) -> ScheduledFuture[V]: ...

  @overload
  def schedule(self, arg0: Callable[V], arg1: int, arg2: TimeUnit) -> ScheduledFuture[V]: ...

  @overload
  def scheduleAtFixedRate(self, arg0: Runnable, arg1: int, arg2: int, arg3: TimeUnit) -> ScheduledFuture[Any]: ...

  @overload
  def scheduleAtFixedRate(self, arg0: Runnable, arg1: int, arg2: int, arg3: TimeUnit) -> ScheduledFuture[Any]: ...

  @overload
  def scheduleWithFixedDelay(self, arg0: Runnable, arg1: int, arg2: int, arg3: TimeUnit) -> ScheduledFuture[Any]: ...

  @overload
  def scheduleWithFixedDelay(self, arg0: Runnable, arg1: int, arg2: int, arg3: TimeUnit) -> ScheduledFuture[Any]: ...

  def setContinueExistingPeriodicTasksAfterShutdownPolicy(self, arg0: bool) -> None: ...

  def setExecuteExistingDelayedTasksAfterShutdownPolicy(self, arg0: bool) -> None: ...

  def setRemoveOnCancelPolicy(self, arg0: bool) -> None: ...

  def shutdown(self) -> None: ...

  def shutdownNow(self) -> List[Runnable]: ...

  @overload
  def submit(self, arg0: Runnable) -> Future[Any]: ...

  @overload
  def submit(self, arg0: Callable[T]) -> Future[T]: ...

  @overload
  def submit(self, arg0: Runnable, arg1: object) -> Future[T]: ...

  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: int, arg1: RejectedExecutionHandler): ...
  @overload
  def __init__(self, arg0: int, arg1: ThreadFactory): ...
  @overload
  def __init__(self, arg0: int, arg1: ThreadFactory, arg2: RejectedExecutionHandler): ...

  class DelayedWorkQueue(AbstractQueue):

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: object) -> bool: ...

    @overload
    def add(self, arg0: Runnable) -> bool: ...

    def clear(self) -> None: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def contains(self, arg0: object) -> bool: ...

    @overload
    def drainTo(self, arg0: Collection[Runnable]) -> int: ...

    @overload
    def drainTo(self, arg0: Collection[E]) -> int: ...

    @overload
    def drainTo(self, arg0: Collection[Runnable], arg1: int) -> int: ...

    @overload
    def drainTo(self, arg0: Collection[E], arg1: int) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> Iterator[Runnable]: ...

    @overload
    def offer(self, arg0: object) -> bool: ...

    @overload
    def offer(self, arg0: object) -> bool: ...

    @overload
    def offer(self, arg0: Runnable) -> bool: ...

    @overload
    def offer(self, arg0: object, arg1: int, arg2: TimeUnit) -> bool: ...

    @overload
    def offer(self, arg0: object, arg1: int, arg2: TimeUnit) -> bool: ...

    @overload
    def offer(self, arg0: Runnable, arg1: int, arg2: TimeUnit) -> bool: ...

    @overload
    def peek(self) -> object: ...

    @overload
    def peek(self) -> RunnableScheduledFuture[Any]: ...

    @overload
    def poll(self) -> object: ...

    @overload
    def poll(self) -> RunnableScheduledFuture[Any]: ...

    @overload
    def poll(self, arg0: int, arg1: TimeUnit) -> RunnableScheduledFuture[Any]: ...

    @overload
    def poll(self, arg0: int, arg1: TimeUnit) -> object: ...

    @overload
    def poll(self, arg0: int, arg1: TimeUnit) -> object: ...

    @overload
    def put(self, arg0: object) -> None: ...

    @overload
    def put(self, arg0: object) -> None: ...

    @overload
    def put(self, arg0: Runnable) -> None: ...

    @overload
    def remainingCapacity(self) -> int: ...

    @overload
    def remainingCapacity(self) -> int: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    @overload
    def remove(self, arg0: object) -> bool: ...

    def size(self) -> int: ...

    @overload
    def take(self) -> RunnableScheduledFuture[Any]: ...

    @overload
    def take(self) -> object: ...

    @overload
    def take(self) -> object: ...

    @overload
    def toArray(self) -> list[object]: ...

    @overload
    def toArray(self, arg0: list[object]) -> list[object]: ...

    class Itr:

      def forEachRemaining(self, arg0: Consumer[E]) -> None: ...

      @overload
      def hasNext(self) -> bool: ...

      @overload
      def hasNext(self) -> bool: ...

      @overload
      def next(self) -> object: ...

      @overload
      def next(self) -> Runnable: ...

      @overload
      def next(self) -> object: ...

      @overload
      def remove(self) -> None: ...

      @overload
      def remove(self) -> None: ...

  class ScheduledFutureTask[V](FutureTask):

    def cancel(self, arg0: bool) -> bool: ...

    @overload
    def compareTo(self, arg0: object) -> int: ...

    @overload
    def compareTo(self, arg0: Delayed) -> int: ...

    def getDelay(self, arg0: TimeUnit) -> int: ...

    @overload
    def isPeriodic(self) -> bool: ...

    @overload
    def isPeriodic(self) -> bool: ...

    def run(self) -> None: ...


class Semaphore:

  @overload
  def acquire(self) -> None: ...

  @overload
  def acquire(self, arg0: int) -> None: ...

  @overload
  def acquireUninterruptibly(self) -> None: ...

  @overload
  def acquireUninterruptibly(self, arg0: int) -> None: ...

  def availablePermits(self) -> int: ...

  def drainPermits(self) -> int: ...

  def getQueueLength(self) -> int: ...

  def hasQueuedThreads(self) -> bool: ...

  def isFair(self) -> bool: ...

  @overload
  def release(self) -> None: ...

  @overload
  def release(self, arg0: int) -> None: ...

  def toString(self) -> str: ...

  @overload
  def tryAcquire(self) -> bool: ...

  @overload
  def tryAcquire(self, arg0: int) -> bool: ...

  @overload
  def tryAcquire(self, arg0: int, arg1: TimeUnit) -> bool: ...

  @overload
  def tryAcquire(self, arg0: int, arg1: int, arg2: TimeUnit) -> bool: ...

  @overload
  def __init__(self, arg0: int): ...
  @overload
  def __init__(self, arg0: int, arg1: bool): ...

  class NonfairSync(Semaphore.Sync): ...

  class Sync(AbstractQueuedSynchronizer): ...

  class FairSync(Semaphore.Sync): ...


class ThreadFactory:

  def newThread(self, arg0: Runnable) -> Thread: ...


class ThreadPoolExecutor(AbstractExecutorService):

  def allowCoreThreadTimeOut(self, arg0: bool) -> None: ...

  def allowsCoreThreadTimeOut(self) -> bool: ...

  def awaitTermination(self, arg0: int, arg1: TimeUnit) -> bool: ...

  def execute(self, arg0: Runnable) -> None: ...

  def getActiveCount(self) -> int: ...

  def getCompletedTaskCount(self) -> int: ...

  def getCorePoolSize(self) -> int: ...

  def getKeepAliveTime(self, arg0: TimeUnit) -> int: ...

  def getLargestPoolSize(self) -> int: ...

  def getMaximumPoolSize(self) -> int: ...

  def getPoolSize(self) -> int: ...

  def getQueue(self) -> BlockingQueue[Runnable]: ...

  def getRejectedExecutionHandler(self) -> RejectedExecutionHandler: ...

  def getTaskCount(self) -> int: ...

  def getThreadFactory(self) -> ThreadFactory: ...

  def isShutdown(self) -> bool: ...

  def isTerminated(self) -> bool: ...

  def isTerminating(self) -> bool: ...

  def prestartAllCoreThreads(self) -> int: ...

  def prestartCoreThread(self) -> bool: ...

  def purge(self) -> None: ...

  def remove(self, arg0: Runnable) -> bool: ...

  def setCorePoolSize(self, arg0: int) -> None: ...

  def setKeepAliveTime(self, arg0: int, arg1: TimeUnit) -> None: ...

  def setMaximumPoolSize(self, arg0: int) -> None: ...

  def setRejectedExecutionHandler(self, arg0: RejectedExecutionHandler) -> None: ...

  def setThreadFactory(self, arg0: ThreadFactory) -> None: ...

  def shutdown(self) -> None: ...

  def shutdownNow(self) -> List[Runnable]: ...

  def toString(self) -> str: ...

  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int, arg3: TimeUnit, arg4: BlockingQueue[Runnable]): ...
  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int, arg3: TimeUnit, arg4: BlockingQueue[Runnable], arg5: RejectedExecutionHandler): ...
  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int, arg3: TimeUnit, arg4: BlockingQueue[Runnable], arg5: ThreadFactory): ...
  @overload
  def __init__(self, arg0: int, arg1: int, arg2: int, arg3: TimeUnit, arg4: BlockingQueue[Runnable], arg5: ThreadFactory, arg6: RejectedExecutionHandler): ...

  class Worker(AbstractQueuedSynchronizer):

    def isLocked(self) -> bool: ...

    def lock(self) -> None: ...

    @overload
    def run(self) -> None: ...

    @overload
    def run(self) -> None: ...

    def tryLock(self) -> bool: ...

    def unlock(self) -> None: ...

  class AbortPolicy:

    @overload
    def rejectedExecution(self, arg0: Runnable, arg1: ThreadPoolExecutor) -> None: ...

    @overload
    def rejectedExecution(self, arg0: Runnable, arg1: ThreadPoolExecutor) -> None: ...

    def __init__(self): ...

  class DiscardOldestPolicy:

    @overload
    def rejectedExecution(self, arg0: Runnable, arg1: ThreadPoolExecutor) -> None: ...

    @overload
    def rejectedExecution(self, arg0: Runnable, arg1: ThreadPoolExecutor) -> None: ...

    def __init__(self): ...

  class DiscardPolicy:

    @overload
    def rejectedExecution(self, arg0: Runnable, arg1: ThreadPoolExecutor) -> None: ...

    @overload
    def rejectedExecution(self, arg0: Runnable, arg1: ThreadPoolExecutor) -> None: ...

    def __init__(self): ...

  class CallerRunsPolicy:

    @overload
    def rejectedExecution(self, arg0: Runnable, arg1: ThreadPoolExecutor) -> None: ...

    @overload
    def rejectedExecution(self, arg0: Runnable, arg1: ThreadPoolExecutor) -> None: ...

    def __init__(self): ...


class TimeUnit(Enum):

  DAYS: TimeUnit

  HOURS: TimeUnit

  MICROSECONDS: TimeUnit

  MILLISECONDS: TimeUnit

  MINUTES: TimeUnit

  NANOSECONDS: TimeUnit

  SECONDS: TimeUnit

  @overload
  def convert(self, arg0: Duration) -> int: ...

  @overload
  def convert(self, arg0: int, arg1: TimeUnit) -> int: ...

  def sleep(self, arg0: int) -> None: ...

  def timedJoin(self, arg0: Thread, arg1: int) -> None: ...

  def timedWait(self, arg0: object, arg1: int) -> None: ...

  def toChronoUnit(self) -> ChronoUnit: ...

  def toDays(self, arg0: int) -> int: ...

  def toHours(self, arg0: int) -> int: ...

  def toMicros(self, arg0: int) -> int: ...

  def toMillis(self, arg0: int) -> int: ...

  def toMinutes(self, arg0: int) -> int: ...

  def toNanos(self, arg0: int) -> int: ...

  def toSeconds(self, arg0: int) -> int: ...

  @staticmethod
  def of(arg0: ChronoUnit) -> TimeUnit: ...

  @staticmethod
  def valueOf(arg0: str) -> TimeUnit: ...

  @staticmethod
  def values() -> list[TimeUnit]: ...


class TimeoutException(Exception):

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: str): ...

