from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.lang import Thread, ThreadLocal
from java.util import Collection, Date
from java.util.concurrent import TimeUnit

class AbstractOwnableSynchronizer: ...


class AbstractQueuedSynchronizer(AbstractOwnableSynchronizer):

  def acquire(self, arg0: int) -> None: ...

  def acquireInterruptibly(self, arg0: int) -> None: ...

  def acquireShared(self, arg0: int) -> None: ...

  def acquireSharedInterruptibly(self, arg0: int) -> None: ...

  def getExclusiveQueuedThreads(self) -> Collection[Thread]: ...

  def getFirstQueuedThread(self) -> Thread: ...

  def getQueueLength(self) -> int: ...

  def getQueuedThreads(self) -> Collection[Thread]: ...

  def getSharedQueuedThreads(self) -> Collection[Thread]: ...

  def getWaitQueueLength(self, arg0: AbstractQueuedSynchronizer.ConditionObject) -> int: ...

  def getWaitingThreads(self, arg0: AbstractQueuedSynchronizer.ConditionObject) -> Collection[Thread]: ...

  def hasContended(self) -> bool: ...

  def hasQueuedPredecessors(self) -> bool: ...

  def hasQueuedThreads(self) -> bool: ...

  def hasWaiters(self, arg0: AbstractQueuedSynchronizer.ConditionObject) -> bool: ...

  def isQueued(self, arg0: Thread) -> bool: ...

  def owns(self, arg0: AbstractQueuedSynchronizer.ConditionObject) -> bool: ...

  def release(self, arg0: int) -> bool: ...

  def releaseShared(self, arg0: int) -> bool: ...

  def toString(self) -> str: ...

  def tryAcquireNanos(self, arg0: int, arg1: int) -> bool: ...

  def tryAcquireSharedNanos(self, arg0: int, arg1: int) -> bool: ...

  class ExclusiveNode(AbstractQueuedSynchronizer.Node): ...

  class Node: ...

  class SharedNode(AbstractQueuedSynchronizer.Node): ...

  class ConditionObject:

    @overload
    def await(self) -> None: ...

    @overload
    def await(self) -> None: ...

    @overload
    def await(self, arg0: int, arg1: TimeUnit) -> bool: ...

    @overload
    def await(self, arg0: int, arg1: TimeUnit) -> bool: ...

    @overload
    def awaitNanos(self, arg0: int) -> int: ...

    @overload
    def awaitNanos(self, arg0: int) -> int: ...

    @overload
    def awaitUninterruptibly(self) -> None: ...

    @overload
    def awaitUninterruptibly(self) -> None: ...

    @overload
    def awaitUntil(self, arg0: Date) -> bool: ...

    @overload
    def awaitUntil(self, arg0: Date) -> bool: ...

    @overload
    def signal(self) -> None: ...

    @overload
    def signal(self) -> None: ...

    @overload
    def signalAll(self) -> None: ...

    @overload
    def signalAll(self) -> None: ...

    def __init__(self, arg0: AbstractQueuedSynchronizer): ...

  class ConditionNode(AbstractQueuedSynchronizer.Node):

    @overload
    def block(self) -> bool: ...

    @overload
    def block(self) -> bool: ...

    @overload
    def isReleasable(self) -> bool: ...

    @overload
    def isReleasable(self) -> bool: ...


class Condition:

  @overload
  def await(self) -> None: ...

  @overload
  def await(self, arg0: int, arg1: TimeUnit) -> bool: ...

  def awaitNanos(self, arg0: int) -> int: ...

  def awaitUninterruptibly(self) -> None: ...

  def awaitUntil(self, arg0: Date) -> bool: ...

  def signal(self) -> None: ...

  def signalAll(self) -> None: ...


class Lock:

  def lock(self) -> None: ...

  def lockInterruptibly(self) -> None: ...

  def newCondition(self) -> Condition: ...

  @overload
  def tryLock(self) -> bool: ...

  @overload
  def tryLock(self, arg0: int, arg1: TimeUnit) -> bool: ...

  def unlock(self) -> None: ...


class LockSupport:

  @staticmethod
  def getBlocker(arg0: Thread) -> object: ...

  @staticmethod
  @overload
  def park() -> None: ...

  @staticmethod
  @overload
  def park(arg0: object) -> None: ...

  @staticmethod
  @overload
  def parkNanos(arg0: int) -> None: ...

  @staticmethod
  @overload
  def parkNanos(arg0: object, arg1: int) -> None: ...

  @staticmethod
  @overload
  def parkUntil(arg0: int) -> None: ...

  @staticmethod
  @overload
  def parkUntil(arg0: object, arg1: int) -> None: ...

  @staticmethod
  def setCurrentBlocker(arg0: object) -> None: ...

  @staticmethod
  def unpark(arg0: Thread) -> None: ...


class ReadWriteLock:

  def readLock(self) -> Lock: ...

  def writeLock(self) -> Lock: ...


class ReentrantLock:

  def getHoldCount(self) -> int: ...

  def getQueueLength(self) -> int: ...

  def getWaitQueueLength(self, arg0: Condition) -> int: ...

  def hasQueuedThread(self, arg0: Thread) -> bool: ...

  def hasQueuedThreads(self) -> bool: ...

  def hasWaiters(self, arg0: Condition) -> bool: ...

  def isFair(self) -> bool: ...

  def isHeldByCurrentThread(self) -> bool: ...

  def isLocked(self) -> bool: ...

  @overload
  def lock(self) -> None: ...

  @overload
  def lock(self) -> None: ...

  @overload
  def lockInterruptibly(self) -> None: ...

  @overload
  def lockInterruptibly(self) -> None: ...

  @overload
  def newCondition(self) -> Condition: ...

  @overload
  def newCondition(self) -> Condition: ...

  def toString(self) -> str: ...

  @overload
  def tryLock(self) -> bool: ...

  @overload
  def tryLock(self) -> bool: ...

  @overload
  def tryLock(self, arg0: int, arg1: TimeUnit) -> bool: ...

  @overload
  def tryLock(self, arg0: int, arg1: TimeUnit) -> bool: ...

  @overload
  def unlock(self) -> None: ...

  @overload
  def unlock(self) -> None: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: bool): ...

  class NonfairSync(ReentrantLock.Sync): ...

  class Sync(AbstractQueuedSynchronizer): ...

  class FairSync(ReentrantLock.Sync): ...


class ReentrantReadWriteLock:

  def getQueueLength(self) -> int: ...

  def getReadHoldCount(self) -> int: ...

  def getReadLockCount(self) -> int: ...

  def getWaitQueueLength(self, arg0: Condition) -> int: ...

  def getWriteHoldCount(self) -> int: ...

  def hasQueuedThread(self, arg0: Thread) -> bool: ...

  def hasQueuedThreads(self) -> bool: ...

  def hasWaiters(self, arg0: Condition) -> bool: ...

  def isFair(self) -> bool: ...

  def isWriteLocked(self) -> bool: ...

  def isWriteLockedByCurrentThread(self) -> bool: ...

  @overload
  def readLock(self) -> ReentrantReadWriteLock.ReadLock: ...

  @overload
  def readLock(self) -> Lock: ...

  @overload
  def readLock(self) -> Lock: ...

  def toString(self) -> str: ...

  @overload
  def writeLock(self) -> Lock: ...

  @overload
  def writeLock(self) -> ReentrantReadWriteLock.WriteLock: ...

  @overload
  def writeLock(self) -> Lock: ...

  @overload
  def __init__(self): ...
  @overload
  def __init__(self, arg0: bool): ...

  class FairSync(ReentrantReadWriteLock.Sync): ...

  class NonfairSync(ReentrantReadWriteLock.Sync): ...

  class Sync(AbstractQueuedSynchronizer):

    class ThreadLocalHoldCounter(ThreadLocal):

      @overload
      def initialValue(self) -> ReentrantReadWriteLock.Sync.HoldCounter: ...

      @overload
      def initialValue(self) -> object: ...

    class HoldCounter: ...

  class ReadLock:

    @overload
    def lock(self) -> None: ...

    @overload
    def lock(self) -> None: ...

    @overload
    def lockInterruptibly(self) -> None: ...

    @overload
    def lockInterruptibly(self) -> None: ...

    @overload
    def newCondition(self) -> Condition: ...

    @overload
    def newCondition(self) -> Condition: ...

    def toString(self) -> str: ...

    @overload
    def tryLock(self) -> bool: ...

    @overload
    def tryLock(self) -> bool: ...

    @overload
    def tryLock(self, arg0: int, arg1: TimeUnit) -> bool: ...

    @overload
    def tryLock(self, arg0: int, arg1: TimeUnit) -> bool: ...

    @overload
    def unlock(self) -> None: ...

    @overload
    def unlock(self) -> None: ...

  class WriteLock:

    def getHoldCount(self) -> int: ...

    def isHeldByCurrentThread(self) -> bool: ...

    @overload
    def lock(self) -> None: ...

    @overload
    def lock(self) -> None: ...

    @overload
    def lockInterruptibly(self) -> None: ...

    @overload
    def lockInterruptibly(self) -> None: ...

    @overload
    def newCondition(self) -> Condition: ...

    @overload
    def newCondition(self) -> Condition: ...

    def toString(self) -> str: ...

    @overload
    def tryLock(self) -> bool: ...

    @overload
    def tryLock(self) -> bool: ...

    @overload
    def tryLock(self, arg0: int, arg1: TimeUnit) -> bool: ...

    @overload
    def tryLock(self, arg0: int, arg1: TimeUnit) -> bool: ...

    @overload
    def unlock(self) -> None: ...

    @overload
    def unlock(self) -> None: ...

