from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.lang import Runnable, Enum, Double, Long, CharSequence, Integer
from java.util import Iterator, Spliterator, Set, Map, List, Comparator, Optional, DoubleSummaryStatistics, IntSummaryStatistics, LongSummaryStatistics, AbstractMap, Collection, OptionalDouble, PrimitiveIterator, OptionalInt, OptionalLong
from java.util.concurrent import CountedCompleter, ConcurrentMap
from java.util.function import BiConsumer, BinaryOperator, Function, Supplier, ToDoubleFunction, ToIntFunction, ToLongFunction, Predicate, BiFunction, DoublePredicate, ObjDoubleConsumer, DoubleFunction, DoubleConsumer, DoubleUnaryOperator, DoubleToIntFunction, DoubleToLongFunction, DoubleBinaryOperator, DoubleSupplier, IntPredicate, ObjIntConsumer, IntFunction, IntConsumer, IntUnaryOperator, IntToDoubleFunction, IntToLongFunction, IntBinaryOperator, IntSupplier, LongPredicate, ObjLongConsumer, LongFunction, LongConsumer, LongUnaryOperator, LongToDoubleFunction, LongToIntFunction, LongBinaryOperator, LongSupplier, Consumer, UnaryOperator

E_IN = TypeVar('E_IN', default=Any)
E_OUT = TypeVar('E_OUT', default=Any)
S = TypeVar('S', default=Any)
P_IN = TypeVar('P_IN', default=Any)
P_OUT = TypeVar('P_OUT', default=Any)
R = TypeVar('R', default=Any)
K = TypeVar('K', default=Any)
T = TypeVar('T', default=Any)
A = TypeVar('A', default=Any)
RR = TypeVar('RR', default=Any)
U = TypeVar('U', default=Any)
D = TypeVar('D', default=Any)
M = TypeVar('M', default=Any)
R1 = TypeVar('R1', default=Any)
R2 = TypeVar('R2', default=Any)
C = TypeVar('C', default=Any)
V = TypeVar('V', default=Any)
O = TypeVar('O', default=Any)
OfRef_T = TypeVar('OfRef_T', default=Any)
Builder_T = TypeVar('Builder_T', default=Any)
OfPrimitive_T = TypeVar('OfPrimitive_T', default=Any)
T_CONS = TypeVar('T_CONS', default=Any)
T_ARR = TypeVar('T_ARR', default=Any)
T_SPLITR = TypeVar('T_SPLITR', default=Any)
T_NODE = TypeVar('T_NODE', default=Any)
E = TypeVar('E', default=Any)
T_SINK = TypeVar('T_SINK', default=Any)
OfDouble_P_IN = TypeVar('OfDouble_P_IN', default=Any)
OfLong_P_IN = TypeVar('OfLong_P_IN', default=Any)
OfInt_P_IN = TypeVar('OfInt_P_IN', default=Any)
OfRef_P_IN = TypeVar('OfRef_P_IN', default=Any)
OfRef_P_OUT = TypeVar('OfRef_P_OUT', default=Any)
T_BUILDER = TypeVar('T_BUILDER', default=Any)
OfPrimitive_T_NODE = TypeVar('OfPrimitive_T_NODE', default=Any)
N = TypeVar('N', default=Any)
OfPrimitive_N = TypeVar('OfPrimitive_N', default=Any)
I = TypeVar('I', default=Any)
ChainedReference_T = TypeVar('ChainedReference_T', default=Any)
OfPrimitive_E = TypeVar('OfPrimitive_E', default=Any)

class AbstractPipeline[E_IN, E_OUT, S](PipelineHelper):

  @overload
  def close(self) -> None: ...

  @overload
  def close(self) -> None: ...

  @overload
  def isParallel(self) -> bool: ...

  @overload
  def isParallel(self) -> bool: ...

  def iterator(self) -> Iterator[T]: ...

  @overload
  def onClose(self, arg0: Runnable) -> S: ...

  @overload
  def onClose(self, arg0: Runnable) -> S: ...

  @overload
  def parallel(self) -> S: ...

  @overload
  def parallel(self) -> S: ...

  @overload
  def sequential(self) -> S: ...

  @overload
  def sequential(self) -> S: ...

  @overload
  def spliterator(self) -> Spliterator[E_OUT]: ...

  @overload
  def spliterator(self) -> Spliterator[T]: ...

  def unordered(self) -> S: ...


class AbstractShortCircuitTask[P_IN, P_OUT, R, K](AbstractTask):

  def compute(self) -> None: ...

  def getLocalResult(self) -> object: ...

  def getRawResult(self) -> object: ...


class AbstractSpinedBuffer:

  MAX_CHUNK_POWER: int

  MIN_CHUNK_POWER: int

  MIN_CHUNK_SIZE: int

  MIN_SPINE_SIZE: int

  def clear(self) -> None: ...

  def count(self) -> int: ...

  def isEmpty(self) -> bool: ...


class AbstractTask[P_IN, P_OUT, R, K](CountedCompleter):

  def compute(self) -> None: ...

  def getRawResult(self) -> object: ...

  def onCompletion(self, arg0: CountedCompleter[Any]) -> None: ...

  @staticmethod
  def getLeafTarget() -> int: ...

  @staticmethod
  def suggestTargetSize(arg0: int) -> int: ...


class BaseStream[T, S]:

  @overload
  def close(self) -> None: ...

  @overload
  def close(self) -> None: ...

  def isParallel(self) -> bool: ...

  def iterator(self) -> Iterator[T]: ...

  def onClose(self, arg0: Runnable) -> S: ...

  def parallel(self) -> S: ...

  def sequential(self) -> S: ...

  def spliterator(self) -> Spliterator[T]: ...

  def unordered(self) -> S: ...


class Collector[T, A, R]:

  def accumulator(self) -> BiConsumer[A, T]: ...

  def characteristics(self) -> Set[Collector.Characteristics]: ...

  def combiner(self) -> BinaryOperator[A]: ...

  def finisher(self) -> Function[A, R]: ...

  def supplier(self) -> Supplier[A]: ...

  @staticmethod
  @overload
  def of(arg0: Supplier[R], arg1: BiConsumer[R, T], arg2: BinaryOperator[R], arg3: list[Collector.Characteristics]) -> Collector[T, R, R]: ...

  @staticmethod
  @overload
  def of(arg0: Supplier[A], arg1: BiConsumer[A, T], arg2: BinaryOperator[A], arg3: Function[A, R], arg4: list[Collector.Characteristics]) -> Collector[T, A, R]: ...

  class Characteristics(Enum):

    CONCURRENT: Collector.Characteristics

    IDENTITY_FINISH: Collector.Characteristics

    UNORDERED: Collector.Characteristics

    @staticmethod
    def valueOf(arg0: str) -> Collector.Characteristics: ...

    @staticmethod
    def values() -> list[Collector.Characteristics]: ...


class Collectors:

  @staticmethod
  def averagingDouble(arg0: ToDoubleFunction[T]) -> Collector[T, Any, Double]: ...

  @staticmethod
  def averagingInt(arg0: ToIntFunction[T]) -> Collector[T, Any, Double]: ...

  @staticmethod
  def averagingLong(arg0: ToLongFunction[T]) -> Collector[T, Any, Double]: ...

  @staticmethod
  def collectingAndThen(arg0: Collector[T, A, R], arg1: Function[R, RR]) -> Collector[T, A, RR]: ...

  @staticmethod
  def counting() -> Collector[T, Any, Long]: ...

  @staticmethod
  def filtering(arg0: Predicate[T], arg1: Collector[T, A, R]) -> Collector[T, Any, R]: ...

  @staticmethod
  def flatMapping(arg0: Function[T, Stream[U]], arg1: Collector[U, A, R]) -> Collector[T, Any, R]: ...

  @staticmethod
  @overload
  def groupingBy(arg0: Function[T, K]) -> Collector[T, Any, Map[K, List[T]]]: ...

  @staticmethod
  @overload
  def groupingBy(arg0: Function[T, K], arg1: Collector[T, A, D]) -> Collector[T, Any, Map[K, D]]: ...

  @staticmethod
  @overload
  def groupingBy(arg0: Function[T, K], arg1: Supplier[M], arg2: Collector[T, A, D]) -> Collector[T, Any, M]: ...

  @staticmethod
  @overload
  def groupingByConcurrent(arg0: Function[T, K]) -> Collector[T, Any, ConcurrentMap[K, List[T]]]: ...

  @staticmethod
  @overload
  def groupingByConcurrent(arg0: Function[T, K], arg1: Collector[T, A, D]) -> Collector[T, Any, ConcurrentMap[K, D]]: ...

  @staticmethod
  @overload
  def groupingByConcurrent(arg0: Function[T, K], arg1: Supplier[M], arg2: Collector[T, A, D]) -> Collector[T, Any, M]: ...

  @staticmethod
  @overload
  def joining() -> Collector[CharSequence, Any, str]: ...

  @staticmethod
  @overload
  def joining(arg0: CharSequence) -> Collector[CharSequence, Any, str]: ...

  @staticmethod
  @overload
  def joining(arg0: CharSequence, arg1: CharSequence, arg2: CharSequence) -> Collector[CharSequence, Any, str]: ...

  @staticmethod
  def mapping(arg0: Function[T, U], arg1: Collector[U, A, R]) -> Collector[T, Any, R]: ...

  @staticmethod
  def maxBy(arg0: Comparator[T]) -> Collector[T, Any, Optional[T]]: ...

  @staticmethod
  def minBy(arg0: Comparator[T]) -> Collector[T, Any, Optional[T]]: ...

  @staticmethod
  @overload
  def partitioningBy(arg0: Predicate[T]) -> Collector[T, Any, Map[Boolean, List[T]]]: ...

  @staticmethod
  @overload
  def partitioningBy(arg0: Predicate[T], arg1: Collector[T, A, D]) -> Collector[T, Any, Map[Boolean, D]]: ...

  @staticmethod
  @overload
  def reducing(arg0: BinaryOperator[T]) -> Collector[T, Any, Optional[T]]: ...

  @staticmethod
  @overload
  def reducing(arg0: object, arg1: BinaryOperator[T]) -> Collector[T, Any, T]: ...

  @staticmethod
  @overload
  def reducing(arg0: object, arg1: Function[T, U], arg2: BinaryOperator[U]) -> Collector[T, Any, U]: ...

  @staticmethod
  def summarizingDouble(arg0: ToDoubleFunction[T]) -> Collector[T, Any, DoubleSummaryStatistics]: ...

  @staticmethod
  def summarizingInt(arg0: ToIntFunction[T]) -> Collector[T, Any, IntSummaryStatistics]: ...

  @staticmethod
  def summarizingLong(arg0: ToLongFunction[T]) -> Collector[T, Any, LongSummaryStatistics]: ...

  @staticmethod
  def summingDouble(arg0: ToDoubleFunction[T]) -> Collector[T, Any, Double]: ...

  @staticmethod
  def summingInt(arg0: ToIntFunction[T]) -> Collector[T, Any, Integer]: ...

  @staticmethod
  def summingLong(arg0: ToLongFunction[T]) -> Collector[T, Any, Long]: ...

  @staticmethod
  def teeing(arg0: Collector[T, Any, R1], arg1: Collector[T, Any, R2], arg2: BiFunction[R1, R2, R]) -> Collector[T, Any, R]: ...

  @staticmethod
  def toCollection(arg0: Supplier[C]) -> Collector[T, Any, C]: ...

  @staticmethod
  @overload
  def toConcurrentMap(arg0: Function[T, K], arg1: Function[T, U]) -> Collector[T, Any, ConcurrentMap[K, U]]: ...

  @staticmethod
  @overload
  def toConcurrentMap(arg0: Function[T, K], arg1: Function[T, U], arg2: BinaryOperator[U]) -> Collector[T, Any, ConcurrentMap[K, U]]: ...

  @staticmethod
  @overload
  def toConcurrentMap(arg0: Function[T, K], arg1: Function[T, U], arg2: BinaryOperator[U], arg3: Supplier[M]) -> Collector[T, Any, M]: ...

  @staticmethod
  def toList() -> Collector[T, Any, List[T]]: ...

  @staticmethod
  @overload
  def toMap(arg0: Function[T, K], arg1: Function[T, U]) -> Collector[T, Any, Map[K, U]]: ...

  @staticmethod
  @overload
  def toMap(arg0: Function[T, K], arg1: Function[T, U], arg2: BinaryOperator[U]) -> Collector[T, Any, Map[K, U]]: ...

  @staticmethod
  @overload
  def toMap(arg0: Function[T, K], arg1: Function[T, U], arg2: BinaryOperator[U], arg3: Supplier[M]) -> Collector[T, Any, M]: ...

  @staticmethod
  def toSet() -> Collector[T, Any, Set[T]]: ...

  @staticmethod
  def toUnmodifiableList() -> Collector[T, Any, List[T]]: ...

  @staticmethod
  @overload
  def toUnmodifiableMap(arg0: Function[T, K], arg1: Function[T, U]) -> Collector[T, Any, Map[K, U]]: ...

  @staticmethod
  @overload
  def toUnmodifiableMap(arg0: Function[T, K], arg1: Function[T, U], arg2: BinaryOperator[U]) -> Collector[T, Any, Map[K, U]]: ...

  @staticmethod
  def toUnmodifiableSet() -> Collector[T, Any, Set[T]]: ...

  class CollectorImpl[T, A, R]:

    @overload
    def accumulator(self) -> BiConsumer[A, T]: ...

    @overload
    def accumulator(self) -> BiConsumer[A, T]: ...

    @overload
    def characteristics(self) -> Set[Collector.Characteristics]: ...

    @overload
    def characteristics(self) -> Set[Collector.Characteristics]: ...

    @overload
    def combiner(self) -> BinaryOperator[A]: ...

    @overload
    def combiner(self) -> BinaryOperator[A]: ...

    @overload
    def finisher(self) -> Function[A, R]: ...

    @overload
    def finisher(self) -> Function[A, R]: ...

    @overload
    def supplier(self) -> Supplier[A]: ...

    @overload
    def supplier(self) -> Supplier[A]: ...

    @staticmethod
    @overload
    def of(arg0: Supplier[R], arg1: BiConsumer[R, T], arg2: BinaryOperator[R], arg3: list[Collector.Characteristics]) -> Collector[T, R, R]: ...

    @staticmethod
    @overload
    def of(arg0: Supplier[A], arg1: BiConsumer[A, T], arg2: BinaryOperator[A], arg3: Function[A, R], arg4: list[Collector.Characteristics]) -> Collector[T, A, R]: ...

  class Partition[T](AbstractMap):

    def clear(self) -> None: ...

    def compute(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    def computeIfAbsent(self, arg0: object, arg1: Function[K, V]) -> object: ...

    def computeIfPresent(self, arg0: object, arg1: BiFunction[K, V, V]) -> object: ...

    def containsKey(self, arg0: object) -> bool: ...

    def containsValue(self, arg0: object) -> bool: ...

    @overload
    def entrySet(self) -> Set[Map.Entry[Boolean, T]]: ...

    @overload
    def entrySet(self) -> Set[Map.Entry[K, V]]: ...

    def equals(self, arg0: object) -> bool: ...

    def forEach(self, arg0: BiConsumer[K, V]) -> None: ...

    def get(self, arg0: object) -> object: ...

    def getOrDefault(self, arg0: object, arg1: object) -> object: ...

    def hashCode(self) -> int: ...

    def isEmpty(self) -> bool: ...

    def keySet(self) -> Set[K]: ...

    def merge(self, arg0: object, arg1: object, arg2: BiFunction[V, V, V]) -> object: ...

    def put(self, arg0: object, arg1: object) -> object: ...

    def putAll(self, arg0: Map[K, V]) -> None: ...

    def putIfAbsent(self, arg0: object, arg1: object) -> object: ...

    @overload
    def remove(self, arg0: object) -> object: ...

    @overload
    def remove(self, arg0: object, arg1: object) -> bool: ...

    @overload
    def replace(self, arg0: object, arg1: object) -> object: ...

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool: ...

    def replaceAll(self, arg0: BiFunction[K, V, V]) -> None: ...

    def size(self) -> int: ...

    def values(self) -> Collection[V]: ...

    @staticmethod
    def copyOf(arg0: Map[K, V]) -> Map[K, V]: ...

    @staticmethod
    def entry(arg0: object, arg1: object) -> Map.Entry: ...

    @staticmethod
    @overload
    def of() -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object) -> Map[K, V]: ...

    @staticmethod
    @overload
    def of(arg0: object, arg1: object, arg2: object, arg3: object, arg4: object, arg5: object, arg6: object, arg7: object, arg8: object, arg9: object, arg10: object, arg11: object, arg12: object, arg13: object, arg14: object, arg15: object, arg16: object, arg17: object, arg18: object, arg19: object) -> Map[K, V]: ...

    @staticmethod
    def ofEntries(arg0: list[Map.Entry]) -> Map[K, V]: ...


class DoubleStream:

  def allMatch(self, arg0: DoublePredicate) -> bool: ...

  def anyMatch(self, arg0: DoublePredicate) -> bool: ...

  def average(self) -> OptionalDouble: ...

  def boxed(self) -> Stream[Double]: ...

  def close(self) -> None: ...

  def collect(self, arg0: Supplier[R], arg1: ObjDoubleConsumer[R], arg2: BiConsumer[R, R]) -> object: ...

  def count(self) -> int: ...

  def distinct(self) -> DoubleStream: ...

  def dropWhile(self, arg0: DoublePredicate) -> DoubleStream: ...

  def filter(self, arg0: DoublePredicate) -> DoubleStream: ...

  def findAny(self) -> OptionalDouble: ...

  def findFirst(self) -> OptionalDouble: ...

  def flatMap(self, arg0: DoubleFunction[DoubleStream]) -> DoubleStream: ...

  def forEach(self, arg0: DoubleConsumer) -> None: ...

  def forEachOrdered(self, arg0: DoubleConsumer) -> None: ...

  def isParallel(self) -> bool: ...

  @overload
  def iterator(self) -> PrimitiveIterator.OfDouble: ...

  @overload
  def iterator(self) -> Iterator: ...

  @overload
  def iterator(self) -> Iterator[T]: ...

  def limit(self, arg0: int) -> DoubleStream: ...

  def map(self, arg0: DoubleUnaryOperator) -> DoubleStream: ...

  def mapMulti(self, arg0: DoubleStream.DoubleMapMultiConsumer) -> DoubleStream: ...

  def mapToInt(self, arg0: DoubleToIntFunction) -> IntStream: ...

  def mapToLong(self, arg0: DoubleToLongFunction) -> LongStream: ...

  def mapToObj(self, arg0: DoubleFunction[U]) -> Stream[U]: ...

  def max(self) -> OptionalDouble: ...

  def min(self) -> OptionalDouble: ...

  def noneMatch(self, arg0: DoublePredicate) -> bool: ...

  def onClose(self, arg0: Runnable) -> S: ...

  @overload
  def parallel(self) -> DoubleStream: ...

  @overload
  def parallel(self) -> BaseStream: ...

  @overload
  def parallel(self) -> S: ...

  def peek(self, arg0: DoubleConsumer) -> DoubleStream: ...

  @overload
  def reduce(self, arg0: DoubleBinaryOperator) -> OptionalDouble: ...

  @overload
  def reduce(self, arg0: float, arg1: DoubleBinaryOperator) -> float: ...

  @overload
  def sequential(self) -> DoubleStream: ...

  @overload
  def sequential(self) -> BaseStream: ...

  @overload
  def sequential(self) -> S: ...

  def skip(self, arg0: int) -> DoubleStream: ...

  def sorted(self) -> DoubleStream: ...

  @overload
  def spliterator(self) -> Spliterator: ...

  @overload
  def spliterator(self) -> Spliterator.OfDouble: ...

  @overload
  def spliterator(self) -> Spliterator[T]: ...

  def sum(self) -> float: ...

  def summaryStatistics(self) -> DoubleSummaryStatistics: ...

  def takeWhile(self, arg0: DoublePredicate) -> DoubleStream: ...

  def toArray(self) -> list[float]: ...

  def unordered(self) -> S: ...

  @staticmethod
  def builder() -> DoubleStream.Builder: ...

  @staticmethod
  def concat(arg0: DoubleStream, arg1: DoubleStream) -> DoubleStream: ...

  @staticmethod
  def empty() -> DoubleStream: ...

  @staticmethod
  def generate(arg0: DoubleSupplier) -> DoubleStream: ...

  @staticmethod
  @overload
  def iterate(arg0: float, arg1: DoubleUnaryOperator) -> DoubleStream: ...

  @staticmethod
  @overload
  def iterate(arg0: float, arg1: DoublePredicate, arg2: DoubleUnaryOperator) -> DoubleStream: ...

  @staticmethod
  @overload
  def of(arg0: list[float]) -> DoubleStream: ...

  @staticmethod
  @overload
  def of(arg0: float) -> DoubleStream: ...

  class DoubleMapMultiConsumer:

    def accept(self, arg0: float, arg1: DoubleConsumer) -> None: ...

  class Builder:

    @overload
    def accept(self, arg0: float) -> None: ...

    @overload
    def accept(self, arg0: float) -> None: ...

    def add(self, arg0: float) -> DoubleStream.Builder: ...

    def andThen(self, arg0: DoubleConsumer) -> DoubleConsumer: ...

    def build(self) -> DoubleStream: ...


class FindOps:

  @staticmethod
  def makeDouble(arg0: bool) -> TerminalOp[Double, OptionalDouble]: ...

  @staticmethod
  def makeInt(arg0: bool) -> TerminalOp[Integer, OptionalInt]: ...

  @staticmethod
  def makeLong(arg0: bool) -> TerminalOp[Long, OptionalLong]: ...

  @staticmethod
  def makeRef(arg0: bool) -> TerminalOp[T, Optional[T]]: ...

  class FindSink[T, O]:

    def accept(self, arg0: object) -> None: ...

    def cancellationRequested(self) -> bool: ...

    class OfDouble(FindOps.FindSink):

      @overload
      def accept(self, arg0: float) -> None: ...

      @overload
      def accept(self, arg0: float) -> None: ...

      @overload
      def accept(self, arg0: Double) -> None: ...

      @overload
      def accept(self, arg0: Double) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      @overload
      def get(self) -> object: ...

      @overload
      def get(self) -> OptionalDouble: ...

    class OfLong(FindOps.FindSink):

      @overload
      def accept(self, arg0: Long) -> None: ...

      @overload
      def accept(self, arg0: Long) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def get(self) -> object: ...

      @overload
      def get(self) -> OptionalLong: ...

    class OfInt(FindOps.FindSink):

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: Integer) -> None: ...

      @overload
      def accept(self, arg0: Integer) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      @overload
      def get(self) -> object: ...

      @overload
      def get(self) -> OptionalInt: ...

    class OfRef[OfRef_T](FindOps.FindSink):

      @overload
      def get(self) -> Optional[T]: ...

      @overload
      def get(self) -> object: ...

  class FindTask[P_IN, P_OUT, O](AbstractShortCircuitTask):

    def onCompletion(self, arg0: CountedCompleter[Any]) -> None: ...

  class FindOp[T, O]:

    @overload
    def evaluateParallel(self, arg0: PipelineHelper[T], arg1: Spliterator[P_IN]) -> object: ...

    @overload
    def evaluateParallel(self, arg0: PipelineHelper[E_IN], arg1: Spliterator[P_IN]) -> object: ...

    @overload
    def evaluateSequential(self, arg0: PipelineHelper[T], arg1: Spliterator[S]) -> object: ...

    @overload
    def evaluateSequential(self, arg0: PipelineHelper[E_IN], arg1: Spliterator[P_IN]) -> object: ...

    @overload
    def getOpFlags(self) -> int: ...

    @overload
    def getOpFlags(self) -> int: ...

    @overload
    def inputShape(self) -> StreamShape: ...

    @overload
    def inputShape(self) -> StreamShape: ...


class IntStream:

  def allMatch(self, arg0: IntPredicate) -> bool: ...

  def anyMatch(self, arg0: IntPredicate) -> bool: ...

  def asDoubleStream(self) -> DoubleStream: ...

  def asLongStream(self) -> LongStream: ...

  def average(self) -> OptionalDouble: ...

  def boxed(self) -> Stream[Integer]: ...

  def close(self) -> None: ...

  def collect(self, arg0: Supplier[R], arg1: ObjIntConsumer[R], arg2: BiConsumer[R, R]) -> object: ...

  def count(self) -> int: ...

  def distinct(self) -> IntStream: ...

  def dropWhile(self, arg0: IntPredicate) -> IntStream: ...

  def filter(self, arg0: IntPredicate) -> IntStream: ...

  def findAny(self) -> OptionalInt: ...

  def findFirst(self) -> OptionalInt: ...

  def flatMap(self, arg0: IntFunction[IntStream]) -> IntStream: ...

  def forEach(self, arg0: IntConsumer) -> None: ...

  def forEachOrdered(self, arg0: IntConsumer) -> None: ...

  def isParallel(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator: ...

  @overload
  def iterator(self) -> PrimitiveIterator.OfInt: ...

  @overload
  def iterator(self) -> Iterator[T]: ...

  def limit(self, arg0: int) -> IntStream: ...

  def map(self, arg0: IntUnaryOperator) -> IntStream: ...

  def mapMulti(self, arg0: IntStream.IntMapMultiConsumer) -> IntStream: ...

  def mapToDouble(self, arg0: IntToDoubleFunction) -> DoubleStream: ...

  def mapToLong(self, arg0: IntToLongFunction) -> LongStream: ...

  def mapToObj(self, arg0: IntFunction[U]) -> Stream[U]: ...

  def max(self) -> OptionalInt: ...

  def min(self) -> OptionalInt: ...

  def noneMatch(self, arg0: IntPredicate) -> bool: ...

  def onClose(self, arg0: Runnable) -> S: ...

  @overload
  def parallel(self) -> BaseStream: ...

  @overload
  def parallel(self) -> IntStream: ...

  @overload
  def parallel(self) -> S: ...

  def peek(self, arg0: IntConsumer) -> IntStream: ...

  @overload
  def reduce(self, arg0: IntBinaryOperator) -> OptionalInt: ...

  @overload
  def reduce(self, arg0: int, arg1: IntBinaryOperator) -> int: ...

  @overload
  def sequential(self) -> BaseStream: ...

  @overload
  def sequential(self) -> IntStream: ...

  @overload
  def sequential(self) -> S: ...

  def skip(self, arg0: int) -> IntStream: ...

  def sorted(self) -> IntStream: ...

  @overload
  def spliterator(self) -> Spliterator.OfInt: ...

  @overload
  def spliterator(self) -> Spliterator: ...

  @overload
  def spliterator(self) -> Spliterator[T]: ...

  def sum(self) -> int: ...

  def summaryStatistics(self) -> IntSummaryStatistics: ...

  def takeWhile(self, arg0: IntPredicate) -> IntStream: ...

  def toArray(self) -> list[int]: ...

  def unordered(self) -> S: ...

  @staticmethod
  def builder() -> IntStream.Builder: ...

  @staticmethod
  def concat(arg0: IntStream, arg1: IntStream) -> IntStream: ...

  @staticmethod
  def empty() -> IntStream: ...

  @staticmethod
  def generate(arg0: IntSupplier) -> IntStream: ...

  @staticmethod
  @overload
  def iterate(arg0: int, arg1: IntUnaryOperator) -> IntStream: ...

  @staticmethod
  @overload
  def iterate(arg0: int, arg1: IntPredicate, arg2: IntUnaryOperator) -> IntStream: ...

  @staticmethod
  @overload
  def of(arg0: list[int]) -> IntStream: ...

  @staticmethod
  @overload
  def of(arg0: int) -> IntStream: ...

  @staticmethod
  def range(arg0: int, arg1: int) -> IntStream: ...

  @staticmethod
  def rangeClosed(arg0: int, arg1: int) -> IntStream: ...

  class IntMapMultiConsumer:

    def accept(self, arg0: int, arg1: IntConsumer) -> None: ...

  class Builder:

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    def add(self, arg0: int) -> IntStream.Builder: ...

    def andThen(self, arg0: IntConsumer) -> IntConsumer: ...

    def build(self) -> IntStream: ...


class LongStream:

  def allMatch(self, arg0: LongPredicate) -> bool: ...

  def anyMatch(self, arg0: LongPredicate) -> bool: ...

  def asDoubleStream(self) -> DoubleStream: ...

  def average(self) -> OptionalDouble: ...

  def boxed(self) -> Stream[Long]: ...

  def close(self) -> None: ...

  def collect(self, arg0: Supplier[R], arg1: ObjLongConsumer[R], arg2: BiConsumer[R, R]) -> object: ...

  def count(self) -> int: ...

  def distinct(self) -> LongStream: ...

  def dropWhile(self, arg0: LongPredicate) -> LongStream: ...

  def filter(self, arg0: LongPredicate) -> LongStream: ...

  def findAny(self) -> OptionalLong: ...

  def findFirst(self) -> OptionalLong: ...

  def flatMap(self, arg0: LongFunction[LongStream]) -> LongStream: ...

  def forEach(self, arg0: LongConsumer) -> None: ...

  def forEachOrdered(self, arg0: LongConsumer) -> None: ...

  def isParallel(self) -> bool: ...

  @overload
  def iterator(self) -> Iterator: ...

  @overload
  def iterator(self) -> PrimitiveIterator.OfLong: ...

  @overload
  def iterator(self) -> Iterator[T]: ...

  def limit(self, arg0: int) -> LongStream: ...

  def map(self, arg0: LongUnaryOperator) -> LongStream: ...

  def mapMulti(self, arg0: LongStream.LongMapMultiConsumer) -> LongStream: ...

  def mapToDouble(self, arg0: LongToDoubleFunction) -> DoubleStream: ...

  def mapToInt(self, arg0: LongToIntFunction) -> IntStream: ...

  def mapToObj(self, arg0: LongFunction[U]) -> Stream[U]: ...

  def max(self) -> OptionalLong: ...

  def min(self) -> OptionalLong: ...

  def noneMatch(self, arg0: LongPredicate) -> bool: ...

  def onClose(self, arg0: Runnable) -> S: ...

  @overload
  def parallel(self) -> LongStream: ...

  @overload
  def parallel(self) -> BaseStream: ...

  @overload
  def parallel(self) -> S: ...

  def peek(self, arg0: LongConsumer) -> LongStream: ...

  @overload
  def reduce(self, arg0: LongBinaryOperator) -> OptionalLong: ...

  @overload
  def reduce(self, arg0: int, arg1: LongBinaryOperator) -> int: ...

  @overload
  def sequential(self) -> LongStream: ...

  @overload
  def sequential(self) -> BaseStream: ...

  @overload
  def sequential(self) -> S: ...

  def skip(self, arg0: int) -> LongStream: ...

  def sorted(self) -> LongStream: ...

  @overload
  def spliterator(self) -> Spliterator.OfLong: ...

  @overload
  def spliterator(self) -> Spliterator: ...

  @overload
  def spliterator(self) -> Spliterator[T]: ...

  def sum(self) -> int: ...

  def summaryStatistics(self) -> LongSummaryStatistics: ...

  def takeWhile(self, arg0: LongPredicate) -> LongStream: ...

  def toArray(self) -> list[int]: ...

  def unordered(self) -> S: ...

  @staticmethod
  def builder() -> LongStream.Builder: ...

  @staticmethod
  def concat(arg0: LongStream, arg1: LongStream) -> LongStream: ...

  @staticmethod
  def empty() -> LongStream: ...

  @staticmethod
  def generate(arg0: LongSupplier) -> LongStream: ...

  @staticmethod
  @overload
  def iterate(arg0: int, arg1: LongUnaryOperator) -> LongStream: ...

  @staticmethod
  @overload
  def iterate(arg0: int, arg1: LongPredicate, arg2: LongUnaryOperator) -> LongStream: ...

  @staticmethod
  @overload
  def of(arg0: list[int]) -> LongStream: ...

  @staticmethod
  @overload
  def of(arg0: int) -> LongStream: ...

  @staticmethod
  def range(arg0: int, arg1: int) -> LongStream: ...

  @staticmethod
  def rangeClosed(arg0: int, arg1: int) -> LongStream: ...

  class LongMapMultiConsumer:

    def accept(self, arg0: int, arg1: LongConsumer) -> None: ...

  class Builder:

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    def add(self, arg0: int) -> LongStream.Builder: ...

    def andThen(self, arg0: LongConsumer) -> LongConsumer: ...

    def build(self) -> LongStream: ...


class Node[T]:

  def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

  def copyInto(self, arg0: list[object], arg1: int) -> None: ...

  def count(self) -> int: ...

  def forEach(self, arg0: Consumer[T]) -> None: ...

  def getChild(self, arg0: int) -> Node[T]: ...

  def getChildCount(self) -> int: ...

  def getShape(self) -> StreamShape: ...

  def spliterator(self) -> Spliterator[T]: ...

  def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node[T]: ...

  class Builder[Builder_T]:

    @overload
    def accept(self, arg0: float) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    def begin(self, arg0: int) -> None: ...

    def build(self) -> Node[T]: ...

    def cancellationRequested(self) -> bool: ...

    def end(self) -> None: ...

    class OfDouble:

      @overload
      def accept(self, arg0: float) -> None: ...

      @overload
      def accept(self, arg0: Double) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      @overload
      def build(self) -> Node.OfDouble: ...

      @overload
      def build(self) -> Node: ...

      @overload
      def build(self) -> Node[T]: ...

    class OfLong:

      @overload
      def accept(self, arg0: Long) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def build(self) -> Node.OfLong: ...

      @overload
      def build(self) -> Node: ...

      @overload
      def build(self) -> Node[T]: ...

    class OfInt:

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: Integer) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      @overload
      def build(self) -> Node.OfInt: ...

      @overload
      def build(self) -> Node: ...

      @overload
      def build(self) -> Node[T]: ...

  class OfDouble:

    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    def asPrimitiveArray(self) -> object: ...

    @overload
    def copyInto(self, arg0: list[Double], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: object, arg1: int) -> None: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[Double]) -> None: ...

    @overload
    def getChild(self, arg0: int) -> Node.OfPrimitive: ...

    @overload
    def getChild(self, arg0: int) -> Node: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def newArray(self, arg0: int) -> list[float]: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfPrimitive: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Double]) -> Node.OfDouble: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node.OfPrimitive: ...

  class OfLong:

    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    def asPrimitiveArray(self) -> object: ...

    @overload
    def copyInto(self, arg0: list[Long], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: object, arg1: int) -> None: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[Long]) -> None: ...

    @overload
    def getChild(self, arg0: int) -> Node.OfPrimitive: ...

    @overload
    def getChild(self, arg0: int) -> Node: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def newArray(self, arg0: int) -> list[int]: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfPrimitive: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Long]) -> Node.OfLong: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node.OfPrimitive: ...

  class OfInt:

    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    def asPrimitiveArray(self) -> object: ...

    @overload
    def copyInto(self, arg0: list[Integer], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: object, arg1: int) -> None: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[Integer]) -> None: ...

    @overload
    def getChild(self, arg0: int) -> Node.OfPrimitive: ...

    @overload
    def getChild(self, arg0: int) -> Node: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def newArray(self, arg0: int) -> list[int]: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfPrimitive: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Integer]) -> Node.OfInt: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node.OfPrimitive: ...

  class OfPrimitive[OfPrimitive_T, T_CONS, T_ARR, T_SPLITR, T_NODE]:

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    def asPrimitiveArray(self) -> object: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: object, arg1: int) -> None: ...

    def count(self) -> int: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[T]) -> None: ...

    @overload
    def getChild(self, arg0: int) -> Node.OfPrimitive: ...

    @overload
    def getChild(self, arg0: int) -> Node: ...

    @overload
    def getChild(self, arg0: int) -> Node[T]: ...

    def getChildCount(self) -> int: ...

    def getShape(self) -> StreamShape: ...

    def newArray(self, arg0: int) -> object: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfPrimitive: ...

    @overload
    def spliterator(self) -> Spliterator[T]: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node.OfPrimitive: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node[T]: ...


class Nodes:

  @staticmethod
  def collect(arg0: PipelineHelper[P_OUT], arg1: Spliterator[P_IN], arg2: bool, arg3: IntFunction[P_OUT]) -> Node[P_OUT]: ...

  @staticmethod
  def collectDouble(arg0: PipelineHelper[Double], arg1: Spliterator[P_IN], arg2: bool) -> Node.OfDouble: ...

  @staticmethod
  def collectInt(arg0: PipelineHelper[Integer], arg1: Spliterator[P_IN], arg2: bool) -> Node.OfInt: ...

  @staticmethod
  def collectLong(arg0: PipelineHelper[Long], arg1: Spliterator[P_IN], arg2: bool) -> Node.OfLong: ...

  @staticmethod
  def flatten(arg0: Node[T], arg1: IntFunction[T]) -> Node[T]: ...

  @staticmethod
  def flattenDouble(arg0: Node.OfDouble) -> Node.OfDouble: ...

  @staticmethod
  def flattenInt(arg0: Node.OfInt) -> Node.OfInt: ...

  @staticmethod
  def flattenLong(arg0: Node.OfLong) -> Node.OfLong: ...

  class ConcNode[T](Nodes.AbstractConcNode):

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    def count(self) -> int: ...

    @overload
    def forEach(self, arg0: Consumer[T]) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[T]) -> None: ...

    def getChild(self, arg0: int) -> Node[T]: ...

    def getChildCount(self) -> int: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def spliterator(self) -> Spliterator[T]: ...

    @overload
    def spliterator(self) -> Spliterator[T]: ...

    def toString(self) -> str: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node[T]: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node[T]: ...

    class OfDouble(Nodes.ConcNode.OfPrimitive):

      @overload
      def copyInto(self, arg0: list[Double], arg1: int) -> None: ...

      @overload
      def copyInto(self, arg0: list[object], arg1: int) -> None: ...

      def forEach(self, arg0: Consumer[Double]) -> None: ...

      def getShape(self) -> StreamShape: ...

      @overload
      def newArray(self, arg0: int) -> object: ...

      @overload
      def newArray(self, arg0: int) -> list[float]: ...

      @overload
      def spliterator(self) -> Spliterator: ...

      @overload
      def spliterator(self) -> Spliterator.OfPrimitive: ...

      @overload
      def spliterator(self) -> Spliterator.OfDouble: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Double]) -> Node.OfDouble: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

    class OfLong(Nodes.ConcNode.OfPrimitive):

      @overload
      def copyInto(self, arg0: list[Long], arg1: int) -> None: ...

      @overload
      def copyInto(self, arg0: list[object], arg1: int) -> None: ...

      def forEach(self, arg0: Consumer[Long]) -> None: ...

      def getShape(self) -> StreamShape: ...

      @overload
      def newArray(self, arg0: int) -> object: ...

      @overload
      def newArray(self, arg0: int) -> list[int]: ...

      @overload
      def spliterator(self) -> Spliterator: ...

      @overload
      def spliterator(self) -> Spliterator.OfPrimitive: ...

      @overload
      def spliterator(self) -> Spliterator.OfLong: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Long]) -> Node.OfLong: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

    class OfInt(Nodes.ConcNode.OfPrimitive):

      @overload
      def copyInto(self, arg0: list[Integer], arg1: int) -> None: ...

      @overload
      def copyInto(self, arg0: list[object], arg1: int) -> None: ...

      def forEach(self, arg0: Consumer[Integer]) -> None: ...

      def getShape(self) -> StreamShape: ...

      @overload
      def newArray(self, arg0: int) -> object: ...

      @overload
      def newArray(self, arg0: int) -> list[int]: ...

      @overload
      def spliterator(self) -> Spliterator: ...

      @overload
      def spliterator(self) -> Spliterator.OfPrimitive: ...

      @overload
      def spliterator(self) -> Spliterator.OfInt: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Integer]) -> Node.OfInt: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

    class OfPrimitive[E, T_CONS, T_ARR, T_SPLITR, T_NODE](Nodes.AbstractConcNode):

      def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

      @overload
      def asPrimitiveArray(self) -> object: ...

      @overload
      def asPrimitiveArray(self) -> object: ...

      @overload
      def copyInto(self, arg0: object, arg1: int) -> None: ...

      @overload
      def copyInto(self, arg0: object, arg1: int) -> None: ...

      @overload
      def forEach(self, arg0: object) -> None: ...

      @overload
      def forEach(self, arg0: object) -> None: ...

      @overload
      def getChild(self, arg0: int) -> Node.OfPrimitive: ...

      @overload
      def getChild(self, arg0: int) -> Node.OfPrimitive: ...

      @overload
      def getChild(self, arg0: int) -> Node: ...

      def newArray(self, arg0: int) -> object: ...

      @overload
      def spliterator(self) -> Spliterator: ...

      @overload
      def spliterator(self) -> Spliterator.OfPrimitive: ...

      def toString(self) -> str: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node.OfPrimitive: ...

  class ArrayNode[T]:

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def count(self) -> int: ...

    @overload
    def count(self) -> int: ...

    @overload
    def forEach(self, arg0: Consumer[T]) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[T]) -> None: ...

    def getChild(self, arg0: int) -> Node[T]: ...

    def getChildCount(self) -> int: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def spliterator(self) -> Spliterator[T]: ...

    @overload
    def spliterator(self) -> Spliterator[T]: ...

    def toString(self) -> str: ...

    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node[T]: ...

  class CollectionNode[T]:

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def count(self) -> int: ...

    @overload
    def count(self) -> int: ...

    @overload
    def forEach(self, arg0: Consumer[T]) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[T]) -> None: ...

    def getChild(self, arg0: int) -> Node[T]: ...

    def getChildCount(self) -> int: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def spliterator(self) -> Spliterator[T]: ...

    @overload
    def spliterator(self) -> Spliterator[T]: ...

    def toString(self) -> str: ...

    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node[T]: ...

  class FixedNodeBuilder[T](Nodes.ArrayNode):

    def accept(self, arg0: object) -> None: ...

    def begin(self, arg0: int) -> None: ...

    @overload
    def build(self) -> Node[T]: ...

    @overload
    def build(self) -> Node[T]: ...

    def end(self) -> None: ...

    def toString(self) -> str: ...

  class SpinedNodeBuilder[T](SpinedBuffer):

    def accept(self, arg0: object) -> None: ...

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    def begin(self, arg0: int) -> None: ...

    @overload
    def build(self) -> Node[T]: ...

    @overload
    def build(self) -> Node[T]: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    def count(self) -> int: ...

    def end(self) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[T]) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[T]) -> None: ...

    def getChild(self, arg0: int) -> Node[T]: ...

    def getChildCount(self) -> int: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def spliterator(self) -> Spliterator[T]: ...

    @overload
    def spliterator(self) -> Spliterator[T]: ...

    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node[T]: ...

  class IntArrayNode:

    @overload
    def asPrimitiveArray(self) -> list[int]: ...

    @overload
    def asPrimitiveArray(self) -> object: ...

    @overload
    def copyInto(self, arg0: list[int], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[Integer], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: object, arg1: int) -> None: ...

    def count(self) -> int: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[Integer]) -> None: ...

    @overload
    def forEach(self, arg0: IntConsumer) -> None: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def newArray(self, arg0: int) -> list[int]: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfPrimitive: ...

    @overload
    def spliterator(self) -> Spliterator.OfInt: ...

    def toString(self) -> str: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Integer]) -> Node.OfInt: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

  class IntFixedNodeBuilder(Nodes.IntArrayNode):

    def accept(self, arg0: int) -> None: ...

    def begin(self, arg0: int) -> None: ...

    @overload
    def build(self) -> Node.OfInt: ...

    @overload
    def build(self) -> Node: ...

    @overload
    def build(self) -> Node.OfInt: ...

    @overload
    def build(self) -> Node: ...

    def end(self) -> None: ...

    def toString(self) -> str: ...

  class IntSpinedNodeBuilder(SpinedBuffer.OfInt):

    def accept(self, arg0: int) -> None: ...

    @overload
    def asPrimitiveArray(self) -> object: ...

    @overload
    def asPrimitiveArray(self) -> list[int]: ...

    def begin(self, arg0: int) -> None: ...

    @overload
    def build(self) -> Node.OfInt: ...

    @overload
    def build(self) -> Node: ...

    @overload
    def build(self) -> Node.OfInt: ...

    @overload
    def build(self) -> Node: ...

    @overload
    def copyInto(self, arg0: list[int], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[Integer], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: object, arg1: int) -> None: ...

    def end(self) -> None: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[Integer]) -> None: ...

    @overload
    def forEach(self, arg0: IntConsumer) -> None: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def newArray(self, arg0: int) -> list[int]: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfInt: ...

    @overload
    def spliterator(self) -> Spliterator.OfPrimitive: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Integer]) -> Node.OfInt: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

  class LongArrayNode:

    @overload
    def asPrimitiveArray(self) -> list[int]: ...

    @overload
    def asPrimitiveArray(self) -> object: ...

    @overload
    def copyInto(self, arg0: list[int], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[Long], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: object, arg1: int) -> None: ...

    def count(self) -> int: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[Long]) -> None: ...

    @overload
    def forEach(self, arg0: LongConsumer) -> None: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def newArray(self, arg0: int) -> list[int]: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfPrimitive: ...

    @overload
    def spliterator(self) -> Spliterator.OfLong: ...

    def toString(self) -> str: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Long]) -> Node.OfLong: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

  class LongFixedNodeBuilder(Nodes.LongArrayNode):

    def accept(self, arg0: int) -> None: ...

    def begin(self, arg0: int) -> None: ...

    @overload
    def build(self) -> Node.OfLong: ...

    @overload
    def build(self) -> Node: ...

    @overload
    def build(self) -> Node.OfLong: ...

    @overload
    def build(self) -> Node: ...

    def end(self) -> None: ...

    def toString(self) -> str: ...

  class LongSpinedNodeBuilder(SpinedBuffer.OfLong):

    def accept(self, arg0: int) -> None: ...

    @overload
    def asPrimitiveArray(self) -> object: ...

    @overload
    def asPrimitiveArray(self) -> list[int]: ...

    def begin(self, arg0: int) -> None: ...

    @overload
    def build(self) -> Node.OfLong: ...

    @overload
    def build(self) -> Node: ...

    @overload
    def build(self) -> Node.OfLong: ...

    @overload
    def build(self) -> Node: ...

    @overload
    def copyInto(self, arg0: list[int], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[Long], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: object, arg1: int) -> None: ...

    def end(self) -> None: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[Long]) -> None: ...

    @overload
    def forEach(self, arg0: LongConsumer) -> None: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def newArray(self, arg0: int) -> list[int]: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfLong: ...

    @overload
    def spliterator(self) -> Spliterator.OfPrimitive: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Long]) -> Node.OfLong: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

  class DoubleArrayNode:

    @overload
    def asPrimitiveArray(self) -> list[float]: ...

    @overload
    def asPrimitiveArray(self) -> object: ...

    @overload
    def copyInto(self, arg0: list[float], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[Double], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: object, arg1: int) -> None: ...

    def count(self) -> int: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[Double]) -> None: ...

    @overload
    def forEach(self, arg0: DoubleConsumer) -> None: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def newArray(self, arg0: int) -> list[float]: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfPrimitive: ...

    @overload
    def spliterator(self) -> Spliterator.OfDouble: ...

    def toString(self) -> str: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Double]) -> Node.OfDouble: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

  class DoubleFixedNodeBuilder(Nodes.DoubleArrayNode):

    def accept(self, arg0: float) -> None: ...

    def begin(self, arg0: int) -> None: ...

    @overload
    def build(self) -> Node.OfDouble: ...

    @overload
    def build(self) -> Node: ...

    @overload
    def build(self) -> Node.OfDouble: ...

    @overload
    def build(self) -> Node: ...

    def end(self) -> None: ...

    def toString(self) -> str: ...

  class DoubleSpinedNodeBuilder(SpinedBuffer.OfDouble):

    def accept(self, arg0: float) -> None: ...

    @overload
    def asPrimitiveArray(self) -> object: ...

    @overload
    def asPrimitiveArray(self) -> list[float]: ...

    def begin(self, arg0: int) -> None: ...

    @overload
    def build(self) -> Node.OfDouble: ...

    @overload
    def build(self) -> Node: ...

    @overload
    def build(self) -> Node.OfDouble: ...

    @overload
    def build(self) -> Node: ...

    @overload
    def copyInto(self, arg0: list[float], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[Double], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: object, arg1: int) -> None: ...

    def end(self) -> None: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[Double]) -> None: ...

    @overload
    def forEach(self, arg0: DoubleConsumer) -> None: ...

    def getShape(self) -> StreamShape: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def newArray(self, arg0: int) -> list[float]: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfDouble: ...

    @overload
    def spliterator(self) -> Spliterator.OfPrimitive: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Double]) -> Node.OfDouble: ...

    @overload
    def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

  class SizedCollectorTask[P_IN, P_OUT, T_SINK, K](CountedCompleter):

    @overload
    def accept(self, arg0: float) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def begin(self, arg0: int) -> None: ...

    @overload
    def begin(self, arg0: int) -> None: ...

    def cancellationRequested(self) -> bool: ...

    def compute(self) -> None: ...

    def end(self) -> None: ...

    class OfDouble[OfDouble_P_IN](Nodes.SizedCollectorTask):

      @overload
      def accept(self, arg0: float) -> None: ...

      @overload
      def accept(self, arg0: float) -> None: ...

      @overload
      def accept(self, arg0: Double) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

    class OfLong[OfLong_P_IN](Nodes.SizedCollectorTask):

      @overload
      def accept(self, arg0: Long) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

    class OfInt[OfInt_P_IN](Nodes.SizedCollectorTask):

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: Integer) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

    class OfRef[OfRef_P_IN, OfRef_P_OUT](Nodes.SizedCollectorTask):

      @overload
      def accept(self, arg0: float) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      def begin(self, arg0: int) -> None: ...

      def cancellationRequested(self) -> bool: ...

      def end(self) -> None: ...

  class CollectorTask[P_IN, P_OUT, T_NODE, T_BUILDER](AbstractTask):

    def onCompletion(self, arg0: CountedCompleter[Any]) -> None: ...

    class OfDouble[OfDouble_P_IN](Nodes.CollectorTask): ...

    class OfLong[OfLong_P_IN](Nodes.CollectorTask): ...

    class OfInt[OfInt_P_IN](Nodes.CollectorTask): ...

    class OfRef[OfRef_P_IN, OfRef_P_OUT](Nodes.CollectorTask): ...

  class ToArrayTask[T, T_NODE, K](CountedCompleter):

    def compute(self) -> None: ...

    class OfDouble(Nodes.ToArrayTask.OfPrimitive): ...

    class OfLong(Nodes.ToArrayTask.OfPrimitive): ...

    class OfInt(Nodes.ToArrayTask.OfPrimitive): ...

    class OfPrimitive[OfPrimitive_T, T_CONS, T_ARR, T_SPLITR, OfPrimitive_T_NODE](Nodes.ToArrayTask): ...

    class OfRef[OfRef_T](Nodes.ToArrayTask): ...

  class EmptyNode[T, T_ARR, T_CONS]:

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    @overload
    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def copyInto(self, arg0: object, arg1: int) -> None: ...

    @overload
    def count(self) -> int: ...

    @overload
    def count(self) -> int: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[T]) -> None: ...

    def getChild(self, arg0: int) -> Node[T]: ...

    def getChildCount(self) -> int: ...

    def getShape(self) -> StreamShape: ...

    def spliterator(self) -> Spliterator[T]: ...

    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node[T]: ...

    class OfDouble(Nodes.EmptyNode):

      @overload
      def asPrimitiveArray(self) -> object: ...

      @overload
      def asPrimitiveArray(self) -> list[float]: ...

      @overload
      def copyInto(self, arg0: list[Double], arg1: int) -> None: ...

      @overload
      def copyInto(self, arg0: list[object], arg1: int) -> None: ...

      def forEach(self, arg0: Consumer[Double]) -> None: ...

      def getShape(self) -> StreamShape: ...

      @overload
      def newArray(self, arg0: int) -> object: ...

      @overload
      def newArray(self, arg0: int) -> list[float]: ...

      @overload
      def spliterator(self) -> Spliterator.OfPrimitive: ...

      @overload
      def spliterator(self) -> Spliterator: ...

      @overload
      def spliterator(self) -> Spliterator.OfDouble: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Double]) -> Node.OfDouble: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

    class OfLong(Nodes.EmptyNode):

      @overload
      def asPrimitiveArray(self) -> object: ...

      @overload
      def asPrimitiveArray(self) -> list[int]: ...

      @overload
      def copyInto(self, arg0: list[Long], arg1: int) -> None: ...

      @overload
      def copyInto(self, arg0: list[object], arg1: int) -> None: ...

      def forEach(self, arg0: Consumer[Long]) -> None: ...

      def getShape(self) -> StreamShape: ...

      @overload
      def newArray(self, arg0: int) -> object: ...

      @overload
      def newArray(self, arg0: int) -> list[int]: ...

      @overload
      def spliterator(self) -> Spliterator.OfPrimitive: ...

      @overload
      def spliterator(self) -> Spliterator: ...

      @overload
      def spliterator(self) -> Spliterator.OfLong: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Long]) -> Node.OfLong: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

    class OfInt(Nodes.EmptyNode):

      @overload
      def asPrimitiveArray(self) -> object: ...

      @overload
      def asPrimitiveArray(self) -> list[int]: ...

      @overload
      def copyInto(self, arg0: list[Integer], arg1: int) -> None: ...

      @overload
      def copyInto(self, arg0: list[object], arg1: int) -> None: ...

      def forEach(self, arg0: Consumer[Integer]) -> None: ...

      def getShape(self) -> StreamShape: ...

      @overload
      def newArray(self, arg0: int) -> object: ...

      @overload
      def newArray(self, arg0: int) -> list[int]: ...

      @overload
      def spliterator(self) -> Spliterator.OfPrimitive: ...

      @overload
      def spliterator(self) -> Spliterator: ...

      @overload
      def spliterator(self) -> Spliterator.OfInt: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction[Integer]) -> Node.OfInt: ...

      @overload
      def truncate(self, arg0: int, arg1: int, arg2: IntFunction) -> Node.OfPrimitive: ...

    class OfRef[OfRef_T](Nodes.EmptyNode):

      def copyInto(self, arg0: list[object], arg1: int) -> None: ...

      def forEach(self, arg0: Consumer) -> None: ...

      def spliterator(self) -> Spliterator[T]: ...

  class InternalNodeSpliterator[T, S, N]:

    CONCURRENT: int

    DISTINCT: int

    IMMUTABLE: int

    NONNULL: int

    ORDERED: int

    SIZED: int

    SORTED: int

    SUBSIZED: int

    @overload
    def characteristics(self) -> int: ...

    @overload
    def characteristics(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    @overload
    def estimateSize(self) -> int: ...

    def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

    def getComparator(self) -> Comparator[T]: ...

    def getExactSizeIfKnown(self) -> int: ...

    def hasCharacteristics(self, arg0: int) -> bool: ...

    def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

    @overload
    def trySplit(self) -> S: ...

    @overload
    def trySplit(self) -> Spliterator[T]: ...

    class OfDouble(Nodes.InternalNodeSpliterator.OfPrimitive):

      @overload
      def forEachRemaining(self, arg0: object) -> None: ...

      @overload
      def forEachRemaining(self, arg0: Consumer[Double]) -> None: ...

      @overload
      def forEachRemaining(self, arg0: DoubleConsumer) -> None: ...

      @overload
      def forEachRemaining(self, arg0: DoubleConsumer) -> None: ...

      @overload
      def tryAdvance(self, arg0: object) -> bool: ...

      @overload
      def tryAdvance(self, arg0: Consumer[Double]) -> bool: ...

      @overload
      def tryAdvance(self, arg0: DoubleConsumer) -> bool: ...

      @overload
      def tryAdvance(self, arg0: DoubleConsumer) -> bool: ...

      @overload
      def trySplit(self) -> Spliterator.OfDouble: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

      @overload
      def trySplit(self) -> Spliterator: ...

      @overload
      def trySplit(self) -> Spliterator.OfDouble: ...

    class OfLong(Nodes.InternalNodeSpliterator.OfPrimitive):

      @overload
      def forEachRemaining(self, arg0: object) -> None: ...

      @overload
      def forEachRemaining(self, arg0: Consumer[Long]) -> None: ...

      @overload
      def forEachRemaining(self, arg0: LongConsumer) -> None: ...

      @overload
      def forEachRemaining(self, arg0: LongConsumer) -> None: ...

      @overload
      def tryAdvance(self, arg0: object) -> bool: ...

      @overload
      def tryAdvance(self, arg0: Consumer[Long]) -> bool: ...

      @overload
      def tryAdvance(self, arg0: LongConsumer) -> bool: ...

      @overload
      def tryAdvance(self, arg0: LongConsumer) -> bool: ...

      @overload
      def trySplit(self) -> Spliterator.OfLong: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

      @overload
      def trySplit(self) -> Spliterator: ...

      @overload
      def trySplit(self) -> Spliterator.OfLong: ...

    class OfInt(Nodes.InternalNodeSpliterator.OfPrimitive):

      @overload
      def forEachRemaining(self, arg0: object) -> None: ...

      @overload
      def forEachRemaining(self, arg0: Consumer[Integer]) -> None: ...

      @overload
      def forEachRemaining(self, arg0: IntConsumer) -> None: ...

      @overload
      def forEachRemaining(self, arg0: IntConsumer) -> None: ...

      @overload
      def tryAdvance(self, arg0: object) -> bool: ...

      @overload
      def tryAdvance(self, arg0: Consumer[Integer]) -> bool: ...

      @overload
      def tryAdvance(self, arg0: IntConsumer) -> bool: ...

      @overload
      def tryAdvance(self, arg0: IntConsumer) -> bool: ...

      @overload
      def trySplit(self) -> Spliterator.OfInt: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

      @overload
      def trySplit(self) -> Spliterator: ...

      @overload
      def trySplit(self) -> Spliterator.OfInt: ...

    class OfPrimitive[OfPrimitive_T, T_CONS, T_ARR, T_SPLITR, OfPrimitive_N](Nodes.InternalNodeSpliterator):

      @overload
      def forEachRemaining(self, arg0: object) -> None: ...

      @overload
      def forEachRemaining(self, arg0: object) -> None: ...

      @overload
      def tryAdvance(self, arg0: object) -> bool: ...

      @overload
      def tryAdvance(self, arg0: object) -> bool: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

      @overload
      def trySplit(self) -> Spliterator: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

    class OfRef[OfRef_T](Nodes.InternalNodeSpliterator):

      def forEachRemaining(self, arg0: Consumer[T]) -> None: ...

      def tryAdvance(self, arg0: Consumer[T]) -> bool: ...

  class AbstractConcNode[T, T_NODE]:

    def asArray(self, arg0: IntFunction[T]) -> list[object]: ...

    def copyInto(self, arg0: list[object], arg1: int) -> None: ...

    @overload
    def count(self) -> int: ...

    @overload
    def count(self) -> int: ...

    def forEach(self, arg0: Consumer[T]) -> None: ...

    @overload
    def getChild(self, arg0: int) -> T_NODE: ...

    @overload
    def getChild(self, arg0: int) -> Node[T]: ...

    @overload
    def getChildCount(self) -> int: ...

    @overload
    def getChildCount(self) -> int: ...

    def getShape(self) -> StreamShape: ...

    def spliterator(self) -> Spliterator[T]: ...

    def truncate(self, arg0: int, arg1: int, arg2: IntFunction[T]) -> Node[T]: ...


class OptionalBox:

  @overload
  def accept(self, arg0: object) -> None: ...

  @overload
  def accept(self, arg0: object) -> None: ...

  def andThen(self, arg0: Consumer[T]) -> Consumer[T]: ...


class PairBox: ...


class PipelineHelper[P_OUT]: ...


class ReduceOps:

  @staticmethod
  @overload
  def makeDouble(arg0: DoubleBinaryOperator) -> TerminalOp[Double, OptionalDouble]: ...

  @staticmethod
  @overload
  def makeDouble(arg0: float, arg1: DoubleBinaryOperator) -> TerminalOp[Double, Double]: ...

  @staticmethod
  @overload
  def makeDouble(arg0: Supplier[R], arg1: ObjDoubleConsumer[R], arg2: BinaryOperator[R]) -> TerminalOp[Double, R]: ...

  @staticmethod
  def makeDoubleCounting() -> TerminalOp[Double, Long]: ...

  @staticmethod
  @overload
  def makeInt(arg0: IntBinaryOperator) -> TerminalOp[Integer, OptionalInt]: ...

  @staticmethod
  @overload
  def makeInt(arg0: int, arg1: IntBinaryOperator) -> TerminalOp[Integer, Integer]: ...

  @staticmethod
  @overload
  def makeInt(arg0: Supplier[R], arg1: ObjIntConsumer[R], arg2: BinaryOperator[R]) -> TerminalOp[Integer, R]: ...

  @staticmethod
  def makeIntCounting() -> TerminalOp[Integer, Long]: ...

  @staticmethod
  @overload
  def makeLong(arg0: LongBinaryOperator) -> TerminalOp[Long, OptionalLong]: ...

  @staticmethod
  @overload
  def makeLong(arg0: int, arg1: LongBinaryOperator) -> TerminalOp[Long, Long]: ...

  @staticmethod
  @overload
  def makeLong(arg0: Supplier[R], arg1: ObjLongConsumer[R], arg2: BinaryOperator[R]) -> TerminalOp[Long, R]: ...

  @staticmethod
  def makeLongCounting() -> TerminalOp[Long, Long]: ...

  @staticmethod
  @overload
  def makeRef(arg0: BinaryOperator[T]) -> TerminalOp[T, Optional[T]]: ...

  @staticmethod
  @overload
  def makeRef(arg0: Collector[T, I, Any]) -> TerminalOp[T, I]: ...

  @staticmethod
  @overload
  def makeRef(arg0: object, arg1: BiFunction[U, T, U], arg2: BinaryOperator[U]) -> TerminalOp[T, U]: ...

  @staticmethod
  @overload
  def makeRef(arg0: Supplier[R], arg1: BiConsumer[R, T], arg2: BiConsumer[R, R]) -> TerminalOp[T, R]: ...

  @staticmethod
  def makeRefCounting() -> TerminalOp[T, Long]: ...

  class ReduceTask[P_IN, P_OUT, R, S](AbstractTask):

    def onCompletion(self, arg0: CountedCompleter[Any]) -> None: ...

  class ReduceOp[T, R, S]:

    @overload
    def evaluateParallel(self, arg0: PipelineHelper[T], arg1: Spliterator[P_IN]) -> object: ...

    @overload
    def evaluateParallel(self, arg0: PipelineHelper[E_IN], arg1: Spliterator[P_IN]) -> object: ...

    @overload
    def evaluateSequential(self, arg0: PipelineHelper[T], arg1: Spliterator[P_IN]) -> object: ...

    @overload
    def evaluateSequential(self, arg0: PipelineHelper[E_IN], arg1: Spliterator[P_IN]) -> object: ...

    def getOpFlags(self) -> int: ...

    @overload
    def inputShape(self) -> StreamShape: ...

    @overload
    def inputShape(self) -> StreamShape: ...

    def makeSink(self) -> ReduceOps.AccumulatingSink: ...

  class Box[U]:

    def get(self) -> object: ...

  class AccumulatingSink[T, R, K]:

    def combine(self, arg0: ReduceOps.AccumulatingSink) -> None: ...

  class CountingSink[T](ReduceOps.Box):

    def begin(self, arg0: int) -> None: ...

    @overload
    def combine(self, arg0: ReduceOps.AccumulatingSink) -> None: ...

    @overload
    def combine(self, arg0: ReduceOps.AccumulatingSink) -> None: ...

    @overload
    def combine(self, arg0: ReduceOps.CountingSink) -> None: ...

    @overload
    def get(self) -> object: ...

    @overload
    def get(self) -> Long: ...

    class OfDouble(ReduceOps.CountingSink):

      @overload
      def accept(self, arg0: float) -> None: ...

      @overload
      def accept(self, arg0: float) -> None: ...

      @overload
      def accept(self, arg0: Double) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      def combine(self, arg0: ReduceOps.AccumulatingSink) -> None: ...

      def get(self) -> object: ...

    class OfLong(ReduceOps.CountingSink):

      @overload
      def accept(self, arg0: Long) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      def combine(self, arg0: ReduceOps.AccumulatingSink) -> None: ...

      def get(self) -> object: ...

    class OfInt(ReduceOps.CountingSink):

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: int) -> None: ...

      @overload
      def accept(self, arg0: Integer) -> None: ...

      @overload
      def accept(self, arg0: object) -> None: ...

      def combine(self, arg0: ReduceOps.AccumulatingSink) -> None: ...

      def get(self) -> object: ...

    class OfRef[OfRef_T](ReduceOps.CountingSink):

      def accept(self, arg0: object) -> None: ...

      def combine(self, arg0: ReduceOps.AccumulatingSink) -> None: ...

      def get(self) -> object: ...


class ReducingSink(ReduceOps.Box):

  def accept(self, arg0: object) -> None: ...

  def begin(self, arg0: int) -> None: ...

  @overload
  def combine(self, arg0: ReduceOps.ReducingSink) -> None: ...

  @overload
  def combine(self, arg0: ReduceOps.AccumulatingSink) -> None: ...

  @overload
  def combine(self, arg0: ReduceOps.AccumulatingSink) -> None: ...


class ReferencePipeline[P_IN, P_OUT](AbstractPipeline):

  @overload
  def allMatch(self, arg0: Predicate[P_OUT]) -> bool: ...

  @overload
  def allMatch(self, arg0: Predicate[T]) -> bool: ...

  @overload
  def anyMatch(self, arg0: Predicate[P_OUT]) -> bool: ...

  @overload
  def anyMatch(self, arg0: Predicate[T]) -> bool: ...

  @overload
  def collect(self, arg0: Collector[P_OUT, A, R]) -> object: ...

  @overload
  def collect(self, arg0: Collector[T, A, R]) -> object: ...

  @overload
  def collect(self, arg0: Supplier[R], arg1: BiConsumer[R, P_OUT], arg2: BiConsumer[R, R]) -> object: ...

  @overload
  def collect(self, arg0: Supplier[R], arg1: BiConsumer[R, T], arg2: BiConsumer[R, R]) -> object: ...

  @overload
  def count(self) -> int: ...

  @overload
  def count(self) -> int: ...

  @overload
  def distinct(self) -> Stream[P_OUT]: ...

  @overload
  def distinct(self) -> Stream[T]: ...

  @overload
  def dropWhile(self, arg0: Predicate[P_OUT]) -> Stream[P_OUT]: ...

  @overload
  def dropWhile(self, arg0: Predicate[T]) -> Stream[T]: ...

  @overload
  def filter(self, arg0: Predicate[P_OUT]) -> Stream[P_OUT]: ...

  @overload
  def filter(self, arg0: Predicate[T]) -> Stream[T]: ...

  @overload
  def findAny(self) -> Optional[P_OUT]: ...

  @overload
  def findAny(self) -> Optional[T]: ...

  @overload
  def findFirst(self) -> Optional[P_OUT]: ...

  @overload
  def findFirst(self) -> Optional[T]: ...

  @overload
  def flatMap(self, arg0: Function[P_OUT, Stream[R]]) -> Stream[R]: ...

  @overload
  def flatMap(self, arg0: Function[T, Stream[R]]) -> Stream[R]: ...

  @overload
  def flatMapToDouble(self, arg0: Function[P_OUT, DoubleStream]) -> DoubleStream: ...

  @overload
  def flatMapToDouble(self, arg0: Function[T, DoubleStream]) -> DoubleStream: ...

  @overload
  def flatMapToInt(self, arg0: Function[P_OUT, IntStream]) -> IntStream: ...

  @overload
  def flatMapToInt(self, arg0: Function[T, IntStream]) -> IntStream: ...

  @overload
  def flatMapToLong(self, arg0: Function[P_OUT, LongStream]) -> LongStream: ...

  @overload
  def flatMapToLong(self, arg0: Function[T, LongStream]) -> LongStream: ...

  @overload
  def forEach(self, arg0: Consumer[P_OUT]) -> None: ...

  @overload
  def forEach(self, arg0: Consumer[T]) -> None: ...

  @overload
  def forEachOrdered(self, arg0: Consumer[P_OUT]) -> None: ...

  @overload
  def forEachOrdered(self, arg0: Consumer[T]) -> None: ...

  def iterator(self) -> Iterator[P_OUT]: ...

  @overload
  def limit(self, arg0: int) -> Stream[P_OUT]: ...

  @overload
  def limit(self, arg0: int) -> Stream[T]: ...

  @overload
  def map(self, arg0: Function[P_OUT, R]) -> Stream[R]: ...

  @overload
  def map(self, arg0: Function[T, R]) -> Stream[R]: ...

  @overload
  def mapMulti(self, arg0: BiConsumer[P_OUT, Consumer[R]]) -> Stream[R]: ...

  @overload
  def mapMulti(self, arg0: BiConsumer[T, Consumer[R]]) -> Stream[R]: ...

  @overload
  def mapMultiToDouble(self, arg0: BiConsumer[P_OUT, DoubleConsumer]) -> DoubleStream: ...

  @overload
  def mapMultiToDouble(self, arg0: BiConsumer[T, DoubleConsumer]) -> DoubleStream: ...

  @overload
  def mapMultiToInt(self, arg0: BiConsumer[P_OUT, IntConsumer]) -> IntStream: ...

  @overload
  def mapMultiToInt(self, arg0: BiConsumer[T, IntConsumer]) -> IntStream: ...

  @overload
  def mapMultiToLong(self, arg0: BiConsumer[P_OUT, LongConsumer]) -> LongStream: ...

  @overload
  def mapMultiToLong(self, arg0: BiConsumer[T, LongConsumer]) -> LongStream: ...

  @overload
  def mapToDouble(self, arg0: ToDoubleFunction[P_OUT]) -> DoubleStream: ...

  @overload
  def mapToDouble(self, arg0: ToDoubleFunction[T]) -> DoubleStream: ...

  @overload
  def mapToInt(self, arg0: ToIntFunction[P_OUT]) -> IntStream: ...

  @overload
  def mapToInt(self, arg0: ToIntFunction[T]) -> IntStream: ...

  @overload
  def mapToLong(self, arg0: ToLongFunction[P_OUT]) -> LongStream: ...

  @overload
  def mapToLong(self, arg0: ToLongFunction[T]) -> LongStream: ...

  @overload
  def max(self, arg0: Comparator[P_OUT]) -> Optional[P_OUT]: ...

  @overload
  def max(self, arg0: Comparator[T]) -> Optional[T]: ...

  @overload
  def min(self, arg0: Comparator[P_OUT]) -> Optional[P_OUT]: ...

  @overload
  def min(self, arg0: Comparator[T]) -> Optional[T]: ...

  @overload
  def noneMatch(self, arg0: Predicate[P_OUT]) -> bool: ...

  @overload
  def noneMatch(self, arg0: Predicate[T]) -> bool: ...

  @overload
  def peek(self, arg0: Consumer[P_OUT]) -> Stream[P_OUT]: ...

  @overload
  def peek(self, arg0: Consumer[T]) -> Stream[T]: ...

  @overload
  def reduce(self, arg0: BinaryOperator[P_OUT]) -> Optional[P_OUT]: ...

  @overload
  def reduce(self, arg0: BinaryOperator[T]) -> Optional[T]: ...

  @overload
  def reduce(self, arg0: object, arg1: BinaryOperator[P_OUT]) -> object: ...

  @overload
  def reduce(self, arg0: object, arg1: BinaryOperator[T]) -> object: ...

  @overload
  def reduce(self, arg0: object, arg1: BiFunction[R, P_OUT, R], arg2: BinaryOperator[R]) -> object: ...

  @overload
  def reduce(self, arg0: object, arg1: BiFunction[U, T, U], arg2: BinaryOperator[U]) -> object: ...

  @overload
  def skip(self, arg0: int) -> Stream[P_OUT]: ...

  @overload
  def skip(self, arg0: int) -> Stream[T]: ...

  @overload
  def sorted(self) -> Stream[P_OUT]: ...

  @overload
  def sorted(self) -> Stream[T]: ...

  @overload
  def sorted(self, arg0: Comparator[P_OUT]) -> Stream[P_OUT]: ...

  @overload
  def sorted(self, arg0: Comparator[T]) -> Stream[T]: ...

  @overload
  def takeWhile(self, arg0: Predicate[P_OUT]) -> Stream[P_OUT]: ...

  @overload
  def takeWhile(self, arg0: Predicate[T]) -> Stream[T]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: IntFunction[A]) -> list[object]: ...

  @overload
  def toArray(self, arg0: IntFunction[A]) -> list[object]: ...

  @overload
  def toList(self) -> List[P_OUT]: ...

  @overload
  def toList(self) -> List[T]: ...

  @overload
  def unordered(self) -> Stream[P_OUT]: ...

  @overload
  def unordered(self) -> BaseStream: ...

  @staticmethod
  def builder() -> Stream.Builder: ...

  @staticmethod
  def concat(arg0: Stream[T], arg1: Stream[T]) -> Stream[T]: ...

  @staticmethod
  def empty() -> Stream[T]: ...

  @staticmethod
  def generate(arg0: Supplier[T]) -> Stream[T]: ...

  @staticmethod
  @overload
  def iterate(arg0: object, arg1: UnaryOperator[T]) -> Stream[T]: ...

  @staticmethod
  @overload
  def iterate(arg0: object, arg1: Predicate[T], arg2: UnaryOperator[T]) -> Stream[T]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> Stream[T]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> Stream[T]: ...

  @staticmethod
  def ofNullable(arg0: object) -> Stream[T]: ...

  class StatefulOp[E_IN, E_OUT](ReferencePipeline):

    def unordered(self) -> BaseStream: ...

  class StatelessOp[E_IN, E_OUT](ReferencePipeline):

    def unordered(self) -> BaseStream: ...

  class Head[E_IN, E_OUT](ReferencePipeline):

    def forEach(self, arg0: Consumer[E_OUT]) -> None: ...

    def forEachOrdered(self, arg0: Consumer[E_OUT]) -> None: ...

    def unordered(self) -> BaseStream: ...


class Sink[T]:

  @overload
  def accept(self, arg0: float) -> None: ...

  @overload
  def accept(self, arg0: int) -> None: ...

  @overload
  def accept(self, arg0: object) -> None: ...

  @overload
  def accept(self, arg0: int) -> None: ...

  def andThen(self, arg0: Consumer[T]) -> Consumer[T]: ...

  def begin(self, arg0: int) -> None: ...

  def cancellationRequested(self) -> bool: ...

  def end(self) -> None: ...

  class ChainedDouble[E_OUT]:

    @overload
    def accept(self, arg0: float) -> None: ...

    @overload
    def accept(self, arg0: Double) -> None: ...

    @overload
    def accept(self, arg0: object) -> None: ...

    def begin(self, arg0: int) -> None: ...

    def cancellationRequested(self) -> bool: ...

    def end(self) -> None: ...

    def __init__(self, arg0: Sink[E_OUT]): ...

  class ChainedLong[E_OUT]:

    @overload
    def accept(self, arg0: Long) -> None: ...

    @overload
    def accept(self, arg0: object) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    def begin(self, arg0: int) -> None: ...

    def cancellationRequested(self) -> bool: ...

    def end(self) -> None: ...

    def __init__(self, arg0: Sink[E_OUT]): ...

  class ChainedInt[E_OUT]:

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: Integer) -> None: ...

    @overload
    def accept(self, arg0: object) -> None: ...

    def begin(self, arg0: int) -> None: ...

    def cancellationRequested(self) -> bool: ...

    def end(self) -> None: ...

    def __init__(self, arg0: Sink[E_OUT]): ...

  class ChainedReference[ChainedReference_T, E_OUT]:

    @overload
    def accept(self, arg0: float) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def begin(self, arg0: int) -> None: ...

    @overload
    def begin(self, arg0: int) -> None: ...

    @overload
    def cancellationRequested(self) -> bool: ...

    @overload
    def cancellationRequested(self) -> bool: ...

    @overload
    def end(self) -> None: ...

    @overload
    def end(self) -> None: ...

    def __init__(self, arg0: Sink[E_OUT]): ...

  class OfDouble:

    @overload
    def accept(self, arg0: float) -> None: ...

    @overload
    def accept(self, arg0: float) -> None: ...

    @overload
    def accept(self, arg0: float) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: Double) -> None: ...

    @overload
    def accept(self, arg0: object) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    def andThen(self, arg0: DoubleConsumer) -> DoubleConsumer: ...

    def begin(self, arg0: int) -> None: ...

    def cancellationRequested(self) -> bool: ...

    def end(self) -> None: ...

  class OfLong:

    @overload
    def accept(self, arg0: float) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: Long) -> None: ...

    @overload
    def accept(self, arg0: object) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    def andThen(self, arg0: LongConsumer) -> LongConsumer: ...

    def begin(self, arg0: int) -> None: ...

    def cancellationRequested(self) -> bool: ...

    def end(self) -> None: ...

  class OfInt:

    @overload
    def accept(self, arg0: float) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: Integer) -> None: ...

    @overload
    def accept(self, arg0: object) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    def andThen(self, arg0: IntConsumer) -> IntConsumer: ...

    def begin(self, arg0: int) -> None: ...

    def cancellationRequested(self) -> bool: ...

    def end(self) -> None: ...


class SpinedBuffer[E](AbstractSpinedBuffer):

  @overload
  def accept(self, arg0: object) -> None: ...

  @overload
  def accept(self, arg0: object) -> None: ...

  def andThen(self, arg0: Consumer[T]) -> Consumer[T]: ...

  def asArray(self, arg0: IntFunction[E]) -> list[object]: ...

  def clear(self) -> None: ...

  def copyInto(self, arg0: list[object], arg1: int) -> None: ...

  @overload
  def forEach(self, arg0: Consumer[E]) -> None: ...

  @overload
  def forEach(self, arg0: Consumer[T]) -> None: ...

  def get(self, arg0: int) -> object: ...

  @overload
  def iterator(self) -> Iterator[E]: ...

  @overload
  def iterator(self) -> Iterator[T]: ...

  @overload
  def spliterator(self) -> Spliterator[E]: ...

  @overload
  def spliterator(self) -> Spliterator[T]: ...

  def toString(self) -> str: ...

  class OfDouble(SpinedBuffer.OfPrimitive):

    @overload
    def accept(self, arg0: float) -> None: ...

    @overload
    def accept(self, arg0: float) -> None: ...

    def andThen(self, arg0: DoubleConsumer) -> DoubleConsumer: ...

    def forEach(self, arg0: Consumer[Double]) -> None: ...

    def get(self, arg0: int) -> float: ...

    @overload
    def iterator(self) -> PrimitiveIterator.OfDouble: ...

    @overload
    def iterator(self) -> Iterator: ...

    @overload
    def newArray(self, arg0: int) -> list[float]: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfDouble: ...

    def toString(self) -> str: ...

  class OfLong(SpinedBuffer.OfPrimitive):

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    def andThen(self, arg0: LongConsumer) -> LongConsumer: ...

    def forEach(self, arg0: Consumer[Long]) -> None: ...

    def get(self, arg0: int) -> int: ...

    @overload
    def iterator(self) -> PrimitiveIterator.OfLong: ...

    @overload
    def iterator(self) -> Iterator: ...

    @overload
    def newArray(self, arg0: int) -> list[int]: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfLong: ...

    def toString(self) -> str: ...

  class OfInt(SpinedBuffer.OfPrimitive):

    @overload
    def accept(self, arg0: int) -> None: ...

    @overload
    def accept(self, arg0: int) -> None: ...

    def andThen(self, arg0: IntConsumer) -> IntConsumer: ...

    def forEach(self, arg0: Consumer[Integer]) -> None: ...

    def get(self, arg0: int) -> int: ...

    @overload
    def iterator(self) -> PrimitiveIterator.OfInt: ...

    @overload
    def iterator(self) -> Iterator: ...

    @overload
    def newArray(self, arg0: int) -> list[int]: ...

    @overload
    def newArray(self, arg0: int) -> object: ...

    @overload
    def spliterator(self) -> Spliterator: ...

    @overload
    def spliterator(self) -> Spliterator.OfInt: ...

    def toString(self) -> str: ...

  class OfPrimitive[OfPrimitive_E, T_ARR, T_CONS](AbstractSpinedBuffer):

    def asPrimitiveArray(self) -> object: ...

    def clear(self) -> None: ...

    def copyInto(self, arg0: object, arg1: int) -> None: ...

    @overload
    def forEach(self, arg0: object) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[E]) -> None: ...

    @overload
    def forEach(self, arg0: Consumer[T]) -> None: ...

    @overload
    def iterator(self) -> Iterator[E]: ...

    @overload
    def iterator(self) -> Iterator[T]: ...

    def newArray(self, arg0: int) -> object: ...

    def spliterator(self) -> Spliterator[T]: ...

    class BaseSpliterator[T_SPLITR]:

      def characteristics(self) -> int: ...

      def estimateSize(self) -> int: ...

      @overload
      def forEachRemaining(self, arg0: object) -> None: ...

      @overload
      def forEachRemaining(self, arg0: object) -> None: ...

      @overload
      def tryAdvance(self, arg0: object) -> bool: ...

      @overload
      def tryAdvance(self, arg0: object) -> bool: ...

      @overload
      def trySplit(self) -> Spliterator: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...

      @overload
      def trySplit(self) -> Spliterator: ...

      @overload
      def trySplit(self) -> Spliterator.OfPrimitive: ...


class Stream[T]:

  def allMatch(self, arg0: Predicate[T]) -> bool: ...

  def anyMatch(self, arg0: Predicate[T]) -> bool: ...

  def close(self) -> None: ...

  @overload
  def collect(self, arg0: Collector[T, A, R]) -> object: ...

  @overload
  def collect(self, arg0: Supplier[R], arg1: BiConsumer[R, T], arg2: BiConsumer[R, R]) -> object: ...

  def count(self) -> int: ...

  def distinct(self) -> Stream[T]: ...

  def dropWhile(self, arg0: Predicate[T]) -> Stream[T]: ...

  def filter(self, arg0: Predicate[T]) -> Stream[T]: ...

  def findAny(self) -> Optional[T]: ...

  def findFirst(self) -> Optional[T]: ...

  def flatMap(self, arg0: Function[T, Stream[R]]) -> Stream[R]: ...

  def flatMapToDouble(self, arg0: Function[T, DoubleStream]) -> DoubleStream: ...

  def flatMapToInt(self, arg0: Function[T, IntStream]) -> IntStream: ...

  def flatMapToLong(self, arg0: Function[T, LongStream]) -> LongStream: ...

  def forEach(self, arg0: Consumer[T]) -> None: ...

  def forEachOrdered(self, arg0: Consumer[T]) -> None: ...

  def isParallel(self) -> bool: ...

  def iterator(self) -> Iterator[T]: ...

  def limit(self, arg0: int) -> Stream[T]: ...

  def map(self, arg0: Function[T, R]) -> Stream[R]: ...

  def mapMulti(self, arg0: BiConsumer[T, Consumer[R]]) -> Stream[R]: ...

  def mapMultiToDouble(self, arg0: BiConsumer[T, DoubleConsumer]) -> DoubleStream: ...

  def mapMultiToInt(self, arg0: BiConsumer[T, IntConsumer]) -> IntStream: ...

  def mapMultiToLong(self, arg0: BiConsumer[T, LongConsumer]) -> LongStream: ...

  def mapToDouble(self, arg0: ToDoubleFunction[T]) -> DoubleStream: ...

  def mapToInt(self, arg0: ToIntFunction[T]) -> IntStream: ...

  def mapToLong(self, arg0: ToLongFunction[T]) -> LongStream: ...

  def max(self, arg0: Comparator[T]) -> Optional[T]: ...

  def min(self, arg0: Comparator[T]) -> Optional[T]: ...

  def noneMatch(self, arg0: Predicate[T]) -> bool: ...

  def onClose(self, arg0: Runnable) -> S: ...

  def parallel(self) -> S: ...

  def peek(self, arg0: Consumer[T]) -> Stream[T]: ...

  @overload
  def reduce(self, arg0: BinaryOperator[T]) -> Optional[T]: ...

  @overload
  def reduce(self, arg0: object, arg1: BinaryOperator[T]) -> object: ...

  @overload
  def reduce(self, arg0: object, arg1: BiFunction[U, T, U], arg2: BinaryOperator[U]) -> object: ...

  def sequential(self) -> S: ...

  def skip(self, arg0: int) -> Stream[T]: ...

  @overload
  def sorted(self) -> Stream[T]: ...

  @overload
  def sorted(self, arg0: Comparator[T]) -> Stream[T]: ...

  def spliterator(self) -> Spliterator[T]: ...

  def takeWhile(self, arg0: Predicate[T]) -> Stream[T]: ...

  @overload
  def toArray(self) -> list[object]: ...

  @overload
  def toArray(self, arg0: IntFunction[A]) -> list[object]: ...

  def toList(self) -> List[T]: ...

  def unordered(self) -> S: ...

  @staticmethod
  def builder() -> Stream.Builder: ...

  @staticmethod
  def concat(arg0: Stream[T], arg1: Stream[T]) -> Stream[T]: ...

  @staticmethod
  def empty() -> Stream[T]: ...

  @staticmethod
  def generate(arg0: Supplier[T]) -> Stream[T]: ...

  @staticmethod
  @overload
  def iterate(arg0: object, arg1: UnaryOperator[T]) -> Stream[T]: ...

  @staticmethod
  @overload
  def iterate(arg0: object, arg1: Predicate[T], arg2: UnaryOperator[T]) -> Stream[T]: ...

  @staticmethod
  @overload
  def of(arg0: list[object]) -> Stream[T]: ...

  @staticmethod
  @overload
  def of(arg0: object) -> Stream[T]: ...

  @staticmethod
  def ofNullable(arg0: object) -> Stream[T]: ...

  class Builder[Builder_T]:

    @overload
    def accept(self, arg0: object) -> None: ...

    @overload
    def accept(self, arg0: object) -> None: ...

    def add(self, arg0: object) -> Stream.Builder: ...

    def andThen(self, arg0: Consumer[T]) -> Consumer[T]: ...

    def build(self) -> Stream[T]: ...


class StreamOpFlag(Enum):

  DISTINCT: StreamOpFlag

  ORDERED: StreamOpFlag

  SHORT_CIRCUIT: StreamOpFlag

  SIZE_ADJUSTING: StreamOpFlag

  SIZED: StreamOpFlag

  SORTED: StreamOpFlag

  @staticmethod
  def valueOf(arg0: str) -> StreamOpFlag: ...

  @staticmethod
  def values() -> list[StreamOpFlag]: ...

  class MaskBuilder: ...

  class Type(Enum):

    OP: StreamOpFlag.Type

    SPLITERATOR: StreamOpFlag.Type

    STREAM: StreamOpFlag.Type

    TERMINAL_OP: StreamOpFlag.Type

    UPSTREAM_TERMINAL_OP: StreamOpFlag.Type

    @staticmethod
    def valueOf(arg0: str) -> StreamOpFlag.Type: ...

    @staticmethod
    def values() -> list[StreamOpFlag.Type]: ...


class StreamShape(Enum):

  DOUBLE_VALUE: StreamShape

  INT_VALUE: StreamShape

  LONG_VALUE: StreamShape

  REFERENCE: StreamShape

  @staticmethod
  def valueOf(arg0: str) -> StreamShape: ...

  @staticmethod
  def values() -> list[StreamShape]: ...


class StreamSupport:

  @staticmethod
  @overload
  def doubleStream(arg0: Spliterator.OfDouble, arg1: bool) -> DoubleStream: ...

  @staticmethod
  @overload
  def doubleStream(arg0: Supplier[Spliterator.OfDouble], arg1: int, arg2: bool) -> DoubleStream: ...

  @staticmethod
  @overload
  def intStream(arg0: Spliterator.OfInt, arg1: bool) -> IntStream: ...

  @staticmethod
  @overload
  def intStream(arg0: Supplier[Spliterator.OfInt], arg1: int, arg2: bool) -> IntStream: ...

  @staticmethod
  @overload
  def longStream(arg0: Spliterator.OfLong, arg1: bool) -> LongStream: ...

  @staticmethod
  @overload
  def longStream(arg0: Supplier[Spliterator.OfLong], arg1: int, arg2: bool) -> LongStream: ...

  @staticmethod
  @overload
  def stream(arg0: Spliterator[T], arg1: bool) -> Stream[T]: ...

  @staticmethod
  @overload
  def stream(arg0: Supplier[Spliterator[T]], arg1: int, arg2: bool) -> Stream[T]: ...


class TerminalOp[E_IN, R]:

  def evaluateParallel(self, arg0: PipelineHelper[E_IN], arg1: Spliterator[P_IN]) -> object: ...

  def evaluateSequential(self, arg0: PipelineHelper[E_IN], arg1: Spliterator[P_IN]) -> object: ...

  def getOpFlags(self) -> int: ...

  def inputShape(self) -> StreamShape: ...


class TerminalSink[T, R]:

  @overload
  def accept(self, arg0: float) -> None: ...

  @overload
  def accept(self, arg0: int) -> None: ...

  @overload
  def accept(self, arg0: int) -> None: ...

  def begin(self, arg0: int) -> None: ...

  def cancellationRequested(self) -> bool: ...

  def end(self) -> None: ...

  def get(self) -> object: ...

