from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from com.asledgehammer.rosetta import RosettaClass, RosettaConstructor, RosettaField, Rosetta, RosettaMethod, RosettaParameter
from java.io import File
from java.lang import Class
from java.lang.instrument import Instrumentation
from java.lang.reflect import Constructor, Method, Parameter, Field, Type
from java.util import Map, List, Comparator
from java.util.function import Function, ToDoubleFunction, ToIntFunction, ToLongFunction

U = TypeVar('U', default=Any)
T = TypeVar('T', default=Any)
E = TypeVar('E', default=Any)
C = TypeVar('C', default=Any)

class Candle:

  addParameterClasses: bool

  addReturnClasses: bool

  addSubClasses: bool

  addSuperClasses: bool

  def saveJavaAPI(self, arg0: File) -> None: ...

  @staticmethod
  def main(arg0: list[str]) -> None: ...


class CandleAlias(CandleEntity):

  def getClazz(self) -> Class: ...

  def __init__(self, arg0: Class[Any]): ...


class CandleClass(CandleEntity):

  def genDocs(self) -> Map[str, object]: ...

  def getClazz(self) -> Class: ...

  def getConstructors(self) -> CandleExecutableCluster[CandleConstructor]: ...

  def getDocs(self) -> RosettaClass: ...

  def getInstanceFields(self) -> Map[str, CandleField]: ...

  def getMethods(self) -> Map[str, CandleExecutableCluster[CandleMethod]]: ...

  def getStaticFields(self) -> Map[str, CandleField]: ...

  def getStaticMethods(self) -> Map[str, CandleExecutableCluster[CandleMethod]]: ...

  def hasConstructors(self) -> bool: ...

  def hasInstanceFields(self) -> bool: ...

  def hasInstanceMethod(self, arg0: str) -> bool: ...

  def hasInstanceMethods(self) -> bool: ...

  def hasStaticFields(self) -> bool: ...

  def hasStaticMethod(self, arg0: str) -> bool: ...

  def hasStaticMethods(self) -> bool: ...

  def isDocsValid(self) -> bool: ...

  def save(self, arg0: File) -> None: ...

  def __init__(self, arg0: Class[Any]): ...


class CandleClassBag:

  def getClasses(self) -> List[Class[Any]]: ...

  @staticmethod
  def isExempt(arg0: Class[Any]) -> bool: ...

  def __init__(self): ...


class CandleClassComparator:

  @overload
  def compare(self, arg0: Class[Any], arg1: Class[Any]) -> int: ...

  @overload
  def compare(self, arg0: object, arg1: object) -> int: ...

  @overload
  def compare(self, arg0: object, arg1: object) -> int: ...

  def equals(self, arg0: object) -> bool: ...

  def reversed(self) -> Comparator[T]: ...

  @overload
  def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

  @overload
  def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

  @overload
  def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

  def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

  def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

  def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

  @staticmethod
  @overload
  def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

  @staticmethod
  @overload
  def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

  @staticmethod
  def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

  @staticmethod
  def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

  @staticmethod
  def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

  @staticmethod
  def naturalOrder() -> Comparator[T]: ...

  @staticmethod
  def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

  @staticmethod
  def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

  @staticmethod
  def reverseOrder() -> Comparator[T]: ...


class CandleConstructor(CandleExecutable):

  def genDocs(self) -> Map[str, object]: ...

  def getDocs(self) -> RosettaConstructor: ...

  def getLuaName(self) -> str: ...

  def hasDocs(self) -> bool: ...

  def isDocsValid(self) -> bool: ...

  def __init__(self, arg0: CandleClass, arg1: Constructor[Any]): ...


class CandleElement[E]:

  def getLuaName(self) -> str: ...

  def getRenderedCode(self) -> str: ...

  def render(self, arg0: CandleRenderer[E]) -> None: ...

  def setRenderedCode(self, arg0: str) -> None: ...

  def walk(self, arg0: CandleGraph) -> None: ...

  def __init__(self, arg0: str): ...


class CandleEntity[E](CandleElement):

  def getClazz(self) -> Class[Any]: ...


class CandleExecutable[E, C](CandleElement):

  def getExecutable(self) -> E: ...

  def getParameterCount(self) -> int: ...

  def getParameters(self) -> List[CandleParameter]: ...

  def hasParameters(self) -> bool: ...

  def isFinal(self) -> bool: ...

  def isPrivate(self) -> bool: ...

  def isProtected(self) -> bool: ...

  def isPublic(self) -> bool: ...

  def isStatic(self) -> bool: ...

  def toString(self) -> str: ...

  def __init__(self, arg0: E): ...


class CandleExecutableCluster[C](CandleElement):

  def add(self, arg0: C) -> None: ...

  def getExecutables(self) -> List[C]: ...

  def hasOverloads(self) -> bool: ...

  def onWalk(self, arg0: CandleGraph) -> None: ...

  def __init__(self, arg0: str): ...


class CandleExecutableComparator:

  @overload
  def compare(self, arg0: CandleExecutable, arg1: CandleExecutable) -> int: ...

  @overload
  def compare(self, arg0: object, arg1: object) -> int: ...

  @overload
  def compare(self, arg0: object, arg1: object) -> int: ...

  def equals(self, arg0: object) -> bool: ...

  def reversed(self) -> Comparator[T]: ...

  @overload
  def thenComparing(self, arg0: Comparator[T]) -> Comparator[T]: ...

  @overload
  def thenComparing(self, arg0: Function[T, U]) -> Comparator[T]: ...

  @overload
  def thenComparing(self, arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

  def thenComparingDouble(self, arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

  def thenComparingInt(self, arg0: ToIntFunction[T]) -> Comparator[T]: ...

  def thenComparingLong(self, arg0: ToLongFunction[T]) -> Comparator[T]: ...

  @staticmethod
  @overload
  def comparing(arg0: Function[T, U]) -> Comparator[T]: ...

  @staticmethod
  @overload
  def comparing(arg0: Function[T, U], arg1: Comparator[U]) -> Comparator[T]: ...

  @staticmethod
  def comparingDouble(arg0: ToDoubleFunction[T]) -> Comparator[T]: ...

  @staticmethod
  def comparingInt(arg0: ToIntFunction[T]) -> Comparator[T]: ...

  @staticmethod
  def comparingLong(arg0: ToLongFunction[T]) -> Comparator[T]: ...

  @staticmethod
  def naturalOrder() -> Comparator[T]: ...

  @staticmethod
  def nullsFirst(arg0: Comparator[T]) -> Comparator[T]: ...

  @staticmethod
  def nullsLast(arg0: Comparator[T]) -> Comparator[T]: ...

  @staticmethod
  def reverseOrder() -> Comparator[T]: ...

  def __init__(self): ...


class CandleField(CandleEntity):

  def genDocs(self) -> Map[str, object]: ...

  def getBasicType(self) -> str: ...

  def getClazz(self) -> Class: ...

  def getDocs(self) -> RosettaField: ...

  def getFullType(self) -> str: ...

  def getName(self) -> str: ...

  def hasDocs(self) -> bool: ...

  def isDocsValid(self) -> bool: ...

  def isFinal(self) -> bool: ...

  def isPrivate(self) -> bool: ...

  def isProtected(self) -> bool: ...

  def isPublic(self) -> bool: ...

  def isStatic(self) -> bool: ...


class CandleGraph:

  @overload
  def addAlias(self, arg0: CandleAlias) -> None: ...

  @overload
  def addAlias(self, arg0: Class[Any]) -> None: ...

  @overload
  def addClass(self, arg0: CandleClass) -> None: ...

  @overload
  def addClass(self, arg0: Class[Any]) -> None: ...

  def evaluate(self, arg0: Class[Any]) -> None: ...

  def getDocs(self) -> Rosetta: ...

  def hasDocs(self) -> bool: ...

  def isAlias(self, arg0: Class[Any]) -> bool: ...

  def isClass(self, arg0: Class[Any]) -> bool: ...

  def isExposedClass(self, arg0: Class[Any]) -> bool: ...

  def render(self, arg0: CandleRenderAdapter) -> None: ...

  def save(self, arg0: File) -> None: ...

  def walk(self, arg0: bool) -> None: ...

  def walkEverything(self) -> None: ...

  def walkLegacy(self) -> None: ...

  @staticmethod
  def write(arg0: File, arg1: str) -> None: ...

  def __init__(self):
    self.aliasessorted: List[CandleAlias]
    self.classbag: CandleClassBag
    self.classes: Map[Class[Any], CandleClass]
    self.classessorted: List[CandleClass]


class CandleMethod(CandleExecutable):

  def genDocs(self) -> Map[str, object]: ...

  def getBasicReturnType(self) -> str: ...

  def getDocs(self) -> RosettaMethod: ...

  def getFullReturnType(self) -> str: ...

  def getLuaName(self) -> str: ...

  def getReturnType(self) -> Class[Any]: ...

  def hasDocs(self) -> bool: ...

  def isDocsValid(self) -> bool: ...

  def isExposed(self) -> bool: ...

  def __init__(self, arg0: CandleClass, arg1: Method): ...


class CandleParameter(CandleEntity):

  def genDocs(self) -> Map[str, object]: ...

  def getBasicType(self) -> str: ...

  def getClazz(self) -> Class: ...

  def getDocs(self) -> RosettaParameter: ...

  def getFullType(self) -> str: ...

  def getJavaParameter(self) -> Parameter: ...

  def getLuaName(self) -> str: ...

  def hasDocs(self) -> bool: ...

  def hasNotes(self) -> bool: ...

  def isDocsValid(self) -> bool: ...

  def isVarArgs(self) -> bool: ...


class CandleRenderAdapter:

  def getAliasRenderer(self) -> CandleRenderer[CandleAlias]: ...

  def getClassRenderer(self) -> CandleRenderer[CandleClass]: ...


class CandleRenderer[E]:

  def onRender(self, arg0: E) -> str: ...


class CandleUtils:

  @staticmethod
  def asBasicType(arg0: str) -> str: ...

  @staticmethod
  def commaSplit(arg0: str) -> List[str]: ...

  @staticmethod
  def extractClasses(arg0: str, arg1: bool) -> List[str]: ...

  @staticmethod
  def getAllClassTypes(arg0: Class[Any]) -> List[Class[Any]]: ...

  @staticmethod
  def getFullClassType(arg0: Class[Any]) -> str: ...

  @staticmethod
  def getFullParameterType(arg0: Parameter) -> str: ...

  @staticmethod
  def getFullReturnType(arg0: Method) -> str: ...

  @staticmethod
  @overload
  def getFullType(arg0: Field) -> str: ...

  @staticmethod
  @overload
  def getFullType(arg0: Type) -> str: ...

  @staticmethod
  def main(arg0: list[str]) -> None: ...

  @staticmethod
  def resolveList(arg0: List[str]) -> List[Class[Any]]: ...


class ClassLoadParser:

  def parse(self, arg0: str) -> None: ...

  @staticmethod
  def main(arg0: list[str]) -> None: ...

  def __init__(self):
    self.classes: List[Class[Any]]


class InstrumentHook:

  @staticmethod
  def getInstrumentation() -> Instrumentation: ...

  @staticmethod
  def premain(arg0: str, arg1: Instrumentation) -> None: ...

  def __init__(self): ...

