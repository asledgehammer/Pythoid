from typing import Any, overload, TypeVar
from java.lang.annotation import Annotation
from java.lang import Class, Enum, CharSequence
from java.lang.annotation import Annotation
from java.util import Map, List, Set
from java.util.stream import IntStream
from javax.lang.model.type import DeclaredType, TypeMirror

R = TypeVar('R', default=Any)
P = TypeVar('P', default=Any)
A = TypeVar('A', default=Any)

class AnnotationMirror:

  def getAnnotationType(self) -> DeclaredType: ...

  def getElementValues(self) -> Map[ExecutableElement, AnnotationValue]: ...


class AnnotationValue:

  def accept(self, arg0: AnnotationValueVisitor[R, P], arg1: object) -> object: ...

  def getValue(self) -> object: ...

  def toString(self) -> str: ...


class AnnotationValueVisitor[R, P]:

  @overload
  def visit(self, arg0: AnnotationValue) -> object: ...

  @overload
  def visit(self, arg0: AnnotationValue, arg1: object) -> object: ...

  def visitAnnotation(self, arg0: AnnotationMirror, arg1: object) -> object: ...

  def visitArray(self, arg0: List[AnnotationValue], arg1: object) -> object: ...

  def visitBoolean(self, arg0: bool, arg1: object) -> object: ...

  def visitByte(self, arg0: int, arg1: object) -> object: ...

  def visitChar(self, arg0: str, arg1: object) -> object: ...

  def visitDouble(self, arg0: float, arg1: object) -> object: ...

  def visitEnumConstant(self, arg0: VariableElement, arg1: object) -> object: ...

  def visitFloat(self, arg0: float, arg1: object) -> object: ...

  def visitInt(self, arg0: int, arg1: object) -> object: ...

  def visitLong(self, arg0: int, arg1: object) -> object: ...

  def visitShort(self, arg0: int, arg1: object) -> object: ...

  def visitString(self, arg0: str, arg1: object) -> object: ...

  def visitType(self, arg0: TypeMirror, arg1: object) -> object: ...

  def visitUnknown(self, arg0: AnnotationValue, arg1: object) -> object: ...


class Element:

  def accept(self, arg0: ElementVisitor[R, P], arg1: object) -> object: ...

  def asType(self) -> TypeMirror: ...

  def equals(self, arg0: object) -> bool: ...

  @overload
  def getAnnotation(self, arg0: Class[A]) -> A: ...

  @overload
  def getAnnotation(self, arg0: Class[A]) -> A: ...

  @overload
  def getAnnotationMirrors(self) -> List[AnnotationMirror]: ...

  @overload
  def getAnnotationMirrors(self) -> List[AnnotationMirror]: ...

  @overload
  def getAnnotationsByType(self, arg0: Class[A]) -> list[Annotation]: ...

  @overload
  def getAnnotationsByType(self, arg0: Class[A]) -> list[Annotation]: ...

  def getEnclosedElements(self) -> List[Element]: ...

  def getEnclosingElement(self) -> Element: ...

  def getKind(self) -> ElementKind: ...

  def getModifiers(self) -> Set[Modifier]: ...

  def getSimpleName(self) -> Name: ...

  def hashCode(self) -> int: ...


class ElementKind(Enum):

  ANNOTATION_TYPE: ElementKind

  BINDING_VARIABLE: ElementKind

  CONSTRUCTOR: ElementKind

  ENUM: ElementKind

  ENUM_CONSTANT: ElementKind

  EXCEPTION_PARAMETER: ElementKind

  FIELD: ElementKind

  INSTANCE_INIT: ElementKind

  INTERFACE: ElementKind

  LOCAL_VARIABLE: ElementKind

  METHOD: ElementKind

  MODULE: ElementKind

  OTHER: ElementKind

  PACKAGE: ElementKind

  PARAMETER: ElementKind

  RECORD: ElementKind

  RECORD_COMPONENT: ElementKind

  RESOURCE_VARIABLE: ElementKind

  STATIC_INIT: ElementKind

  TYPE_PARAMETER: ElementKind

  def isClass(self) -> bool: ...

  def isField(self) -> bool: ...

  def isInterface(self) -> bool: ...

  @staticmethod
  def valueOf(arg0: str) -> ElementKind: ...

  @staticmethod
  def values() -> list[ElementKind]: ...


class ElementVisitor[R, P]:

  @overload
  def visit(self, arg0: Element) -> object: ...

  @overload
  def visit(self, arg0: Element, arg1: object) -> object: ...

  def visitExecutable(self, arg0: ExecutableElement, arg1: object) -> object: ...

  def visitModule(self, arg0: ModuleElement, arg1: object) -> object: ...

  def visitPackage(self, arg0: PackageElement, arg1: object) -> object: ...

  def visitRecordComponent(self, arg0: RecordComponentElement, arg1: object) -> object: ...

  def visitType(self, arg0: TypeElement, arg1: object) -> object: ...

  def visitTypeParameter(self, arg0: TypeParameterElement, arg1: object) -> object: ...

  def visitUnknown(self, arg0: Element, arg1: object) -> object: ...

  def visitVariable(self, arg0: VariableElement, arg1: object) -> object: ...


class ExecutableElement:

  def accept(self, arg0: ElementVisitor[R, P], arg1: object) -> object: ...

  @overload
  def asType(self) -> TypeMirror: ...

  @overload
  def asType(self) -> TypeMirror: ...

  def equals(self, arg0: object) -> bool: ...

  def getAnnotation(self, arg0: Class[A]) -> A: ...

  def getAnnotationMirrors(self) -> List[AnnotationMirror]: ...

  def getAnnotationsByType(self, arg0: Class[A]) -> list[Annotation]: ...

  def getDefaultValue(self) -> AnnotationValue: ...

  def getEnclosedElements(self) -> List[Element]: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  def getKind(self) -> ElementKind: ...

  def getModifiers(self) -> Set[Modifier]: ...

  def getParameters(self) -> List[VariableElement]: ...

  def getReceiverType(self) -> TypeMirror: ...

  def getReturnType(self) -> TypeMirror: ...

  @overload
  def getSimpleName(self) -> Name: ...

  @overload
  def getSimpleName(self) -> Name: ...

  def getThrownTypes(self) -> List[TypeMirror]: ...

  @overload
  def getTypeParameters(self) -> List[TypeParameterElement]: ...

  @overload
  def getTypeParameters(self) -> List[TypeParameterElement]: ...

  def hashCode(self) -> int: ...

  def isDefault(self) -> bool: ...

  def isVarArgs(self) -> bool: ...


class Modifier(Enum):

  ABSTRACT: Modifier

  DEFAULT: Modifier

  FINAL: Modifier

  NATIVE: Modifier

  NON_SEALED: Modifier

  PRIVATE: Modifier

  PROTECTED: Modifier

  PUBLIC: Modifier

  SEALED: Modifier

  STATIC: Modifier

  STRICTFP: Modifier

  SYNCHRONIZED: Modifier

  TRANSIENT: Modifier

  VOLATILE: Modifier

  def toString(self) -> str: ...

  @staticmethod
  def valueOf(arg0: str) -> Modifier: ...

  @staticmethod
  def values() -> list[Modifier]: ...


class ModuleElement:

  def accept(self, arg0: ElementVisitor[R, P], arg1: object) -> object: ...

  @overload
  def asType(self) -> TypeMirror: ...

  @overload
  def asType(self) -> TypeMirror: ...

  def equals(self, arg0: object) -> bool: ...

  def getAnnotation(self, arg0: Class[A]) -> A: ...

  def getAnnotationMirrors(self) -> List[AnnotationMirror]: ...

  def getAnnotationsByType(self, arg0: Class[A]) -> list[Annotation]: ...

  def getDirectives(self) -> List[ModuleElement.Directive]: ...

  @overload
  def getEnclosedElements(self) -> List[Element]: ...

  @overload
  def getEnclosedElements(self) -> List[Element]: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  def getKind(self) -> ElementKind: ...

  def getModifiers(self) -> Set[Modifier]: ...

  @overload
  def getQualifiedName(self) -> Name: ...

  @overload
  def getQualifiedName(self) -> Name: ...

  @overload
  def getSimpleName(self) -> Name: ...

  @overload
  def getSimpleName(self) -> Name: ...

  def hashCode(self) -> int: ...

  def isOpen(self) -> bool: ...

  def isUnnamed(self) -> bool: ...

  class UsesDirective:

    def accept(self, arg0: ModuleElement.DirectiveVisitor, arg1: object) -> object: ...

    def getKind(self) -> ModuleElement.DirectiveKind: ...

    def getService(self) -> TypeElement: ...

  class ProvidesDirective:

    def accept(self, arg0: ModuleElement.DirectiveVisitor, arg1: object) -> object: ...

    def getImplementations(self) -> List[TypeElement]: ...

    def getKind(self) -> ModuleElement.DirectiveKind: ...

    def getService(self) -> TypeElement: ...

  class OpensDirective:

    def accept(self, arg0: ModuleElement.DirectiveVisitor, arg1: object) -> object: ...

    def getKind(self) -> ModuleElement.DirectiveKind: ...

    def getPackage(self) -> PackageElement: ...

    def getTargetModules(self) -> List[ModuleElement]: ...

  class ExportsDirective:

    def accept(self, arg0: ModuleElement.DirectiveVisitor, arg1: object) -> object: ...

    def getKind(self) -> ModuleElement.DirectiveKind: ...

    def getPackage(self) -> PackageElement: ...

    def getTargetModules(self) -> List[ModuleElement]: ...

  class RequiresDirective:

    def accept(self, arg0: ModuleElement.DirectiveVisitor, arg1: object) -> object: ...

    def getDependency(self) -> ModuleElement: ...

    def getKind(self) -> ModuleElement.DirectiveKind: ...

    def isStatic(self) -> bool: ...

    def isTransitive(self) -> bool: ...

  class DirectiveVisitor[R, P]:

    @overload
    def visit(self, arg0: ModuleElement.Directive) -> object: ...

    @overload
    def visit(self, arg0: ModuleElement.Directive, arg1: object) -> object: ...

    def visitExports(self, arg0: ModuleElement.ExportsDirective, arg1: object) -> object: ...

    def visitOpens(self, arg0: ModuleElement.OpensDirective, arg1: object) -> object: ...

    def visitProvides(self, arg0: ModuleElement.ProvidesDirective, arg1: object) -> object: ...

    def visitRequires(self, arg0: ModuleElement.RequiresDirective, arg1: object) -> object: ...

    def visitUnknown(self, arg0: ModuleElement.Directive, arg1: object) -> object: ...

    def visitUses(self, arg0: ModuleElement.UsesDirective, arg1: object) -> object: ...

  class Directive:

    def accept(self, arg0: ModuleElement.DirectiveVisitor, arg1: object) -> object: ...

    def getKind(self) -> ModuleElement.DirectiveKind: ...

  class DirectiveKind(Enum):

    EXPORTS: ModuleElement.DirectiveKind

    OPENS: ModuleElement.DirectiveKind

    PROVIDES: ModuleElement.DirectiveKind

    REQUIRES: ModuleElement.DirectiveKind

    USES: ModuleElement.DirectiveKind

    @staticmethod
    def valueOf(arg0: str) -> ModuleElement.DirectiveKind: ...

    @staticmethod
    def values() -> list[ModuleElement.DirectiveKind]: ...


class Name:

  def charAt(self, arg0: int) -> str: ...

  def chars(self) -> IntStream: ...

  def codePoints(self) -> IntStream: ...

  def contentEquals(self, arg0: CharSequence) -> bool: ...

  def equals(self, arg0: object) -> bool: ...

  def hashCode(self) -> int: ...

  def isEmpty(self) -> bool: ...

  def length(self) -> int: ...

  def subSequence(self, arg0: int, arg1: int) -> CharSequence: ...

  def toString(self) -> str: ...

  @staticmethod
  def compare(arg0: CharSequence, arg1: CharSequence) -> int: ...


class NestingKind(Enum):

  ANONYMOUS: NestingKind

  LOCAL: NestingKind

  MEMBER: NestingKind

  TOP_LEVEL: NestingKind

  def isNested(self) -> bool: ...

  @staticmethod
  def valueOf(arg0: str) -> NestingKind: ...

  @staticmethod
  def values() -> list[NestingKind]: ...


class PackageElement:

  def accept(self, arg0: ElementVisitor[R, P], arg1: object) -> object: ...

  @overload
  def asType(self) -> TypeMirror: ...

  @overload
  def asType(self) -> TypeMirror: ...

  def equals(self, arg0: object) -> bool: ...

  def getAnnotation(self, arg0: Class[A]) -> A: ...

  def getAnnotationMirrors(self) -> List[AnnotationMirror]: ...

  def getAnnotationsByType(self, arg0: Class[A]) -> list[Annotation]: ...

  @overload
  def getEnclosedElements(self) -> List[Element]: ...

  @overload
  def getEnclosedElements(self) -> List[Element]: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  def getKind(self) -> ElementKind: ...

  def getModifiers(self) -> Set[Modifier]: ...

  @overload
  def getQualifiedName(self) -> Name: ...

  @overload
  def getQualifiedName(self) -> Name: ...

  @overload
  def getSimpleName(self) -> Name: ...

  @overload
  def getSimpleName(self) -> Name: ...

  def hashCode(self) -> int: ...

  def isUnnamed(self) -> bool: ...


class RecordComponentElement:

  def accept(self, arg0: ElementVisitor[R, P], arg1: object) -> object: ...

  def asType(self) -> TypeMirror: ...

  def equals(self, arg0: object) -> bool: ...

  def getAccessor(self) -> ExecutableElement: ...

  def getAnnotation(self, arg0: Class[A]) -> A: ...

  def getAnnotationMirrors(self) -> List[AnnotationMirror]: ...

  def getAnnotationsByType(self, arg0: Class[A]) -> list[Annotation]: ...

  def getEnclosedElements(self) -> List[Element]: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  def getKind(self) -> ElementKind: ...

  def getModifiers(self) -> Set[Modifier]: ...

  @overload
  def getSimpleName(self) -> Name: ...

  @overload
  def getSimpleName(self) -> Name: ...

  def hashCode(self) -> int: ...


class TypeElement:

  def accept(self, arg0: ElementVisitor[R, P], arg1: object) -> object: ...

  @overload
  def asType(self) -> TypeMirror: ...

  @overload
  def asType(self) -> TypeMirror: ...

  def equals(self, arg0: object) -> bool: ...

  def getAnnotation(self, arg0: Class[A]) -> A: ...

  def getAnnotationMirrors(self) -> List[AnnotationMirror]: ...

  def getAnnotationsByType(self, arg0: Class[A]) -> list[Annotation]: ...

  @overload
  def getEnclosedElements(self) -> List[Element]: ...

  @overload
  def getEnclosedElements(self) -> List[Element]: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  def getInterfaces(self) -> List[TypeMirror]: ...

  def getKind(self) -> ElementKind: ...

  def getModifiers(self) -> Set[Modifier]: ...

  def getNestingKind(self) -> NestingKind: ...

  def getPermittedSubclasses(self) -> List[TypeMirror]: ...

  @overload
  def getQualifiedName(self) -> Name: ...

  @overload
  def getQualifiedName(self) -> Name: ...

  def getRecordComponents(self) -> List[RecordComponentElement]: ...

  @overload
  def getSimpleName(self) -> Name: ...

  @overload
  def getSimpleName(self) -> Name: ...

  def getSuperclass(self) -> TypeMirror: ...

  @overload
  def getTypeParameters(self) -> List[TypeParameterElement]: ...

  @overload
  def getTypeParameters(self) -> List[TypeParameterElement]: ...

  def hashCode(self) -> int: ...


class TypeParameterElement:

  def accept(self, arg0: ElementVisitor[R, P], arg1: object) -> object: ...

  @overload
  def asType(self) -> TypeMirror: ...

  @overload
  def asType(self) -> TypeMirror: ...

  def equals(self, arg0: object) -> bool: ...

  def getAnnotation(self, arg0: Class[A]) -> A: ...

  def getAnnotationMirrors(self) -> List[AnnotationMirror]: ...

  def getAnnotationsByType(self, arg0: Class[A]) -> list[Annotation]: ...

  def getBounds(self) -> List[TypeMirror]: ...

  def getEnclosedElements(self) -> List[Element]: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  def getGenericElement(self) -> Element: ...

  def getKind(self) -> ElementKind: ...

  def getModifiers(self) -> Set[Modifier]: ...

  def getSimpleName(self) -> Name: ...

  def hashCode(self) -> int: ...


class VariableElement:

  def accept(self, arg0: ElementVisitor[R, P], arg1: object) -> object: ...

  @overload
  def asType(self) -> TypeMirror: ...

  @overload
  def asType(self) -> TypeMirror: ...

  def equals(self, arg0: object) -> bool: ...

  def getAnnotation(self, arg0: Class[A]) -> A: ...

  def getAnnotationMirrors(self) -> List[AnnotationMirror]: ...

  def getAnnotationsByType(self, arg0: Class[A]) -> list[Annotation]: ...

  def getConstantValue(self) -> object: ...

  def getEnclosedElements(self) -> List[Element]: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  @overload
  def getEnclosingElement(self) -> Element: ...

  def getKind(self) -> ElementKind: ...

  def getModifiers(self) -> Set[Modifier]: ...

  @overload
  def getSimpleName(self) -> Name: ...

  @overload
  def getSimpleName(self) -> Name: ...

  def hashCode(self) -> int: ...

